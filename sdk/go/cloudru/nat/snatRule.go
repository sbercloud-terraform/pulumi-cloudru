// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package nat

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sbercloud-terraform/pulumi-cloudru/sdk/go/cloudru/internal"
)

// Manages a Snat rule resource within SberCloud Nat
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/sbercloud-terraform/pulumi-cloudru/sdk/go/cloudru/nat"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := nat.NewSnatRule(ctx, "snat_1", &nat.SnatRuleArgs{
//				NatGatewayId: pulumi.String("3c0dffda-7c76-452b-9dcc-5bce7ae56b17"),
//				NetworkId:    pulumi.String("dc8632e2-d9ff-41b1-aa0c-d455557314a0"),
//				FloatingIpId: pulumi.String("0a166fc5-a904-42fb-b1ef-cf18afeeddca"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Snat can be imported using the following format:
//
// ```sh
// $ pulumi import sbercloud:Nat/snatRule:SnatRule snat_1 9e0713cb-0a2f-484e-8c7d-daecbb61dbe4
// ```
type SnatRule struct {
	pulumi.CustomResourceState

	// Specifies CIDR, which can be in the format of a network segment or a host IP address.
	// This parameter and `networkId` are alternative. Changing this creates a new snat rule.
	Cidr pulumi.StringPtrOutput `pulumi:"cidr"`
	// The creation time of the SNAT rule.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Specifies the description of the SNAT rule.
	// The value is a string of no more than `255` characters, and angle brackets (<>) are not allowed.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The actual floating IP address.
	FloatingIpAddress pulumi.StringOutput `pulumi:"floatingIpAddress"`
	// ID of the floating ip this snat rule connets to.
	// Changing this creates a new snat rule.
	FloatingIpId pulumi.StringOutput `pulumi:"floatingIpId"`
	// The frozen EIP associated with the SNAT rule.
	FreezedIpAddress pulumi.StringOutput `pulumi:"freezedIpAddress"`
	// The global EIP addresses (separated by commas) connected by SNAT rule.
	GlobalEipAddress pulumi.StringOutput `pulumi:"globalEipAddress"`
	// The IDs (separated by commas) of global EIPs connected by SNAT rule.
	GlobalEipId pulumi.StringOutput `pulumi:"globalEipId"`
	// ID of the nat gateway this snat rule belongs to.
	// Changing this creates a new snat rule.
	NatGatewayId pulumi.StringOutput `pulumi:"natGatewayId"`
	// Deprecated: schema: Deprecated; Use 'subnet_id' instead.
	NetworkId pulumi.StringPtrOutput `pulumi:"networkId"`
	// The region in which to create the snat rule resource. If omitted, the provider-level region will be used. Changing this creates a new snat rule resource.
	Region pulumi.StringOutput `pulumi:"region"`
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct Connect scenario).
	// Defaults to 0, only `cidr` can be specified over a Direct Connect connection.
	// Changing this creates a new snat rule.
	SourceType pulumi.IntPtrOutput `pulumi:"sourceType"`
	// The status of the snat rule.
	Status pulumi.StringOutput `pulumi:"status"`
	// Specifies the network IDs of subnet connected by SNAT rule (VPC side).\
	// This parameter and `cidr` are alternative. Changing this will create a new resource.
	SubnetId pulumi.StringOutput `pulumi:"subnetId"`
}

// NewSnatRule registers a new resource with the given unique name, arguments, and options.
func NewSnatRule(ctx *pulumi.Context,
	name string, args *SnatRuleArgs, opts ...pulumi.ResourceOption) (*SnatRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.NatGatewayId == nil {
		return nil, errors.New("invalid value for required argument 'NatGatewayId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SnatRule
	err := ctx.RegisterResource("sbercloud:Nat/snatRule:SnatRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSnatRule gets an existing SnatRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSnatRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SnatRuleState, opts ...pulumi.ResourceOption) (*SnatRule, error) {
	var resource SnatRule
	err := ctx.ReadResource("sbercloud:Nat/snatRule:SnatRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SnatRule resources.
type snatRuleState struct {
	// Specifies CIDR, which can be in the format of a network segment or a host IP address.
	// This parameter and `networkId` are alternative. Changing this creates a new snat rule.
	Cidr *string `pulumi:"cidr"`
	// The creation time of the SNAT rule.
	CreatedAt *string `pulumi:"createdAt"`
	// Specifies the description of the SNAT rule.
	// The value is a string of no more than `255` characters, and angle brackets (<>) are not allowed.
	Description *string `pulumi:"description"`
	// The actual floating IP address.
	FloatingIpAddress *string `pulumi:"floatingIpAddress"`
	// ID of the floating ip this snat rule connets to.
	// Changing this creates a new snat rule.
	FloatingIpId *string `pulumi:"floatingIpId"`
	// The frozen EIP associated with the SNAT rule.
	FreezedIpAddress *string `pulumi:"freezedIpAddress"`
	// The global EIP addresses (separated by commas) connected by SNAT rule.
	GlobalEipAddress *string `pulumi:"globalEipAddress"`
	// The IDs (separated by commas) of global EIPs connected by SNAT rule.
	GlobalEipId *string `pulumi:"globalEipId"`
	// ID of the nat gateway this snat rule belongs to.
	// Changing this creates a new snat rule.
	NatGatewayId *string `pulumi:"natGatewayId"`
	// Deprecated: schema: Deprecated; Use 'subnet_id' instead.
	NetworkId *string `pulumi:"networkId"`
	// The region in which to create the snat rule resource. If omitted, the provider-level region will be used. Changing this creates a new snat rule resource.
	Region *string `pulumi:"region"`
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct Connect scenario).
	// Defaults to 0, only `cidr` can be specified over a Direct Connect connection.
	// Changing this creates a new snat rule.
	SourceType *int `pulumi:"sourceType"`
	// The status of the snat rule.
	Status *string `pulumi:"status"`
	// Specifies the network IDs of subnet connected by SNAT rule (VPC side).\
	// This parameter and `cidr` are alternative. Changing this will create a new resource.
	SubnetId *string `pulumi:"subnetId"`
}

type SnatRuleState struct {
	// Specifies CIDR, which can be in the format of a network segment or a host IP address.
	// This parameter and `networkId` are alternative. Changing this creates a new snat rule.
	Cidr pulumi.StringPtrInput
	// The creation time of the SNAT rule.
	CreatedAt pulumi.StringPtrInput
	// Specifies the description of the SNAT rule.
	// The value is a string of no more than `255` characters, and angle brackets (<>) are not allowed.
	Description pulumi.StringPtrInput
	// The actual floating IP address.
	FloatingIpAddress pulumi.StringPtrInput
	// ID of the floating ip this snat rule connets to.
	// Changing this creates a new snat rule.
	FloatingIpId pulumi.StringPtrInput
	// The frozen EIP associated with the SNAT rule.
	FreezedIpAddress pulumi.StringPtrInput
	// The global EIP addresses (separated by commas) connected by SNAT rule.
	GlobalEipAddress pulumi.StringPtrInput
	// The IDs (separated by commas) of global EIPs connected by SNAT rule.
	GlobalEipId pulumi.StringPtrInput
	// ID of the nat gateway this snat rule belongs to.
	// Changing this creates a new snat rule.
	NatGatewayId pulumi.StringPtrInput
	// Deprecated: schema: Deprecated; Use 'subnet_id' instead.
	NetworkId pulumi.StringPtrInput
	// The region in which to create the snat rule resource. If omitted, the provider-level region will be used. Changing this creates a new snat rule resource.
	Region pulumi.StringPtrInput
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct Connect scenario).
	// Defaults to 0, only `cidr` can be specified over a Direct Connect connection.
	// Changing this creates a new snat rule.
	SourceType pulumi.IntPtrInput
	// The status of the snat rule.
	Status pulumi.StringPtrInput
	// Specifies the network IDs of subnet connected by SNAT rule (VPC side).\
	// This parameter and `cidr` are alternative. Changing this will create a new resource.
	SubnetId pulumi.StringPtrInput
}

func (SnatRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*snatRuleState)(nil)).Elem()
}

type snatRuleArgs struct {
	// Specifies CIDR, which can be in the format of a network segment or a host IP address.
	// This parameter and `networkId` are alternative. Changing this creates a new snat rule.
	Cidr *string `pulumi:"cidr"`
	// Specifies the description of the SNAT rule.
	// The value is a string of no more than `255` characters, and angle brackets (<>) are not allowed.
	Description *string `pulumi:"description"`
	// ID of the floating ip this snat rule connets to.
	// Changing this creates a new snat rule.
	FloatingIpId *string `pulumi:"floatingIpId"`
	// The IDs (separated by commas) of global EIPs connected by SNAT rule.
	GlobalEipId *string `pulumi:"globalEipId"`
	// ID of the nat gateway this snat rule belongs to.
	// Changing this creates a new snat rule.
	NatGatewayId string `pulumi:"natGatewayId"`
	// Deprecated: schema: Deprecated; Use 'subnet_id' instead.
	NetworkId *string `pulumi:"networkId"`
	// The region in which to create the snat rule resource. If omitted, the provider-level region will be used. Changing this creates a new snat rule resource.
	Region *string `pulumi:"region"`
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct Connect scenario).
	// Defaults to 0, only `cidr` can be specified over a Direct Connect connection.
	// Changing this creates a new snat rule.
	SourceType *int `pulumi:"sourceType"`
	// Specifies the network IDs of subnet connected by SNAT rule (VPC side).\
	// This parameter and `cidr` are alternative. Changing this will create a new resource.
	SubnetId *string `pulumi:"subnetId"`
}

// The set of arguments for constructing a SnatRule resource.
type SnatRuleArgs struct {
	// Specifies CIDR, which can be in the format of a network segment or a host IP address.
	// This parameter and `networkId` are alternative. Changing this creates a new snat rule.
	Cidr pulumi.StringPtrInput
	// Specifies the description of the SNAT rule.
	// The value is a string of no more than `255` characters, and angle brackets (<>) are not allowed.
	Description pulumi.StringPtrInput
	// ID of the floating ip this snat rule connets to.
	// Changing this creates a new snat rule.
	FloatingIpId pulumi.StringPtrInput
	// The IDs (separated by commas) of global EIPs connected by SNAT rule.
	GlobalEipId pulumi.StringPtrInput
	// ID of the nat gateway this snat rule belongs to.
	// Changing this creates a new snat rule.
	NatGatewayId pulumi.StringInput
	// Deprecated: schema: Deprecated; Use 'subnet_id' instead.
	NetworkId pulumi.StringPtrInput
	// The region in which to create the snat rule resource. If omitted, the provider-level region will be used. Changing this creates a new snat rule resource.
	Region pulumi.StringPtrInput
	// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct Connect scenario).
	// Defaults to 0, only `cidr` can be specified over a Direct Connect connection.
	// Changing this creates a new snat rule.
	SourceType pulumi.IntPtrInput
	// Specifies the network IDs of subnet connected by SNAT rule (VPC side).\
	// This parameter and `cidr` are alternative. Changing this will create a new resource.
	SubnetId pulumi.StringPtrInput
}

func (SnatRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*snatRuleArgs)(nil)).Elem()
}

type SnatRuleInput interface {
	pulumi.Input

	ToSnatRuleOutput() SnatRuleOutput
	ToSnatRuleOutputWithContext(ctx context.Context) SnatRuleOutput
}

func (*SnatRule) ElementType() reflect.Type {
	return reflect.TypeOf((**SnatRule)(nil)).Elem()
}

func (i *SnatRule) ToSnatRuleOutput() SnatRuleOutput {
	return i.ToSnatRuleOutputWithContext(context.Background())
}

func (i *SnatRule) ToSnatRuleOutputWithContext(ctx context.Context) SnatRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SnatRuleOutput)
}

// SnatRuleArrayInput is an input type that accepts SnatRuleArray and SnatRuleArrayOutput values.
// You can construct a concrete instance of `SnatRuleArrayInput` via:
//
//	SnatRuleArray{ SnatRuleArgs{...} }
type SnatRuleArrayInput interface {
	pulumi.Input

	ToSnatRuleArrayOutput() SnatRuleArrayOutput
	ToSnatRuleArrayOutputWithContext(context.Context) SnatRuleArrayOutput
}

type SnatRuleArray []SnatRuleInput

func (SnatRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SnatRule)(nil)).Elem()
}

func (i SnatRuleArray) ToSnatRuleArrayOutput() SnatRuleArrayOutput {
	return i.ToSnatRuleArrayOutputWithContext(context.Background())
}

func (i SnatRuleArray) ToSnatRuleArrayOutputWithContext(ctx context.Context) SnatRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SnatRuleArrayOutput)
}

// SnatRuleMapInput is an input type that accepts SnatRuleMap and SnatRuleMapOutput values.
// You can construct a concrete instance of `SnatRuleMapInput` via:
//
//	SnatRuleMap{ "key": SnatRuleArgs{...} }
type SnatRuleMapInput interface {
	pulumi.Input

	ToSnatRuleMapOutput() SnatRuleMapOutput
	ToSnatRuleMapOutputWithContext(context.Context) SnatRuleMapOutput
}

type SnatRuleMap map[string]SnatRuleInput

func (SnatRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SnatRule)(nil)).Elem()
}

func (i SnatRuleMap) ToSnatRuleMapOutput() SnatRuleMapOutput {
	return i.ToSnatRuleMapOutputWithContext(context.Background())
}

func (i SnatRuleMap) ToSnatRuleMapOutputWithContext(ctx context.Context) SnatRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SnatRuleMapOutput)
}

type SnatRuleOutput struct{ *pulumi.OutputState }

func (SnatRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SnatRule)(nil)).Elem()
}

func (o SnatRuleOutput) ToSnatRuleOutput() SnatRuleOutput {
	return o
}

func (o SnatRuleOutput) ToSnatRuleOutputWithContext(ctx context.Context) SnatRuleOutput {
	return o
}

// Specifies CIDR, which can be in the format of a network segment or a host IP address.
// This parameter and `networkId` are alternative. Changing this creates a new snat rule.
func (o SnatRuleOutput) Cidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringPtrOutput { return v.Cidr }).(pulumi.StringPtrOutput)
}

// The creation time of the SNAT rule.
func (o SnatRuleOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Specifies the description of the SNAT rule.
// The value is a string of no more than `255` characters, and angle brackets (<>) are not allowed.
func (o SnatRuleOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The actual floating IP address.
func (o SnatRuleOutput) FloatingIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.FloatingIpAddress }).(pulumi.StringOutput)
}

// ID of the floating ip this snat rule connets to.
// Changing this creates a new snat rule.
func (o SnatRuleOutput) FloatingIpId() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.FloatingIpId }).(pulumi.StringOutput)
}

// The frozen EIP associated with the SNAT rule.
func (o SnatRuleOutput) FreezedIpAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.FreezedIpAddress }).(pulumi.StringOutput)
}

// The global EIP addresses (separated by commas) connected by SNAT rule.
func (o SnatRuleOutput) GlobalEipAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.GlobalEipAddress }).(pulumi.StringOutput)
}

// The IDs (separated by commas) of global EIPs connected by SNAT rule.
func (o SnatRuleOutput) GlobalEipId() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.GlobalEipId }).(pulumi.StringOutput)
}

// ID of the nat gateway this snat rule belongs to.
// Changing this creates a new snat rule.
func (o SnatRuleOutput) NatGatewayId() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.NatGatewayId }).(pulumi.StringOutput)
}

// Deprecated: schema: Deprecated; Use 'subnet_id' instead.
func (o SnatRuleOutput) NetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringPtrOutput { return v.NetworkId }).(pulumi.StringPtrOutput)
}

// The region in which to create the snat rule resource. If omitted, the provider-level region will be used. Changing this creates a new snat rule resource.
func (o SnatRuleOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Specifies the scenario. The valid value is 0 (VPC scenario) and 1 (Direct Connect scenario).
// Defaults to 0, only `cidr` can be specified over a Direct Connect connection.
// Changing this creates a new snat rule.
func (o SnatRuleOutput) SourceType() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.IntPtrOutput { return v.SourceType }).(pulumi.IntPtrOutput)
}

// The status of the snat rule.
func (o SnatRuleOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// Specifies the network IDs of subnet connected by SNAT rule (VPC side).\
// This parameter and `cidr` are alternative. Changing this will create a new resource.
func (o SnatRuleOutput) SubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v *SnatRule) pulumi.StringOutput { return v.SubnetId }).(pulumi.StringOutput)
}

type SnatRuleArrayOutput struct{ *pulumi.OutputState }

func (SnatRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SnatRule)(nil)).Elem()
}

func (o SnatRuleArrayOutput) ToSnatRuleArrayOutput() SnatRuleArrayOutput {
	return o
}

func (o SnatRuleArrayOutput) ToSnatRuleArrayOutputWithContext(ctx context.Context) SnatRuleArrayOutput {
	return o
}

func (o SnatRuleArrayOutput) Index(i pulumi.IntInput) SnatRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SnatRule {
		return vs[0].([]*SnatRule)[vs[1].(int)]
	}).(SnatRuleOutput)
}

type SnatRuleMapOutput struct{ *pulumi.OutputState }

func (SnatRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SnatRule)(nil)).Elem()
}

func (o SnatRuleMapOutput) ToSnatRuleMapOutput() SnatRuleMapOutput {
	return o
}

func (o SnatRuleMapOutput) ToSnatRuleMapOutputWithContext(ctx context.Context) SnatRuleMapOutput {
	return o
}

func (o SnatRuleMapOutput) MapIndex(k pulumi.StringInput) SnatRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SnatRule {
		return vs[0].(map[string]*SnatRule)[vs[1].(string)]
	}).(SnatRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SnatRuleInput)(nil)).Elem(), &SnatRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*SnatRuleArrayInput)(nil)).Elem(), SnatRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SnatRuleMapInput)(nil)).Elem(), SnatRuleMap{})
	pulumi.RegisterOutputType(SnatRuleOutput{})
	pulumi.RegisterOutputType(SnatRuleArrayOutput{})
	pulumi.RegisterOutputType(SnatRuleMapOutput{})
}
