// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cloudru

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sbercloud-terraform/pulumi-cloudru/sdk/go/cloudru/internal"
)

type CbrCheckpoint struct {
	pulumi.CustomResourceState

	// The list of backups configuration.
	Backups CbrCheckpointBackupArrayOutput `pulumi:"backups"`
	// The creation time of the checkpoint.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// The description of the checkpoint.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Whether the backups are incremental backups.
	Incremental pulumi.BoolPtrOutput `pulumi:"incremental"`
	// The name of the checkpoint.
	Name pulumi.StringOutput `pulumi:"name"`
	// The region where the vault and backup resources are located.
	Region pulumi.StringOutput `pulumi:"region"`
	// The status of the checkpoint.
	Status pulumi.StringOutput `pulumi:"status"`
	// The ID of the vault where the checkpoint to create.
	VaultId pulumi.StringOutput `pulumi:"vaultId"`
}

// NewCbrCheckpoint registers a new resource with the given unique name, arguments, and options.
func NewCbrCheckpoint(ctx *pulumi.Context,
	name string, args *CbrCheckpointArgs, opts ...pulumi.ResourceOption) (*CbrCheckpoint, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Backups == nil {
		return nil, errors.New("invalid value for required argument 'Backups'")
	}
	if args.VaultId == nil {
		return nil, errors.New("invalid value for required argument 'VaultId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CbrCheckpoint
	err := ctx.RegisterResource("sbercloud:index/cbrCheckpoint:CbrCheckpoint", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCbrCheckpoint gets an existing CbrCheckpoint resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCbrCheckpoint(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CbrCheckpointState, opts ...pulumi.ResourceOption) (*CbrCheckpoint, error) {
	var resource CbrCheckpoint
	err := ctx.ReadResource("sbercloud:index/cbrCheckpoint:CbrCheckpoint", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CbrCheckpoint resources.
type cbrCheckpointState struct {
	// The list of backups configuration.
	Backups []CbrCheckpointBackup `pulumi:"backups"`
	// The creation time of the checkpoint.
	CreatedAt *string `pulumi:"createdAt"`
	// The description of the checkpoint.
	Description *string `pulumi:"description"`
	// Whether the backups are incremental backups.
	Incremental *bool `pulumi:"incremental"`
	// The name of the checkpoint.
	Name *string `pulumi:"name"`
	// The region where the vault and backup resources are located.
	Region *string `pulumi:"region"`
	// The status of the checkpoint.
	Status *string `pulumi:"status"`
	// The ID of the vault where the checkpoint to create.
	VaultId *string `pulumi:"vaultId"`
}

type CbrCheckpointState struct {
	// The list of backups configuration.
	Backups CbrCheckpointBackupArrayInput
	// The creation time of the checkpoint.
	CreatedAt pulumi.StringPtrInput
	// The description of the checkpoint.
	Description pulumi.StringPtrInput
	// Whether the backups are incremental backups.
	Incremental pulumi.BoolPtrInput
	// The name of the checkpoint.
	Name pulumi.StringPtrInput
	// The region where the vault and backup resources are located.
	Region pulumi.StringPtrInput
	// The status of the checkpoint.
	Status pulumi.StringPtrInput
	// The ID of the vault where the checkpoint to create.
	VaultId pulumi.StringPtrInput
}

func (CbrCheckpointState) ElementType() reflect.Type {
	return reflect.TypeOf((*cbrCheckpointState)(nil)).Elem()
}

type cbrCheckpointArgs struct {
	// The list of backups configuration.
	Backups []CbrCheckpointBackup `pulumi:"backups"`
	// The description of the checkpoint.
	Description *string `pulumi:"description"`
	// Whether the backups are incremental backups.
	Incremental *bool `pulumi:"incremental"`
	// The name of the checkpoint.
	Name *string `pulumi:"name"`
	// The region where the vault and backup resources are located.
	Region *string `pulumi:"region"`
	// The ID of the vault where the checkpoint to create.
	VaultId string `pulumi:"vaultId"`
}

// The set of arguments for constructing a CbrCheckpoint resource.
type CbrCheckpointArgs struct {
	// The list of backups configuration.
	Backups CbrCheckpointBackupArrayInput
	// The description of the checkpoint.
	Description pulumi.StringPtrInput
	// Whether the backups are incremental backups.
	Incremental pulumi.BoolPtrInput
	// The name of the checkpoint.
	Name pulumi.StringPtrInput
	// The region where the vault and backup resources are located.
	Region pulumi.StringPtrInput
	// The ID of the vault where the checkpoint to create.
	VaultId pulumi.StringInput
}

func (CbrCheckpointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cbrCheckpointArgs)(nil)).Elem()
}

type CbrCheckpointInput interface {
	pulumi.Input

	ToCbrCheckpointOutput() CbrCheckpointOutput
	ToCbrCheckpointOutputWithContext(ctx context.Context) CbrCheckpointOutput
}

func (*CbrCheckpoint) ElementType() reflect.Type {
	return reflect.TypeOf((**CbrCheckpoint)(nil)).Elem()
}

func (i *CbrCheckpoint) ToCbrCheckpointOutput() CbrCheckpointOutput {
	return i.ToCbrCheckpointOutputWithContext(context.Background())
}

func (i *CbrCheckpoint) ToCbrCheckpointOutputWithContext(ctx context.Context) CbrCheckpointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbrCheckpointOutput)
}

// CbrCheckpointArrayInput is an input type that accepts CbrCheckpointArray and CbrCheckpointArrayOutput values.
// You can construct a concrete instance of `CbrCheckpointArrayInput` via:
//
//	CbrCheckpointArray{ CbrCheckpointArgs{...} }
type CbrCheckpointArrayInput interface {
	pulumi.Input

	ToCbrCheckpointArrayOutput() CbrCheckpointArrayOutput
	ToCbrCheckpointArrayOutputWithContext(context.Context) CbrCheckpointArrayOutput
}

type CbrCheckpointArray []CbrCheckpointInput

func (CbrCheckpointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CbrCheckpoint)(nil)).Elem()
}

func (i CbrCheckpointArray) ToCbrCheckpointArrayOutput() CbrCheckpointArrayOutput {
	return i.ToCbrCheckpointArrayOutputWithContext(context.Background())
}

func (i CbrCheckpointArray) ToCbrCheckpointArrayOutputWithContext(ctx context.Context) CbrCheckpointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbrCheckpointArrayOutput)
}

// CbrCheckpointMapInput is an input type that accepts CbrCheckpointMap and CbrCheckpointMapOutput values.
// You can construct a concrete instance of `CbrCheckpointMapInput` via:
//
//	CbrCheckpointMap{ "key": CbrCheckpointArgs{...} }
type CbrCheckpointMapInput interface {
	pulumi.Input

	ToCbrCheckpointMapOutput() CbrCheckpointMapOutput
	ToCbrCheckpointMapOutputWithContext(context.Context) CbrCheckpointMapOutput
}

type CbrCheckpointMap map[string]CbrCheckpointInput

func (CbrCheckpointMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CbrCheckpoint)(nil)).Elem()
}

func (i CbrCheckpointMap) ToCbrCheckpointMapOutput() CbrCheckpointMapOutput {
	return i.ToCbrCheckpointMapOutputWithContext(context.Background())
}

func (i CbrCheckpointMap) ToCbrCheckpointMapOutputWithContext(ctx context.Context) CbrCheckpointMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CbrCheckpointMapOutput)
}

type CbrCheckpointOutput struct{ *pulumi.OutputState }

func (CbrCheckpointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CbrCheckpoint)(nil)).Elem()
}

func (o CbrCheckpointOutput) ToCbrCheckpointOutput() CbrCheckpointOutput {
	return o
}

func (o CbrCheckpointOutput) ToCbrCheckpointOutputWithContext(ctx context.Context) CbrCheckpointOutput {
	return o
}

// The list of backups configuration.
func (o CbrCheckpointOutput) Backups() CbrCheckpointBackupArrayOutput {
	return o.ApplyT(func(v *CbrCheckpoint) CbrCheckpointBackupArrayOutput { return v.Backups }).(CbrCheckpointBackupArrayOutput)
}

// The creation time of the checkpoint.
func (o CbrCheckpointOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *CbrCheckpoint) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// The description of the checkpoint.
func (o CbrCheckpointOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CbrCheckpoint) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Whether the backups are incremental backups.
func (o CbrCheckpointOutput) Incremental() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CbrCheckpoint) pulumi.BoolPtrOutput { return v.Incremental }).(pulumi.BoolPtrOutput)
}

// The name of the checkpoint.
func (o CbrCheckpointOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *CbrCheckpoint) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The region where the vault and backup resources are located.
func (o CbrCheckpointOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *CbrCheckpoint) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The status of the checkpoint.
func (o CbrCheckpointOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *CbrCheckpoint) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// The ID of the vault where the checkpoint to create.
func (o CbrCheckpointOutput) VaultId() pulumi.StringOutput {
	return o.ApplyT(func(v *CbrCheckpoint) pulumi.StringOutput { return v.VaultId }).(pulumi.StringOutput)
}

type CbrCheckpointArrayOutput struct{ *pulumi.OutputState }

func (CbrCheckpointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CbrCheckpoint)(nil)).Elem()
}

func (o CbrCheckpointArrayOutput) ToCbrCheckpointArrayOutput() CbrCheckpointArrayOutput {
	return o
}

func (o CbrCheckpointArrayOutput) ToCbrCheckpointArrayOutputWithContext(ctx context.Context) CbrCheckpointArrayOutput {
	return o
}

func (o CbrCheckpointArrayOutput) Index(i pulumi.IntInput) CbrCheckpointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CbrCheckpoint {
		return vs[0].([]*CbrCheckpoint)[vs[1].(int)]
	}).(CbrCheckpointOutput)
}

type CbrCheckpointMapOutput struct{ *pulumi.OutputState }

func (CbrCheckpointMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CbrCheckpoint)(nil)).Elem()
}

func (o CbrCheckpointMapOutput) ToCbrCheckpointMapOutput() CbrCheckpointMapOutput {
	return o
}

func (o CbrCheckpointMapOutput) ToCbrCheckpointMapOutputWithContext(ctx context.Context) CbrCheckpointMapOutput {
	return o
}

func (o CbrCheckpointMapOutput) MapIndex(k pulumi.StringInput) CbrCheckpointOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CbrCheckpoint {
		return vs[0].(map[string]*CbrCheckpoint)[vs[1].(string)]
	}).(CbrCheckpointOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CbrCheckpointInput)(nil)).Elem(), &CbrCheckpoint{})
	pulumi.RegisterInputType(reflect.TypeOf((*CbrCheckpointArrayInput)(nil)).Elem(), CbrCheckpointArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CbrCheckpointMapInput)(nil)).Elem(), CbrCheckpointMap{})
	pulumi.RegisterOutputType(CbrCheckpointOutput{})
	pulumi.RegisterOutputType(CbrCheckpointArrayOutput{})
	pulumi.RegisterOutputType(CbrCheckpointMapOutput{})
}
