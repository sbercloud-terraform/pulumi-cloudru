// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dis

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/sbercloud-terraform/pulumi-cloudru/sdk/go/cloudru/internal"
)

type Stream struct {
	pulumi.CustomResourceState

	AutoScaleMaxPartitionCount pulumi.IntOutput           `pulumi:"autoScaleMaxPartitionCount"`
	AutoScaleMinPartitionCount pulumi.IntOutput           `pulumi:"autoScaleMinPartitionCount"`
	CompressionFormat          pulumi.StringOutput        `pulumi:"compressionFormat"`
	Created                    pulumi.IntOutput           `pulumi:"created"`
	CsvDelimiter               pulumi.StringOutput        `pulumi:"csvDelimiter"`
	DataSchema                 pulumi.StringOutput        `pulumi:"dataSchema"`
	DataType                   pulumi.StringOutput        `pulumi:"dataType"`
	EnterpriseProjectId        pulumi.StringOutput        `pulumi:"enterpriseProjectId"`
	PartitionCount             pulumi.IntOutput           `pulumi:"partitionCount"`
	Partitions                 StreamPartitionArrayOutput `pulumi:"partitions"`
	ReadablePartitionCount     pulumi.IntOutput           `pulumi:"readablePartitionCount"`
	Region                     pulumi.StringOutput        `pulumi:"region"`
	RetentionPeriod            pulumi.IntPtrOutput        `pulumi:"retentionPeriod"`
	Status                     pulumi.StringOutput        `pulumi:"status"`
	StreamId                   pulumi.StringOutput        `pulumi:"streamId"`
	StreamName                 pulumi.StringOutput        `pulumi:"streamName"`
	StreamType                 pulumi.StringOutput        `pulumi:"streamType"`
	Tags                       pulumi.StringMapOutput     `pulumi:"tags"`
	WritablePartitionCount     pulumi.IntOutput           `pulumi:"writablePartitionCount"`
}

// NewStream registers a new resource with the given unique name, arguments, and options.
func NewStream(ctx *pulumi.Context,
	name string, args *StreamArgs, opts ...pulumi.ResourceOption) (*Stream, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PartitionCount == nil {
		return nil, errors.New("invalid value for required argument 'PartitionCount'")
	}
	if args.StreamName == nil {
		return nil, errors.New("invalid value for required argument 'StreamName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Stream
	err := ctx.RegisterResource("cloudru:Dis/stream:Stream", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetStream gets an existing Stream resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetStream(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *StreamState, opts ...pulumi.ResourceOption) (*Stream, error) {
	var resource Stream
	err := ctx.ReadResource("cloudru:Dis/stream:Stream", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Stream resources.
type streamState struct {
	AutoScaleMaxPartitionCount *int              `pulumi:"autoScaleMaxPartitionCount"`
	AutoScaleMinPartitionCount *int              `pulumi:"autoScaleMinPartitionCount"`
	CompressionFormat          *string           `pulumi:"compressionFormat"`
	Created                    *int              `pulumi:"created"`
	CsvDelimiter               *string           `pulumi:"csvDelimiter"`
	DataSchema                 *string           `pulumi:"dataSchema"`
	DataType                   *string           `pulumi:"dataType"`
	EnterpriseProjectId        *string           `pulumi:"enterpriseProjectId"`
	PartitionCount             *int              `pulumi:"partitionCount"`
	Partitions                 []StreamPartition `pulumi:"partitions"`
	ReadablePartitionCount     *int              `pulumi:"readablePartitionCount"`
	Region                     *string           `pulumi:"region"`
	RetentionPeriod            *int              `pulumi:"retentionPeriod"`
	Status                     *string           `pulumi:"status"`
	StreamId                   *string           `pulumi:"streamId"`
	StreamName                 *string           `pulumi:"streamName"`
	StreamType                 *string           `pulumi:"streamType"`
	Tags                       map[string]string `pulumi:"tags"`
	WritablePartitionCount     *int              `pulumi:"writablePartitionCount"`
}

type StreamState struct {
	AutoScaleMaxPartitionCount pulumi.IntPtrInput
	AutoScaleMinPartitionCount pulumi.IntPtrInput
	CompressionFormat          pulumi.StringPtrInput
	Created                    pulumi.IntPtrInput
	CsvDelimiter               pulumi.StringPtrInput
	DataSchema                 pulumi.StringPtrInput
	DataType                   pulumi.StringPtrInput
	EnterpriseProjectId        pulumi.StringPtrInput
	PartitionCount             pulumi.IntPtrInput
	Partitions                 StreamPartitionArrayInput
	ReadablePartitionCount     pulumi.IntPtrInput
	Region                     pulumi.StringPtrInput
	RetentionPeriod            pulumi.IntPtrInput
	Status                     pulumi.StringPtrInput
	StreamId                   pulumi.StringPtrInput
	StreamName                 pulumi.StringPtrInput
	StreamType                 pulumi.StringPtrInput
	Tags                       pulumi.StringMapInput
	WritablePartitionCount     pulumi.IntPtrInput
}

func (StreamState) ElementType() reflect.Type {
	return reflect.TypeOf((*streamState)(nil)).Elem()
}

type streamArgs struct {
	AutoScaleMaxPartitionCount *int              `pulumi:"autoScaleMaxPartitionCount"`
	AutoScaleMinPartitionCount *int              `pulumi:"autoScaleMinPartitionCount"`
	CompressionFormat          *string           `pulumi:"compressionFormat"`
	CsvDelimiter               *string           `pulumi:"csvDelimiter"`
	DataSchema                 *string           `pulumi:"dataSchema"`
	DataType                   *string           `pulumi:"dataType"`
	EnterpriseProjectId        *string           `pulumi:"enterpriseProjectId"`
	PartitionCount             int               `pulumi:"partitionCount"`
	Region                     *string           `pulumi:"region"`
	RetentionPeriod            *int              `pulumi:"retentionPeriod"`
	StreamName                 string            `pulumi:"streamName"`
	StreamType                 *string           `pulumi:"streamType"`
	Tags                       map[string]string `pulumi:"tags"`
}

// The set of arguments for constructing a Stream resource.
type StreamArgs struct {
	AutoScaleMaxPartitionCount pulumi.IntPtrInput
	AutoScaleMinPartitionCount pulumi.IntPtrInput
	CompressionFormat          pulumi.StringPtrInput
	CsvDelimiter               pulumi.StringPtrInput
	DataSchema                 pulumi.StringPtrInput
	DataType                   pulumi.StringPtrInput
	EnterpriseProjectId        pulumi.StringPtrInput
	PartitionCount             pulumi.IntInput
	Region                     pulumi.StringPtrInput
	RetentionPeriod            pulumi.IntPtrInput
	StreamName                 pulumi.StringInput
	StreamType                 pulumi.StringPtrInput
	Tags                       pulumi.StringMapInput
}

func (StreamArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*streamArgs)(nil)).Elem()
}

type StreamInput interface {
	pulumi.Input

	ToStreamOutput() StreamOutput
	ToStreamOutputWithContext(ctx context.Context) StreamOutput
}

func (*Stream) ElementType() reflect.Type {
	return reflect.TypeOf((**Stream)(nil)).Elem()
}

func (i *Stream) ToStreamOutput() StreamOutput {
	return i.ToStreamOutputWithContext(context.Background())
}

func (i *Stream) ToStreamOutputWithContext(ctx context.Context) StreamOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamOutput)
}

// StreamArrayInput is an input type that accepts StreamArray and StreamArrayOutput values.
// You can construct a concrete instance of `StreamArrayInput` via:
//
//	StreamArray{ StreamArgs{...} }
type StreamArrayInput interface {
	pulumi.Input

	ToStreamArrayOutput() StreamArrayOutput
	ToStreamArrayOutputWithContext(context.Context) StreamArrayOutput
}

type StreamArray []StreamInput

func (StreamArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Stream)(nil)).Elem()
}

func (i StreamArray) ToStreamArrayOutput() StreamArrayOutput {
	return i.ToStreamArrayOutputWithContext(context.Background())
}

func (i StreamArray) ToStreamArrayOutputWithContext(ctx context.Context) StreamArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamArrayOutput)
}

// StreamMapInput is an input type that accepts StreamMap and StreamMapOutput values.
// You can construct a concrete instance of `StreamMapInput` via:
//
//	StreamMap{ "key": StreamArgs{...} }
type StreamMapInput interface {
	pulumi.Input

	ToStreamMapOutput() StreamMapOutput
	ToStreamMapOutputWithContext(context.Context) StreamMapOutput
}

type StreamMap map[string]StreamInput

func (StreamMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Stream)(nil)).Elem()
}

func (i StreamMap) ToStreamMapOutput() StreamMapOutput {
	return i.ToStreamMapOutputWithContext(context.Background())
}

func (i StreamMap) ToStreamMapOutputWithContext(ctx context.Context) StreamMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StreamMapOutput)
}

type StreamOutput struct{ *pulumi.OutputState }

func (StreamOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Stream)(nil)).Elem()
}

func (o StreamOutput) ToStreamOutput() StreamOutput {
	return o
}

func (o StreamOutput) ToStreamOutputWithContext(ctx context.Context) StreamOutput {
	return o
}

func (o StreamOutput) AutoScaleMaxPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Stream) pulumi.IntOutput { return v.AutoScaleMaxPartitionCount }).(pulumi.IntOutput)
}

func (o StreamOutput) AutoScaleMinPartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Stream) pulumi.IntOutput { return v.AutoScaleMinPartitionCount }).(pulumi.IntOutput)
}

func (o StreamOutput) CompressionFormat() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.CompressionFormat }).(pulumi.StringOutput)
}

func (o StreamOutput) Created() pulumi.IntOutput {
	return o.ApplyT(func(v *Stream) pulumi.IntOutput { return v.Created }).(pulumi.IntOutput)
}

func (o StreamOutput) CsvDelimiter() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.CsvDelimiter }).(pulumi.StringOutput)
}

func (o StreamOutput) DataSchema() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.DataSchema }).(pulumi.StringOutput)
}

func (o StreamOutput) DataType() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.DataType }).(pulumi.StringOutput)
}

func (o StreamOutput) EnterpriseProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.EnterpriseProjectId }).(pulumi.StringOutput)
}

func (o StreamOutput) PartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Stream) pulumi.IntOutput { return v.PartitionCount }).(pulumi.IntOutput)
}

func (o StreamOutput) Partitions() StreamPartitionArrayOutput {
	return o.ApplyT(func(v *Stream) StreamPartitionArrayOutput { return v.Partitions }).(StreamPartitionArrayOutput)
}

func (o StreamOutput) ReadablePartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Stream) pulumi.IntOutput { return v.ReadablePartitionCount }).(pulumi.IntOutput)
}

func (o StreamOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

func (o StreamOutput) RetentionPeriod() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Stream) pulumi.IntPtrOutput { return v.RetentionPeriod }).(pulumi.IntPtrOutput)
}

func (o StreamOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

func (o StreamOutput) StreamId() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.StreamId }).(pulumi.StringOutput)
}

func (o StreamOutput) StreamName() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.StreamName }).(pulumi.StringOutput)
}

func (o StreamOutput) StreamType() pulumi.StringOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringOutput { return v.StreamType }).(pulumi.StringOutput)
}

func (o StreamOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Stream) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func (o StreamOutput) WritablePartitionCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Stream) pulumi.IntOutput { return v.WritablePartitionCount }).(pulumi.IntOutput)
}

type StreamArrayOutput struct{ *pulumi.OutputState }

func (StreamArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Stream)(nil)).Elem()
}

func (o StreamArrayOutput) ToStreamArrayOutput() StreamArrayOutput {
	return o
}

func (o StreamArrayOutput) ToStreamArrayOutputWithContext(ctx context.Context) StreamArrayOutput {
	return o
}

func (o StreamArrayOutput) Index(i pulumi.IntInput) StreamOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Stream {
		return vs[0].([]*Stream)[vs[1].(int)]
	}).(StreamOutput)
}

type StreamMapOutput struct{ *pulumi.OutputState }

func (StreamMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Stream)(nil)).Elem()
}

func (o StreamMapOutput) ToStreamMapOutput() StreamMapOutput {
	return o
}

func (o StreamMapOutput) ToStreamMapOutputWithContext(ctx context.Context) StreamMapOutput {
	return o
}

func (o StreamMapOutput) MapIndex(k pulumi.StringInput) StreamOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Stream {
		return vs[0].(map[string]*Stream)[vs[1].(string)]
	}).(StreamOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*StreamInput)(nil)).Elem(), &Stream{})
	pulumi.RegisterInputType(reflect.TypeOf((*StreamArrayInput)(nil)).Elem(), StreamArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StreamMapInput)(nil)).Elem(), StreamMap{})
	pulumi.RegisterOutputType(StreamOutput{})
	pulumi.RegisterOutputType(StreamArrayOutput{})
	pulumi.RegisterOutputType(StreamMapOutput{})
}
