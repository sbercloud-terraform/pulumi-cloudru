# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BandwidthPolicyIntervalAlarmActionArgs',
    'BandwidthPolicyIntervalAlarmActionArgsDict',
    'BandwidthPolicyMetaDataArgs',
    'BandwidthPolicyMetaDataArgsDict',
    'BandwidthPolicyScalingPolicyActionArgs',
    'BandwidthPolicyScalingPolicyActionArgsDict',
    'BandwidthPolicyScheduledPolicyArgs',
    'BandwidthPolicyScheduledPolicyArgsDict',
    'ConfigurationInstanceConfigArgs',
    'ConfigurationInstanceConfigArgsDict',
    'ConfigurationInstanceConfigDiskArgs',
    'ConfigurationInstanceConfigDiskArgsDict',
    'ConfigurationInstanceConfigPersonalityArgs',
    'ConfigurationInstanceConfigPersonalityArgsDict',
    'ConfigurationInstanceConfigPublicIpArgs',
    'ConfigurationInstanceConfigPublicIpArgsDict',
    'ConfigurationInstanceConfigPublicIpEipArgs',
    'ConfigurationInstanceConfigPublicIpEipArgsDict',
    'ConfigurationInstanceConfigPublicIpEipBandwidthArgs',
    'ConfigurationInstanceConfigPublicIpEipBandwidthArgsDict',
    'GroupLbaasListenerArgs',
    'GroupLbaasListenerArgsDict',
    'GroupNetworkArgs',
    'GroupNetworkArgsDict',
    'GroupSecurityGroupArgs',
    'GroupSecurityGroupArgsDict',
    'PolicyScalingPolicyActionArgs',
    'PolicyScalingPolicyActionArgsDict',
    'PolicyScheduledPolicyArgs',
    'PolicyScheduledPolicyArgsDict',
]

MYPY = False

if not MYPY:
    class BandwidthPolicyIntervalAlarmActionArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the operation restrictions.
        - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
        - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
        - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.

        <a name="ASBandWidthPolicy_ScheduledPolicy"></a>
        The `scheduled_policy` block supports:
        """
        lower_bound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the lower limit of the value range.
        """
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operation to be performed. The default operation is ADD.
        The options are as follows:
        - **ADD**: indicates adding the bandwidth size.
        - **REDUCE**: indicates reducing the bandwidth size.
        - **SET**: indicates setting the bandwidth size to a specified value.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the bandwidth (Mbit/s).
        The value is an integer from 1 to 2000. The default value is 1.
        """
        upper_bound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the upper limit of the value range.
        """
elif False:
    BandwidthPolicyIntervalAlarmActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPolicyIntervalAlarmActionArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[_builtins.int]] = None,
                 lower_bound: Optional[pulumi.Input[_builtins.str]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 upper_bound: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] limits: Specifies the operation restrictions.
               - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
               - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
               - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.
               
               <a name="ASBandWidthPolicy_ScheduledPolicy"></a>
               The `scheduled_policy` block supports:
        :param pulumi.Input[_builtins.str] lower_bound: Specifies the lower limit of the value range.
        :param pulumi.Input[_builtins.str] operation: Specifies the operation to be performed. The default operation is ADD.
               The options are as follows:
               - **ADD**: indicates adding the bandwidth size.
               - **REDUCE**: indicates reducing the bandwidth size.
               - **SET**: indicates setting the bandwidth size to a specified value.
        :param pulumi.Input[_builtins.int] size: Specifies the bandwidth (Mbit/s).
               The value is an integer from 1 to 2000. The default value is 1.
        :param pulumi.Input[_builtins.str] upper_bound: Specifies the upper limit of the value range.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if lower_bound is not None:
            pulumi.set(__self__, "lower_bound", lower_bound)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if upper_bound is not None:
            pulumi.set(__self__, "upper_bound", upper_bound)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the operation restrictions.
        - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
        - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
        - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.

        <a name="ASBandWidthPolicy_ScheduledPolicy"></a>
        The `scheduled_policy` block supports:
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter(name="lowerBound")
    def lower_bound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the lower limit of the value range.
        """
        return pulumi.get(self, "lower_bound")

    @lower_bound.setter
    def lower_bound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lower_bound", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operation to be performed. The default operation is ADD.
        The options are as follows:
        - **ADD**: indicates adding the bandwidth size.
        - **REDUCE**: indicates reducing the bandwidth size.
        - **SET**: indicates setting the bandwidth size to a specified value.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the bandwidth (Mbit/s).
        The value is an integer from 1 to 2000. The default value is 1.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the upper limit of the value range.
        """
        return pulumi.get(self, "upper_bound")

    @upper_bound.setter
    def upper_bound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upper_bound", value)


if not MYPY:
    class BandwidthPolicyMetaDataArgsDict(TypedDict):
        metadata_bandwidth_share_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth sharing type in the bandwidth policy.
        """
        metadata_eip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP IP address for the bandwidth in the bandwidth policy.
        """
        metadata_eip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP ID for the bandwidth in the bandwidth policy.
        """
elif False:
    BandwidthPolicyMetaDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPolicyMetaDataArgs:
    def __init__(__self__, *,
                 metadata_bandwidth_share_type: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata_eip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata_eip_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata_bandwidth_share_type: The bandwidth sharing type in the bandwidth policy.
        :param pulumi.Input[_builtins.str] metadata_eip_address: The EIP IP address for the bandwidth in the bandwidth policy.
        :param pulumi.Input[_builtins.str] metadata_eip_id: The EIP ID for the bandwidth in the bandwidth policy.
        """
        if metadata_bandwidth_share_type is not None:
            pulumi.set(__self__, "metadata_bandwidth_share_type", metadata_bandwidth_share_type)
        if metadata_eip_address is not None:
            pulumi.set(__self__, "metadata_eip_address", metadata_eip_address)
        if metadata_eip_id is not None:
            pulumi.set(__self__, "metadata_eip_id", metadata_eip_id)

    @_builtins.property
    @pulumi.getter(name="metadataBandwidthShareType")
    def metadata_bandwidth_share_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth sharing type in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_bandwidth_share_type")

    @metadata_bandwidth_share_type.setter
    def metadata_bandwidth_share_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_bandwidth_share_type", value)

    @_builtins.property
    @pulumi.getter(name="metadataEipAddress")
    def metadata_eip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP IP address for the bandwidth in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_eip_address")

    @metadata_eip_address.setter
    def metadata_eip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_eip_address", value)

    @_builtins.property
    @pulumi.getter(name="metadataEipId")
    def metadata_eip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP ID for the bandwidth in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_eip_id")

    @metadata_eip_id.setter
    def metadata_eip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_eip_id", value)


if not MYPY:
    class BandwidthPolicyScalingPolicyActionArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the operation restrictions.
        - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
        - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
        - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.

        <a name="ASBandWidthPolicy_ScheduledPolicy"></a>
        The `scheduled_policy` block supports:
        """
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operation to be performed. The default operation is ADD.
        The options are as follows:
        - **ADD**: indicates adding the bandwidth size.
        - **REDUCE**: indicates reducing the bandwidth size.
        - **SET**: indicates setting the bandwidth size to a specified value.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the bandwidth (Mbit/s).
        The value is an integer from 1 to 2000. The default value is 1.
        """
elif False:
    BandwidthPolicyScalingPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPolicyScalingPolicyActionArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[_builtins.int]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limits: Specifies the operation restrictions.
               - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
               - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
               - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.
               
               <a name="ASBandWidthPolicy_ScheduledPolicy"></a>
               The `scheduled_policy` block supports:
        :param pulumi.Input[_builtins.str] operation: Specifies the operation to be performed. The default operation is ADD.
               The options are as follows:
               - **ADD**: indicates adding the bandwidth size.
               - **REDUCE**: indicates reducing the bandwidth size.
               - **SET**: indicates setting the bandwidth size to a specified value.
        :param pulumi.Input[_builtins.int] size: Specifies the bandwidth (Mbit/s).
               The value is an integer from 1 to 2000. The default value is 1.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the operation restrictions.
        - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
        - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
        - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.

        <a name="ASBandWidthPolicy_ScheduledPolicy"></a>
        The `scheduled_policy` block supports:
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operation to be performed. The default operation is ADD.
        The options are as follows:
        - **ADD**: indicates adding the bandwidth size.
        - **REDUCE**: indicates reducing the bandwidth size.
        - **SET**: indicates setting the bandwidth size to a specified value.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the bandwidth (Mbit/s).
        The value is an integer from 1 to 2000. The default value is 1.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class BandwidthPolicyScheduledPolicyArgsDict(TypedDict):
        launch_time: pulumi.Input[_builtins.str]
        """
        Specifies the time when the scaling action is triggered.
        The time format complies with UTC.
        - If scaling_policy_type is set to SCHEDULED, the time format is YYYY-MM-DDThh:mmZ.
        - If scaling_policy_type is set to RECURRENCE, the time format is hh:mm.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the end time of the scaling action triggered periodically.
        The time format complies with UTC. This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
        When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
        The time format is YYYY-MM-DDThh:mmZ.
        """
        recurrence_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the periodic triggering type.
        This parameter is mandatory when scaling_policy_type is set to RECURRENCE. The options are as follows:
        - **Daily**: indicates that the scaling action is triggered once a day.
        - **Weekly**: indicates that the scaling action is triggered once a week.
        - **Monthly**: indicates that the scaling action is triggered once a month.
        """
        recurrence_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the day when a periodic scaling action is triggered.
        This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
        - If recurrence_type is set to Daily, the value is null, indicating that the scaling action is triggered once a day.
        - If recurrence_type is set to Weekly, the value ranges from 1 (Sunday) to 7 (Saturday).
        The digits refer to dates in each week and separated by a comma, such as 1,3,5.
        - If recurrence_type is set to Monthly, the value ranges from 1 to 31.
        The digits refer to the dates in each month and separated by a comma, such as 1,10,13,28.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the start time of the scaling action triggered periodically.
        The time format complies with UTC. The default value is the local time.
        The time format is YYYY-MM-DDThh:mmZ.
        """
elif False:
    BandwidthPolicyScheduledPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPolicyScheduledPolicyArgs:
    def __init__(__self__, *,
                 launch_time: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_type: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_value: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] launch_time: Specifies the time when the scaling action is triggered.
               The time format complies with UTC.
               - If scaling_policy_type is set to SCHEDULED, the time format is YYYY-MM-DDThh:mmZ.
               - If scaling_policy_type is set to RECURRENCE, the time format is hh:mm.
        :param pulumi.Input[_builtins.str] end_time: Specifies the end time of the scaling action triggered periodically.
               The time format complies with UTC. This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
               When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
               The time format is YYYY-MM-DDThh:mmZ.
        :param pulumi.Input[_builtins.str] recurrence_type: Specifies the periodic triggering type.
               This parameter is mandatory when scaling_policy_type is set to RECURRENCE. The options are as follows:
               - **Daily**: indicates that the scaling action is triggered once a day.
               - **Weekly**: indicates that the scaling action is triggered once a week.
               - **Monthly**: indicates that the scaling action is triggered once a month.
        :param pulumi.Input[_builtins.str] recurrence_value: Specifies the day when a periodic scaling action is triggered.
               This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
               - If recurrence_type is set to Daily, the value is null, indicating that the scaling action is triggered once a day.
               - If recurrence_type is set to Weekly, the value ranges from 1 (Sunday) to 7 (Saturday).
               The digits refer to dates in each week and separated by a comma, such as 1,3,5.
               - If recurrence_type is set to Monthly, the value ranges from 1 to 31.
               The digits refer to the dates in each month and separated by a comma, such as 1,10,13,28.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time of the scaling action triggered periodically.
               The time format complies with UTC. The default value is the local time.
               The time format is YYYY-MM-DDThh:mmZ.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the time when the scaling action is triggered.
        The time format complies with UTC.
        - If scaling_policy_type is set to SCHEDULED, the time format is YYYY-MM-DDThh:mmZ.
        - If scaling_policy_type is set to RECURRENCE, the time format is hh:mm.
        """
        return pulumi.get(self, "launch_time")

    @launch_time.setter
    def launch_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "launch_time", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the end time of the scaling action triggered periodically.
        The time format complies with UTC. This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
        When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
        The time format is YYYY-MM-DDThh:mmZ.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the periodic triggering type.
        This parameter is mandatory when scaling_policy_type is set to RECURRENCE. The options are as follows:
        - **Daily**: indicates that the scaling action is triggered once a day.
        - **Weekly**: indicates that the scaling action is triggered once a week.
        - **Monthly**: indicates that the scaling action is triggered once a month.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_type", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the day when a periodic scaling action is triggered.
        This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
        - If recurrence_type is set to Daily, the value is null, indicating that the scaling action is triggered once a day.
        - If recurrence_type is set to Weekly, the value ranges from 1 (Sunday) to 7 (Saturday).
        The digits refer to dates in each week and separated by a comma, such as 1,3,5.
        - If recurrence_type is set to Monthly, the value ranges from 1 to 31.
        The digits refer to the dates in each month and separated by a comma, such as 1,10,13,28.
        """
        return pulumi.get(self, "recurrence_value")

    @recurrence_value.setter
    def recurrence_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_value", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the start time of the scaling action triggered periodically.
        The time format complies with UTC. The default value is the local time.
        The time format is YYYY-MM-DDThh:mmZ.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class ConfigurationInstanceConfigArgsDict(TypedDict):
        admin_pass: NotRequired[pulumi.Input[_builtins.str]]
        charging_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies a billing mode for an ECS.
        The value can be `postPaid` and `spot`. The default value is `postPaid`.
        Changing this will create a new resource.
        """
        dedicated_host_id: NotRequired[pulumi.Input[_builtins.str]]
        disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgsDict']]]]
        """
        Specifies the disk group information. System disks are mandatory and
        data disks are optional. The object structure is documented below.
        Changing this will create a new resource.
        """
        ecs_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ECS group ID. Changing this will create a new resource.
        """
        flavor: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ECS flavor name. A maximum of 10 flavors can be selected.
        Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
        """
        flavor_priority_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the priority policy used when there are multiple flavors
        and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.

        + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
        in the flavor list.
        + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.

        Changing this will create a new resource.
        """
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ECS image ID. Changing this will create a new resource.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ECS instance ID when using its specification
        as the template to create AS configurations. In this case, `flavor`, `image`, and `disk` arguments do not take effect.
        If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
        Changing this will create a new resource.
        """
        key_fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the SSH key pair used to log in to the instance.
        Changing this will create a new resource.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the key/value pairs to make available from within the instance.
        Changing this will create a new resource.
        """
        personalities: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgsDict']]]]
        """
        Specifies the customize personality of an instance by defining one or
        more files and their contents. The object structure is documented below.
        Changing this will create a new resource.

        <a name="instance_config_disk_object"></a>
        The `disk` block supports:
        """
        public_ip: NotRequired[pulumi.Input['ConfigurationInstanceConfigPublicIpArgsDict']]
        """
        Specifies the EIP of the ECS instance.
        The object structure is documented below.
        Changing this will create a new resource.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies an array of one or more security group IDs.
        Changing this will create a new resource.
        """
        tenancy: NotRequired[pulumi.Input[_builtins.str]]
        user_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the user data to provide when launching the instance.
        The file content must be encoded with Base64. Changing this will create a new resource.
        """
elif False:
    ConfigurationInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigArgs:
    def __init__(__self__, *,
                 admin_pass: Optional[pulumi.Input[_builtins.str]] = None,
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 dedicated_host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disks: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgs']]]] = None,
                 ecs_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor_priority_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 personalities: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgs']]]] = None,
                 public_ip: Optional[pulumi.Input['ConfigurationInstanceConfigPublicIpArgs']] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tenancy: Optional[pulumi.Input[_builtins.str]] = None,
                 user_data: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] charging_mode: Specifies a billing mode for an ECS.
               The value can be `postPaid` and `spot`. The default value is `postPaid`.
               Changing this will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgs']]] disks: Specifies the disk group information. System disks are mandatory and
               data disks are optional. The object structure is documented below.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] ecs_group_id: Specifies the ECS group ID. Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] flavor: Specifies the ECS flavor name. A maximum of 10 flavors can be selected.
               Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] flavor_priority_policy: Specifies the priority policy used when there are multiple flavors
               and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.
               
               + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
               in the flavor list.
               + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.
               
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] image: Specifies the ECS image ID. Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] instance_id: Specifies the ECS instance ID when using its specification
               as the template to create AS configurations. In this case, `flavor`, `image`, and `disk` arguments do not take effect.
               If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] key_name: Specifies the name of the SSH key pair used to log in to the instance.
               Changing this will create a new resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: Specifies the key/value pairs to make available from within the instance.
               Changing this will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgs']]] personalities: Specifies the customize personality of an instance by defining one or
               more files and their contents. The object structure is documented below.
               Changing this will create a new resource.
               
               <a name="instance_config_disk_object"></a>
               The `disk` block supports:
        :param pulumi.Input['ConfigurationInstanceConfigPublicIpArgs'] public_ip: Specifies the EIP of the ECS instance.
               The object structure is documented below.
               Changing this will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: Specifies an array of one or more security group IDs.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] user_data: Specifies the user data to provide when launching the instance.
               The file content must be encoded with Base64. Changing this will create a new resource.
        """
        if admin_pass is not None:
            pulumi.set(__self__, "admin_pass", admin_pass)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if ecs_group_id is not None:
            pulumi.set(__self__, "ecs_group_id", ecs_group_id)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_priority_policy is not None:
            pulumi.set(__self__, "flavor_priority_policy", flavor_priority_policy)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if key_fingerprint is not None:
            pulumi.set(__self__, "key_fingerprint", key_fingerprint)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if personalities is not None:
            pulumi.set(__self__, "personalities", personalities)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="adminPass")
    def admin_pass(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "admin_pass")

    @admin_pass.setter
    def admin_pass(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "admin_pass", value)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies a billing mode for an ECS.
        The value can be `postPaid` and `spot`. The default value is `postPaid`.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dedicated_host_id")

    @dedicated_host_id.setter
    def dedicated_host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_host_id", value)

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgs']]]]:
        """
        Specifies the disk group information. System disks are mandatory and
        data disks are optional. The object structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "disks")

    @disks.setter
    def disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgs']]]]):
        pulumi.set(self, "disks", value)

    @_builtins.property
    @pulumi.getter(name="ecsGroupId")
    def ecs_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ECS group ID. Changing this will create a new resource.
        """
        return pulumi.get(self, "ecs_group_id")

    @ecs_group_id.setter
    def ecs_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecs_group_id", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ECS flavor name. A maximum of 10 flavors can be selected.
        Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="flavorPriorityPolicy")
    def flavor_priority_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the priority policy used when there are multiple flavors
        and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.

        + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
        in the flavor list.
        + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.

        Changing this will create a new resource.
        """
        return pulumi.get(self, "flavor_priority_policy")

    @flavor_priority_policy.setter
    def flavor_priority_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor_priority_policy", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ECS image ID. Changing this will create a new resource.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ECS instance ID when using its specification
        as the template to create AS configurations. In this case, `flavor`, `image`, and `disk` arguments do not take effect.
        If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="keyFingerprint")
    def key_fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_fingerprint")

    @key_fingerprint.setter
    def key_fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the SSH key pair used to log in to the instance.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the key/value pairs to make available from within the instance.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def personalities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgs']]]]:
        """
        Specifies the customize personality of an instance by defining one or
        more files and their contents. The object structure is documented below.
        Changing this will create a new resource.

        <a name="instance_config_disk_object"></a>
        The `disk` block supports:
        """
        return pulumi.get(self, "personalities")

    @personalities.setter
    def personalities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgs']]]]):
        pulumi.set(self, "personalities", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input['ConfigurationInstanceConfigPublicIpArgs']]:
        """
        Specifies the EIP of the ECS instance.
        The object structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input['ConfigurationInstanceConfigPublicIpArgs']]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies an array of one or more security group IDs.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenancy", value)

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the user data to provide when launching the instance.
        The file content must be encoded with Base64. Changing this will create a new resource.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_data", value)


if not MYPY:
    class ConfigurationInstanceConfigDiskArgsDict(TypedDict):
        disk_type: pulumi.Input[_builtins.str]
        """
        Specifies whether the disk is a system disk or a data disk.
        Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
        Changing this will create a new resource.
        """
        size: pulumi.Input[_builtins.int]
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the disk type. Changing this will create a new resource.
        Available options are:
        + `SAS`: high I/O disk type.
        + `SSD`: ultra-high I/O disk type.
        + `GPSSD`: general purpose SSD disk type.
        """
        data_disk_image_id: NotRequired[pulumi.Input[_builtins.str]]
        dedicated_storage_id: NotRequired[pulumi.Input[_builtins.str]]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        kms_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the encryption KMS ID of the **DATA** disk.
        Changing this will create a new resource.

        <a name="instance_config_public_ip_object"></a>
        The `public_ip` block supports:
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        throughput: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ConfigurationInstanceConfigDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigDiskArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str],
                 data_disk_image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 dedicated_storage_id: Optional[pulumi.Input[_builtins.str]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] disk_type: Specifies whether the disk is a system disk or a data disk.
               Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the disk type. Changing this will create a new resource.
               Available options are:
               + `SAS`: high I/O disk type.
               + `SSD`: ultra-high I/O disk type.
               + `GPSSD`: general purpose SSD disk type.
        :param pulumi.Input[_builtins.str] kms_id: Specifies the encryption KMS ID of the **DATA** disk.
               Changing this will create a new resource.
               
               <a name="instance_config_public_ip_object"></a>
               The `public_ip` block supports:
        """
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if data_disk_image_id is not None:
            pulumi.set(__self__, "data_disk_image_id", data_disk_image_id)
        if dedicated_storage_id is not None:
            pulumi.set(__self__, "dedicated_storage_id", dedicated_storage_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_id is not None:
            pulumi.set(__self__, "kms_id", kms_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies whether the disk is a system disk or a data disk.
        Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type. Changing this will create a new resource.
        Available options are:
        + `SAS`: high I/O disk type.
        + `SSD`: ultra-high I/O disk type.
        + `GPSSD`: general purpose SSD disk type.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)

    @_builtins.property
    @pulumi.getter(name="dataDiskImageId")
    def data_disk_image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "data_disk_image_id")

    @data_disk_image_id.setter
    def data_disk_image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_disk_image_id", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedStorageId")
    def dedicated_storage_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dedicated_storage_id")

    @dedicated_storage_id.setter
    def dedicated_storage_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_storage_id", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsId")
    def kms_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the encryption KMS ID of the **DATA** disk.
        Changing this will create a new resource.

        <a name="instance_config_public_ip_object"></a>
        The `public_ip` block supports:
        """
        return pulumi.get(self, "kms_id")

    @kms_id.setter
    def kms_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class ConfigurationInstanceConfigPersonalityArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        Specifies the content of the injected file, which must be encoded with base64.
        Changing this creates a new resource.
        """
        path: pulumi.Input[_builtins.str]
        """
        Specifies the path of the injected file. Changing this creates a new resource.
        """
elif False:
    ConfigurationInstanceConfigPersonalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigPersonalityArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] content: Specifies the content of the injected file, which must be encoded with base64.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] path: Specifies the path of the injected file. Changing this creates a new resource.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the content of the injected file, which must be encoded with base64.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the path of the injected file. Changing this creates a new resource.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ConfigurationInstanceConfigPublicIpArgsDict(TypedDict):
        eip: pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgsDict']
        """
        Specifies the EIP configuration that will be automatically assigned to the instance.
        The object structure is documented below. Changing this will create a new resource.
        """
elif False:
    ConfigurationInstanceConfigPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigPublicIpArgs:
    def __init__(__self__, *,
                 eip: pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgs']):
        """
        :param pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgs'] eip: Specifies the EIP configuration that will be automatically assigned to the instance.
               The object structure is documented below. Changing this will create a new resource.
        """
        pulumi.set(__self__, "eip", eip)

    @_builtins.property
    @pulumi.getter
    def eip(self) -> pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgs']:
        """
        Specifies the EIP configuration that will be automatically assigned to the instance.
        The object structure is documented below. Changing this will create a new resource.
        """
        return pulumi.get(self, "eip")

    @eip.setter
    def eip(self, value: pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgs']):
        pulumi.set(self, "eip", value)


if not MYPY:
    class ConfigurationInstanceConfigPublicIpEipArgsDict(TypedDict):
        bandwidth: pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgsDict']
        """
        Specifies the bandwidth information. The object structure is documented below.
        Changing this will create a new resource.
        """
        ip_type: pulumi.Input[_builtins.str]
        """
        Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
        and **5_sbgp** (static BGP). Changing this will create a new resource.
        """
elif False:
    ConfigurationInstanceConfigPublicIpEipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigPublicIpEipArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgs'],
                 ip_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgs'] bandwidth: Specifies the bandwidth information. The object structure is documented below.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] ip_type: Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
               and **5_sbgp** (static BGP). Changing this will create a new resource.
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "ip_type", ip_type)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgs']:
        """
        Specifies the bandwidth information. The object structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgs']):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
        and **5_sbgp** (static BGP). Changing this will create a new resource.
        """
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_type", value)


if not MYPY:
    class ConfigurationInstanceConfigPublicIpEipBandwidthArgsDict(TypedDict):
        share_type: pulumi.Input[_builtins.str]
        """
        Specifies the bandwidth sharing type. The system only supports
        **PER** (indicates exclusive bandwidth). Changing this will create a new resource.
        """
        charging_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether the bandwidth is billed by traffic or by bandwidth
        size. The value can be **traffic** or **bandwidth**. Changing this creates a new resource.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID in UUID format.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
        is 1 to 2000 and that for bandwidth billed by traffic is 1 to 300.
        Changing this creates a new resource.

        <a name="instance_config_personality_object"></a>
        The `personality` block supports:
        """
elif False:
    ConfigurationInstanceConfigPublicIpEipBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigPublicIpEipBandwidthArgs:
    def __init__(__self__, *,
                 share_type: pulumi.Input[_builtins.str],
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] share_type: Specifies the bandwidth sharing type. The system only supports
               **PER** (indicates exclusive bandwidth). Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] charging_mode: Specifies whether the bandwidth is billed by traffic or by bandwidth
               size. The value can be **traffic** or **bandwidth**. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] id: The resource ID in UUID format.
        :param pulumi.Input[_builtins.int] size: Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
               is 1 to 2000 and that for bandwidth billed by traffic is 1 to 300.
               Changing this creates a new resource.
               
               <a name="instance_config_personality_object"></a>
               The `personality` block supports:
        """
        pulumi.set(__self__, "share_type", share_type)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the bandwidth sharing type. The system only supports
        **PER** (indicates exclusive bandwidth). Changing this will create a new resource.
        """
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "share_type", value)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether the bandwidth is billed by traffic or by bandwidth
        size. The value can be **traffic** or **bandwidth**. Changing this creates a new resource.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID in UUID format.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
        is 1 to 2000 and that for bandwidth billed by traffic is 1 to 300.
        Changing this creates a new resource.

        <a name="instance_config_personality_object"></a>
        The `personality` block supports:
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class GroupLbaasListenerArgsDict(TypedDict):
        pool_id: pulumi.Input[_builtins.str]
        """
        Specifies the backend ECS group ID.
        """
        protocol_port: pulumi.Input[_builtins.int]
        """
        Specifies the backend protocol, which is the port on which a backend ECS listens for
        traffic. The number of the port ranges from 1 to 65535.
        """
        listener_id: NotRequired[pulumi.Input[_builtins.str]]
        protocol_version: NotRequired[pulumi.Input[_builtins.str]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the weight, which determines the portion of requests a backend ECS processes
        compared to other backend ECSs added to the same listener. The value of this parameter ranges from 0 to 100. The
        default value is 1.
        """
elif False:
    GroupLbaasListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupLbaasListenerArgs:
    def __init__(__self__, *,
                 pool_id: pulumi.Input[_builtins.str],
                 protocol_port: pulumi.Input[_builtins.int],
                 listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_version: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] pool_id: Specifies the backend ECS group ID.
        :param pulumi.Input[_builtins.int] protocol_port: Specifies the backend protocol, which is the port on which a backend ECS listens for
               traffic. The number of the port ranges from 1 to 65535.
        :param pulumi.Input[_builtins.int] weight: Specifies the weight, which determines the portion of requests a backend ECS processes
               compared to other backend ECSs added to the same listener. The value of this parameter ranges from 0 to 100. The
               default value is 1.
        """
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the backend ECS group ID.
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pool_id", value)

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the backend protocol, which is the port on which a backend ECS listens for
        traffic. The number of the port ranges from 1 to 65535.
        """
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "protocol_port", value)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_id", value)

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol_version", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the weight, which determines the portion of requests a backend ECS processes
        compared to other backend ECSs added to the same listener. The value of this parameter ranges from 0 to 100. The
        default value is 1.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GroupNetworkArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
        ipv6_bandwidth_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the shared bandwidth of an IPv6 address.
        """
        ipv6_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to support IPv6 addresses. The default value is `false`.
        """
        source_dest_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether processesing only traffic that is destined specifically
        for it. Defaults to true.

        <a name="group_security_group_object"></a>
        The `security_groups` block supports:
        """
elif False:
    GroupNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 ipv6_bandwidth_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_dest_check: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the security group.
               
               <a name="group_lbaas_listener_object"></a>
               The `lbaas_listeners` block supports:
        :param pulumi.Input[_builtins.str] ipv6_bandwidth_id: Specifies the ID of the shared bandwidth of an IPv6 address.
        :param pulumi.Input[_builtins.bool] ipv6_enable: Specifies whether to support IPv6 addresses. The default value is `false`.
        :param pulumi.Input[_builtins.bool] source_dest_check: Specifies whether processesing only traffic that is destined specifically
               for it. Defaults to true.
               
               <a name="group_security_group_object"></a>
               The `security_groups` block supports:
        """
        pulumi.set(__self__, "id", id)
        if ipv6_bandwidth_id is not None:
            pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the shared bandwidth of an IPv6 address.
        """
        return pulumi.get(self, "ipv6_bandwidth_id")

    @ipv6_bandwidth_id.setter
    def ipv6_bandwidth_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_bandwidth_id", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to support IPv6 addresses. The default value is `false`.
        """
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @_builtins.property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether processesing only traffic that is destined specifically
        for it. Defaults to true.

        <a name="group_security_group_object"></a>
        The `security_groups` block supports:
        """
        return pulumi.get(self, "source_dest_check")

    @source_dest_check.setter
    def source_dest_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_dest_check", value)


if not MYPY:
    class GroupSecurityGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
elif False:
    GroupSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupSecurityGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the security group.
               
               <a name="group_lbaas_listener_object"></a>
               The `lbaas_listeners` block supports:
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PolicyScalingPolicyActionArgsDict(TypedDict):
        instance_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of instances to be operated. The default number is 1.
        """
        instance_percentage: NotRequired[pulumi.Input[_builtins.int]]
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
        and `SET`.
        """
elif False:
    PolicyScalingPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyScalingPolicyActionArgs:
    def __init__(__self__, *,
                 instance_number: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] instance_number: Specifies the number of instances to be operated. The default number is 1.
        :param pulumi.Input[_builtins.str] operation: Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
               and `SET`.
        """
        if instance_number is not None:
            pulumi.set(__self__, "instance_number", instance_number)
        if instance_percentage is not None:
            pulumi.set(__self__, "instance_percentage", instance_percentage)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of instances to be operated. The default number is 1.
        """
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter(name="instancePercentage")
    def instance_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "instance_percentage")

    @instance_percentage.setter
    def instance_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_percentage", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
        and `SET`.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)


if not MYPY:
    class PolicyScheduledPolicyArgsDict(TypedDict):
        launch_time: pulumi.Input[_builtins.str]
        """
        Specifies the time when the scaling action is triggered.
        + If `scaling_policy_type` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
        + If `scaling_policy_type` is set to `RECURRENCE`, the time format is **hh:mm**.

        > the `launch_time` of the `SCHEDULED` policy cannot be earlier than the current time.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the end time of the scaling action triggered periodically. The time format complies
        with UTC. This argument is mandatory when `scaling_policy_type`
        is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.

        <a name="scaling_policy_action_object"></a>
        The `scaling_policy_action` block supports:
        """
        recurrence_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the periodic triggering type. This argument is mandatory when
        `scaling_policy_type` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
        """
        recurrence_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the frequency at which scaling actions are triggered.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the start time of the scaling action triggered periodically. The time format
        complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
        """
elif False:
    PolicyScheduledPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyScheduledPolicyArgs:
    def __init__(__self__, *,
                 launch_time: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_type: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_value: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] launch_time: Specifies the time when the scaling action is triggered.
               + If `scaling_policy_type` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
               + If `scaling_policy_type` is set to `RECURRENCE`, the time format is **hh:mm**.
               
               > the `launch_time` of the `SCHEDULED` policy cannot be earlier than the current time.
        :param pulumi.Input[_builtins.str] end_time: Specifies the end time of the scaling action triggered periodically. The time format complies
               with UTC. This argument is mandatory when `scaling_policy_type`
               is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.
               
               <a name="scaling_policy_action_object"></a>
               The `scaling_policy_action` block supports:
        :param pulumi.Input[_builtins.str] recurrence_type: Specifies the periodic triggering type. This argument is mandatory when
               `scaling_policy_type` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
        :param pulumi.Input[_builtins.str] recurrence_value: Specifies the frequency at which scaling actions are triggered.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time of the scaling action triggered periodically. The time format
               complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the time when the scaling action is triggered.
        + If `scaling_policy_type` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
        + If `scaling_policy_type` is set to `RECURRENCE`, the time format is **hh:mm**.

        > the `launch_time` of the `SCHEDULED` policy cannot be earlier than the current time.
        """
        return pulumi.get(self, "launch_time")

    @launch_time.setter
    def launch_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "launch_time", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the end time of the scaling action triggered periodically. The time format complies
        with UTC. This argument is mandatory when `scaling_policy_type`
        is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.

        <a name="scaling_policy_action_object"></a>
        The `scaling_policy_action` block supports:
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the periodic triggering type. This argument is mandatory when
        `scaling_policy_type` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_type", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the frequency at which scaling actions are triggered.
        """
        return pulumi.get(self, "recurrence_value")

    @recurrence_value.setter
    def recurrence_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_value", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the start time of the scaling action triggered periodically. The time format
        complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


