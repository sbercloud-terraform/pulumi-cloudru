# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ApigApplicationQuotaAssociateApplicationArgs',
    'ApigApplicationQuotaAssociateApplicationArgsDict',
    'ApigChannelHealthCheckArgs',
    'ApigChannelHealthCheckArgsDict',
    'ApigChannelMemberArgs',
    'ApigChannelMemberArgsDict',
    'ApigChannelMemberGroupArgs',
    'ApigChannelMemberGroupArgsDict',
    'ApigChannelMicroserviceArgs',
    'ApigChannelMicroserviceArgsDict',
    'ApigChannelMicroserviceCceConfigArgs',
    'ApigChannelMicroserviceCceConfigArgsDict',
    'ApigChannelMicroserviceCseConfigArgs',
    'ApigChannelMicroserviceCseConfigArgsDict',
    'CbrBackupShareMemberArgs',
    'CbrBackupShareMemberArgsDict',
    'CbrCheckpointBackupArgs',
    'CbrCheckpointBackupArgsDict',
    'DcsParametersConfigurationParameterArgs',
    'DcsParametersConfigurationParameterArgsDict',
    'DcsRestoreRestoreRecordArgs',
    'DcsRestoreRestoreRecordArgsDict',
    'DdsParameterTemplateCompareDifferenceArgs',
    'DdsParameterTemplateCompareDifferenceArgsDict',
    'DdsParameterTemplateCopyParameterArgs',
    'DdsParameterTemplateCopyParameterArgsDict',
    'DdsParameterTemplateParameterArgs',
    'DdsParameterTemplateParameterArgsDict',
    'DmsKafkaMessageProducePropertyListArgs',
    'DmsKafkaMessageProducePropertyListArgsDict',
    'DmsRocketmqConsumptionVerifyResendResultArgs',
    'DmsRocketmqConsumptionVerifyResendResultArgsDict',
    'DmsRocketmqDeadLetterResendResendResultArgs',
    'DmsRocketmqDeadLetterResendResendResultArgsDict',
    'DmsRocketmqInstanceConfigArgs',
    'DmsRocketmqInstanceConfigArgsDict',
    'DmsRocketmqInstanceCrossVpcAccessArgs',
    'DmsRocketmqInstanceCrossVpcAccessArgsDict',
    'DmsRocketmqMigrationTaskBindingArgs',
    'DmsRocketmqMigrationTaskBindingArgsDict',
    'DmsRocketmqMigrationTaskExchangeArgs',
    'DmsRocketmqMigrationTaskExchangeArgsDict',
    'DmsRocketmqMigrationTaskQueueArgs',
    'DmsRocketmqMigrationTaskQueueArgsDict',
    'DmsRocketmqMigrationTaskSubscriptionGroupArgs',
    'DmsRocketmqMigrationTaskSubscriptionGroupArgsDict',
    'DmsRocketmqMigrationTaskTopicConfigArgs',
    'DmsRocketmqMigrationTaskTopicConfigArgsDict',
    'DmsRocketmqMigrationTaskVhostArgs',
    'DmsRocketmqMigrationTaskVhostArgsDict',
    'DmsRocketmqTopicBrokerArgs',
    'DmsRocketmqTopicBrokerArgsDict',
    'DmsRocketmqTopicQueueArgs',
    'DmsRocketmqTopicQueueArgsDict',
    'DmsRocketmqUserGroupPermArgs',
    'DmsRocketmqUserGroupPermArgsDict',
    'DmsRocketmqUserTopicPermArgs',
    'DmsRocketmqUserTopicPermArgsDict',
    'ElbIpgroupIpListArgs',
    'ElbIpgroupIpListArgsDict',
    'ElbL7policyFixedResponseConfigArgs',
    'ElbL7policyFixedResponseConfigArgsDict',
    'ElbL7policyFixedResponseConfigInsertHeadersConfigArgs',
    'ElbL7policyFixedResponseConfigInsertHeadersConfigArgsDict',
    'ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs',
    'ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgsDict',
    'ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs',
    'ElbL7policyFixedResponseConfigRemoveHeadersConfigArgsDict',
    'ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs',
    'ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgsDict',
    'ElbL7policyFixedResponseConfigTrafficLimitConfigArgs',
    'ElbL7policyFixedResponseConfigTrafficLimitConfigArgsDict',
    'ElbL7policyRedirectPoolsConfigArgs',
    'ElbL7policyRedirectPoolsConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgsDict',
    'ElbL7policyRedirectPoolsStickySessionConfigArgs',
    'ElbL7policyRedirectPoolsStickySessionConfigArgsDict',
    'ElbL7policyRedirectUrlConfigArgs',
    'ElbL7policyRedirectUrlConfigArgsDict',
    'ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs',
    'ElbL7policyRedirectUrlConfigInsertHeadersConfigArgsDict',
    'ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs',
    'ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgsDict',
    'ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs',
    'ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgsDict',
    'ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs',
    'ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgsDict',
    'ElbL7ruleConditionArgs',
    'ElbL7ruleConditionArgsDict',
    'ElbListenerPortRangeArgs',
    'ElbListenerPortRangeArgsDict',
    'ElbMemberReasonArgs',
    'ElbMemberReasonArgsDict',
    'ElbMemberStatusArgs',
    'ElbMemberStatusArgsDict',
    'ElbMemberStatusReasonArgs',
    'ElbMemberStatusReasonArgsDict',
    'ElbPoolPersistenceArgs',
    'ElbPoolPersistenceArgsDict',
    'ElbSecurityPolicyListenerArgs',
    'ElbSecurityPolicyListenerArgsDict',
    'FgsApplicationRepositoryArgs',
    'FgsApplicationRepositoryArgsDict',
    'FgsApplicationStackResourceArgs',
    'FgsApplicationStackResourceArgsDict',
    'FgsAsyncInvokeConfigurationOnFailureArgs',
    'FgsAsyncInvokeConfigurationOnFailureArgsDict',
    'FgsAsyncInvokeConfigurationOnSuccessArgs',
    'FgsAsyncInvokeConfigurationOnSuccessArgsDict',
    'GesGraphEncryptionArgs',
    'GesGraphEncryptionArgsDict',
    'GesGraphLtsOperationTraceArgs',
    'GesGraphLtsOperationTraceArgsDict',
    'GesGraphPublicIpArgs',
    'GesGraphPublicIpArgsDict',
    'GesGraphVertexIdTypeArgs',
    'GesGraphVertexIdTypeArgsDict',
    'ObsBucketAclAccountPermissionArgs',
    'ObsBucketAclAccountPermissionArgsDict',
    'ObsBucketAclLogDeliveryUserPermissionArgs',
    'ObsBucketAclLogDeliveryUserPermissionArgsDict',
    'ObsBucketAclOwnerPermissionArgs',
    'ObsBucketAclOwnerPermissionArgsDict',
    'ObsBucketAclPublicPermissionArgs',
    'ObsBucketAclPublicPermissionArgsDict',
    'ProviderAssumeRoleArgs',
    'ProviderAssumeRoleArgsDict',
    'SfsTurboDuTaskDirUsageArgs',
    'SfsTurboDuTaskDirUsageArgsDict',
    'SfsTurboDuTaskDirUsageFileCountArgs',
    'SfsTurboDuTaskDirUsageFileCountArgsDict',
    'SfsTurboObsTargetObsArgs',
    'SfsTurboObsTargetObsArgsDict',
    'SfsTurboObsTargetObsAttributesArgs',
    'SfsTurboObsTargetObsAttributesArgsDict',
    'SfsTurboObsTargetObsPolicyArgs',
    'SfsTurboObsTargetObsPolicyArgsDict',
    'SfsTurboObsTargetObsPolicyAutoExportPolicyArgs',
    'SfsTurboObsTargetObsPolicyAutoExportPolicyArgsDict',
    'SmnSubscriptionExtensionArgs',
    'SmnSubscriptionExtensionArgsDict',
    'SmnSubscriptionFilterPolicyArgs',
    'SmnSubscriptionFilterPolicyArgsDict',
    'SwrOrganizationPermissionsSelfPermissionArgs',
    'SwrOrganizationPermissionsSelfPermissionArgsDict',
    'SwrOrganizationPermissionsUserArgs',
    'SwrOrganizationPermissionsUserArgsDict',
    'VpnConnectionIkepolicyArgs',
    'VpnConnectionIkepolicyArgsDict',
    'VpnConnectionIkepolicyDpdArgs',
    'VpnConnectionIkepolicyDpdArgsDict',
    'VpnConnectionIpsecpolicyArgs',
    'VpnConnectionIpsecpolicyArgsDict',
    'VpnConnectionPolicyRuleArgs',
    'VpnConnectionPolicyRuleArgsDict',
    'VpnGatewayCertificateArgs',
    'VpnGatewayCertificateArgsDict',
    'VpnGatewayEip1Args',
    'VpnGatewayEip1ArgsDict',
    'VpnGatewayEip2Args',
    'VpnGatewayEip2ArgsDict',
    'VpnGatewayMasterEipArgs',
    'VpnGatewayMasterEipArgsDict',
    'VpnGatewaySlaveEipArgs',
    'VpnGatewaySlaveEipArgsDict',
]

MYPY = False

if not MYPY:
    class ApigApplicationQuotaAssociateApplicationArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The application ID bound to the application quota.
        """
        bind_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The binding time, in RFC3339 format.
        """
elif False:
    ApigApplicationQuotaAssociateApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApplicationQuotaAssociateApplicationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 bind_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The application ID bound to the application quota.
        :param pulumi.Input[_builtins.str] bind_time: The binding time, in RFC3339 format.
        """
        pulumi.set(__self__, "id", id)
        if bind_time is not None:
            pulumi.set(__self__, "bind_time", bind_time)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The application ID bound to the application quota.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="bindTime")
    def bind_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The binding time, in RFC3339 format.
        """
        return pulumi.get(self, "bind_time")

    @bind_time.setter
    def bind_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_time", value)


if not MYPY:
    class ApigChannelHealthCheckArgsDict(TypedDict):
        interval: pulumi.Input[_builtins.int]
        """
        The interval between consecutive check, in second.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        The rotocol for performing health check on backend servers.
        """
        threshold_abnormal: pulumi.Input[_builtins.int]
        """
        The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
        """
        threshold_normal: pulumi.Input[_builtins.int]
        """
        The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
        """
        timeout: pulumi.Input[_builtins.int]
        """
        The timeout for determining whether a health check fails, in second.
        """
        enable_client_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable two-way authentication.
        """
        http_codes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The response codes for determining a successful HTTP response.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The request method for health check.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The destination path for health check.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The destination host port for health check.
        """
        status: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status of health check.
        """
elif False:
    ApigChannelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelHealthCheckArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 threshold_abnormal: pulumi.Input[_builtins.int],
                 threshold_normal: pulumi.Input[_builtins.int],
                 timeout: pulumi.Input[_builtins.int],
                 enable_client_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 http_codes: Optional[pulumi.Input[_builtins.str]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: The interval between consecutive check, in second.
        :param pulumi.Input[_builtins.str] protocol: The rotocol for performing health check on backend servers.
        :param pulumi.Input[_builtins.int] threshold_abnormal: The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
        :param pulumi.Input[_builtins.int] threshold_normal: The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
        :param pulumi.Input[_builtins.int] timeout: The timeout for determining whether a health check fails, in second.
        :param pulumi.Input[_builtins.bool] enable_client_ssl: Whether to enable two-way authentication.
        :param pulumi.Input[_builtins.str] http_codes: The response codes for determining a successful HTTP response.
        :param pulumi.Input[_builtins.str] method: The request method for health check.
        :param pulumi.Input[_builtins.str] path: The destination path for health check.
        :param pulumi.Input[_builtins.int] port: The destination host port for health check.
        :param pulumi.Input[_builtins.int] status: The status of health check.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "threshold_abnormal", threshold_abnormal)
        pulumi.set(__self__, "threshold_normal", threshold_normal)
        pulumi.set(__self__, "timeout", timeout)
        if enable_client_ssl is not None:
            pulumi.set(__self__, "enable_client_ssl", enable_client_ssl)
        if http_codes is not None:
            pulumi.set(__self__, "http_codes", http_codes)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> pulumi.Input[_builtins.int]:
        """
        The interval between consecutive check, in second.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The rotocol for performing health check on backend servers.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="thresholdAbnormal")
    def threshold_abnormal(self) -> pulumi.Input[_builtins.int]:
        """
        The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
        """
        return pulumi.get(self, "threshold_abnormal")

    @threshold_abnormal.setter
    def threshold_abnormal(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold_abnormal", value)

    @_builtins.property
    @pulumi.getter(name="thresholdNormal")
    def threshold_normal(self) -> pulumi.Input[_builtins.int]:
        """
        The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
        """
        return pulumi.get(self, "threshold_normal")

    @threshold_normal.setter
    def threshold_normal(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold_normal", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[_builtins.int]:
        """
        The timeout for determining whether a health check fails, in second.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter(name="enableClientSsl")
    def enable_client_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable two-way authentication.
        """
        return pulumi.get(self, "enable_client_ssl")

    @enable_client_ssl.setter
    def enable_client_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_client_ssl", value)

    @_builtins.property
    @pulumi.getter(name="httpCodes")
    def http_codes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The response codes for determining a successful HTTP response.
        """
        return pulumi.get(self, "http_codes")

    @http_codes.setter
    def http_codes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_codes", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The request method for health check.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The destination path for health check.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The destination host port for health check.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status of health check.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ApigChannelMemberArgsDict(TypedDict):
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The group name of the backend server.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the backend server.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the backend server.
        """
        is_backup: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this member is the backup member.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the backend server.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port of the backend server.
        """
        status: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status of the backend server.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The weight of current backend server.
        """
elif False:
    ApigChannelMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMemberArgs:
    def __init__(__self__, *,
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_backup: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] group_name: The group name of the backend server.
        :param pulumi.Input[_builtins.str] host: The IP address of the backend server.
        :param pulumi.Input[_builtins.str] id: The ID of the backend server.
        :param pulumi.Input[_builtins.bool] is_backup: Whether this member is the backup member.
        :param pulumi.Input[_builtins.str] name: The name of the backend server.
        :param pulumi.Input[_builtins.int] port: The port of the backend server.
        :param pulumi.Input[_builtins.int] status: The status of the backend server.
        :param pulumi.Input[_builtins.int] weight: The weight of current backend server.
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_backup is not None:
            pulumi.set(__self__, "is_backup", is_backup)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The group name of the backend server.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the backend server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the backend server.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isBackup")
    def is_backup(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this member is the backup member.
        """
        return pulumi.get(self, "is_backup")

    @is_backup.setter
    def is_backup(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_backup", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the backend server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port of the backend server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status of the backend server.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The weight of current backend server.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ApigChannelMemberGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the member group.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the member group.
        """
        microservice_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The microservice tags of the backend server group.
        """
        microservice_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The microservice port of the backend server group.
        """
        microservice_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The microservice version of the backend server group.
        """
        reference_vpc_channel_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the reference load balance channel.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The weight of the current member group.
        """
elif False:
    ApigChannelMemberGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMemberGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 microservice_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 microservice_port: Optional[pulumi.Input[_builtins.int]] = None,
                 microservice_version: Optional[pulumi.Input[_builtins.str]] = None,
                 reference_vpc_channel_id: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the member group.
        :param pulumi.Input[_builtins.str] description: The description of the member group.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] microservice_labels: The microservice tags of the backend server group.
        :param pulumi.Input[_builtins.int] microservice_port: The microservice port of the backend server group.
        :param pulumi.Input[_builtins.str] microservice_version: The microservice version of the backend server group.
        :param pulumi.Input[_builtins.str] reference_vpc_channel_id: The ID of the reference load balance channel.
        :param pulumi.Input[_builtins.int] weight: The weight of the current member group.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if microservice_labels is not None:
            pulumi.set(__self__, "microservice_labels", microservice_labels)
        if microservice_port is not None:
            pulumi.set(__self__, "microservice_port", microservice_port)
        if microservice_version is not None:
            pulumi.set(__self__, "microservice_version", microservice_version)
        if reference_vpc_channel_id is not None:
            pulumi.set(__self__, "reference_vpc_channel_id", reference_vpc_channel_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the member group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the member group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="microserviceLabels")
    def microservice_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The microservice tags of the backend server group.
        """
        return pulumi.get(self, "microservice_labels")

    @microservice_labels.setter
    def microservice_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "microservice_labels", value)

    @_builtins.property
    @pulumi.getter(name="microservicePort")
    def microservice_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The microservice port of the backend server group.
        """
        return pulumi.get(self, "microservice_port")

    @microservice_port.setter
    def microservice_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "microservice_port", value)

    @_builtins.property
    @pulumi.getter(name="microserviceVersion")
    def microservice_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The microservice version of the backend server group.
        """
        return pulumi.get(self, "microservice_version")

    @microservice_version.setter
    def microservice_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "microservice_version", value)

    @_builtins.property
    @pulumi.getter(name="referenceVpcChannelId")
    def reference_vpc_channel_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the reference load balance channel.
        """
        return pulumi.get(self, "reference_vpc_channel_id")

    @reference_vpc_channel_id.setter
    def reference_vpc_channel_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reference_vpc_channel_id", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The weight of the current member group.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ApigChannelMicroserviceArgsDict(TypedDict):
        cce_config: NotRequired[pulumi.Input['ApigChannelMicroserviceCceConfigArgsDict']]
        """
        The CCE microservice details.
        """
        cse_config: NotRequired[pulumi.Input['ApigChannelMicroserviceCseConfigArgsDict']]
        """
        schema:Internal; The CSE microservice details.
        """
elif False:
    ApigChannelMicroserviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMicroserviceArgs:
    def __init__(__self__, *,
                 cce_config: Optional[pulumi.Input['ApigChannelMicroserviceCceConfigArgs']] = None,
                 cse_config: Optional[pulumi.Input['ApigChannelMicroserviceCseConfigArgs']] = None):
        """
        :param pulumi.Input['ApigChannelMicroserviceCceConfigArgs'] cce_config: The CCE microservice details.
        :param pulumi.Input['ApigChannelMicroserviceCseConfigArgs'] cse_config: schema:Internal; The CSE microservice details.
        """
        if cce_config is not None:
            pulumi.set(__self__, "cce_config", cce_config)
        if cse_config is not None:
            pulumi.set(__self__, "cse_config", cse_config)

    @_builtins.property
    @pulumi.getter(name="cceConfig")
    def cce_config(self) -> Optional[pulumi.Input['ApigChannelMicroserviceCceConfigArgs']]:
        """
        The CCE microservice details.
        """
        return pulumi.get(self, "cce_config")

    @cce_config.setter
    def cce_config(self, value: Optional[pulumi.Input['ApigChannelMicroserviceCceConfigArgs']]):
        pulumi.set(self, "cce_config", value)

    @_builtins.property
    @pulumi.getter(name="cseConfig")
    def cse_config(self) -> Optional[pulumi.Input['ApigChannelMicroserviceCseConfigArgs']]:
        """
        schema:Internal; The CSE microservice details.
        """
        return pulumi.get(self, "cse_config")

    @cse_config.setter
    def cse_config(self, value: Optional[pulumi.Input['ApigChannelMicroserviceCseConfigArgs']]):
        pulumi.set(self, "cse_config", value)


if not MYPY:
    class ApigChannelMicroserviceCceConfigArgsDict(TypedDict):
        cluster_id: pulumi.Input[_builtins.str]
        """
        The ID of the CCE cluster.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        The name of the CCE namespace.
        """
        workload_type: pulumi.Input[_builtins.str]
        """
        The workload type.
        """
        label_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service label key.
        """
        label_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The service label value.
        """
        workload_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The workload name.
        """
elif False:
    ApigChannelMicroserviceCceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMicroserviceCceConfigArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 workload_type: pulumi.Input[_builtins.str],
                 label_key: Optional[pulumi.Input[_builtins.str]] = None,
                 label_value: Optional[pulumi.Input[_builtins.str]] = None,
                 workload_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: The ID of the CCE cluster.
        :param pulumi.Input[_builtins.str] namespace: The name of the CCE namespace.
        :param pulumi.Input[_builtins.str] workload_type: The workload type.
        :param pulumi.Input[_builtins.str] label_key: The service label key.
        :param pulumi.Input[_builtins.str] label_value: The service label value.
        :param pulumi.Input[_builtins.str] workload_name: The workload name.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "workload_type", workload_type)
        if label_key is not None:
            pulumi.set(__self__, "label_key", label_key)
        if label_value is not None:
            pulumi.set(__self__, "label_value", label_value)
        if workload_name is not None:
            pulumi.set(__self__, "workload_name", workload_name)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the CCE cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the CCE namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> pulumi.Input[_builtins.str]:
        """
        The workload type.
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workload_type", value)

    @_builtins.property
    @pulumi.getter(name="labelKey")
    def label_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service label key.
        """
        return pulumi.get(self, "label_key")

    @label_key.setter
    def label_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label_key", value)

    @_builtins.property
    @pulumi.getter(name="labelValue")
    def label_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The service label value.
        """
        return pulumi.get(self, "label_value")

    @label_value.setter
    def label_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label_value", value)

    @_builtins.property
    @pulumi.getter(name="workloadName")
    def workload_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The workload name.
        """
        return pulumi.get(self, "workload_name")

    @workload_name.setter
    def workload_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workload_name", value)


if not MYPY:
    class ApigChannelMicroserviceCseConfigArgsDict(TypedDict):
        engine_id: pulumi.Input[_builtins.str]
        """
        schema:Internal; The microservice engine ID.
        """
        service_id: pulumi.Input[_builtins.str]
        """
        schema:Internal; The microservice ID.
        """
elif False:
    ApigChannelMicroserviceCseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMicroserviceCseConfigArgs:
    def __init__(__self__, *,
                 engine_id: pulumi.Input[_builtins.str],
                 service_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] engine_id: schema:Internal; The microservice engine ID.
        :param pulumi.Input[_builtins.str] service_id: schema:Internal; The microservice ID.
        """
        pulumi.set(__self__, "engine_id", engine_id)
        pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> pulumi.Input[_builtins.str]:
        """
        schema:Internal; The microservice engine ID.
        """
        return pulumi.get(self, "engine_id")

    @engine_id.setter
    def engine_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "engine_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> pulumi.Input[_builtins.str]:
        """
        schema:Internal; The microservice ID.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_id", value)


if not MYPY:
    class CbrBackupShareMemberArgsDict(TypedDict):
        dest_project_id: pulumi.Input[_builtins.str]
        """
        The ID of the project with which the backup is shared.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The creation time of the backup shared member.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the backup shared member record.
        """
        image_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the image registered with the shared backup copy.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The backup shared status.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The latest update time of the backup shared member.
        """
        vault_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the vault where the shared backup is stored.
        """
elif False:
    CbrBackupShareMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CbrBackupShareMemberArgs:
    def __init__(__self__, *,
                 dest_project_id: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 vault_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dest_project_id: The ID of the project with which the backup is shared.
        :param pulumi.Input[_builtins.str] created_at: The creation time of the backup shared member.
        :param pulumi.Input[_builtins.str] id: The ID of the backup shared member record.
        :param pulumi.Input[_builtins.str] image_id: The ID of the image registered with the shared backup copy.
        :param pulumi.Input[_builtins.str] status: The backup shared status.
        :param pulumi.Input[_builtins.str] updated_at: The latest update time of the backup shared member.
        :param pulumi.Input[_builtins.str] vault_id: The ID of the vault where the shared backup is stored.
        """
        pulumi.set(__self__, "dest_project_id", dest_project_id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @_builtins.property
    @pulumi.getter(name="destProjectId")
    def dest_project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the project with which the backup is shared.
        """
        return pulumi.get(self, "dest_project_id")

    @dest_project_id.setter
    def dest_project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dest_project_id", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The creation time of the backup shared member.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the backup shared member record.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the image registered with the shared backup copy.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The backup shared status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The latest update time of the backup shared member.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the vault where the shared backup is stored.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class CbrCheckpointBackupArgsDict(TypedDict):
        resource_id: pulumi.Input[_builtins.str]
        """
        The ID of backup resource.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of the backup resource.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The backup ID.
        """
        protected_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The backup time.
        """
        resource_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The backup resource size.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The backup status.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The latest update time of the backup.
        """
elif False:
    CbrCheckpointBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CbrCheckpointBackupArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 protected_at: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_size: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_id: The ID of backup resource.
        :param pulumi.Input[_builtins.str] type: The type of the backup resource.
        :param pulumi.Input[_builtins.str] id: The backup ID.
        :param pulumi.Input[_builtins.str] protected_at: The backup time.
        :param pulumi.Input[_builtins.int] resource_size: The backup resource size.
        :param pulumi.Input[_builtins.str] status: The backup status.
        :param pulumi.Input[_builtins.str] updated_at: The latest update time of the backup.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if protected_at is not None:
            pulumi.set(__self__, "protected_at", protected_at)
        if resource_size is not None:
            pulumi.set(__self__, "resource_size", resource_size)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of backup resource.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the backup resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The backup ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="protectedAt")
    def protected_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The backup time.
        """
        return pulumi.get(self, "protected_at")

    @protected_at.setter
    def protected_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protected_at", value)

    @_builtins.property
    @pulumi.getter(name="resourceSize")
    def resource_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The backup resource size.
        """
        return pulumi.get(self, "resource_size")

    @resource_size.setter
    def resource_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "resource_size", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The backup status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The latest update time of the backup.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class DcsParametersConfigurationParameterArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter name.
        """
        need_restart: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether a restart is required.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter type.
        """
        user_permission: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates a user permission
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter value.
        """
elif False:
    DcsParametersConfigurationParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DcsParametersConfigurationParameterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 need_restart: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 user_permission: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Indicates the parameter name.
        :param pulumi.Input[_builtins.bool] need_restart: Indicates whether a restart is required.
        :param pulumi.Input[_builtins.str] type: Indicates the parameter type.
        :param pulumi.Input[_builtins.str] user_permission: Indicates a user permission
        :param pulumi.Input[_builtins.str] value: Indicates the parameter value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if need_restart is not None:
            pulumi.set(__self__, "need_restart", need_restart)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_permission is not None:
            pulumi.set(__self__, "user_permission", user_permission)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="needRestart")
    def need_restart(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether a restart is required.
        """
        return pulumi.get(self, "need_restart")

    @need_restart.setter
    def need_restart(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "need_restart", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userPermission")
    def user_permission(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates a user permission
        """
        return pulumi.get(self, "user_permission")

    @user_permission.setter
    def user_permission(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_permission", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DcsRestoreRestoreRecordArgsDict(TypedDict):
        backup_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the backup record.
        """
        backup_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the backup record.
        """
        backup_remark: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of DCS instance backup.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time at which the restoration task is created.
        """
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Error code returned if DCS instance restoration fails.
        """
        progress: NotRequired[pulumi.Input[_builtins.str]]
        """
        Restoration progress.
        """
        restore_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the restoration record.
        """
        restore_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the restoration record.
        """
        restore_remark: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of DCS instance restoration.
        """
        source_instance_id: NotRequired[pulumi.Input[_builtins.str]]
        source_instance_name: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Restoration status:
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time at which DCS instance restoration completed.
        """
elif False:
    DcsRestoreRestoreRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DcsRestoreRestoreRecordArgs:
    def __init__(__self__, *,
                 backup_id: Optional[pulumi.Input[_builtins.str]] = None,
                 backup_name: Optional[pulumi.Input[_builtins.str]] = None,
                 backup_remark: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 progress: Optional[pulumi.Input[_builtins.str]] = None,
                 restore_id: Optional[pulumi.Input[_builtins.str]] = None,
                 restore_name: Optional[pulumi.Input[_builtins.str]] = None,
                 restore_remark: Optional[pulumi.Input[_builtins.str]] = None,
                 source_instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_instance_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] backup_id: ID of the backup record.
        :param pulumi.Input[_builtins.str] backup_name: Name of the backup record.
        :param pulumi.Input[_builtins.str] backup_remark: Description of DCS instance backup.
        :param pulumi.Input[_builtins.str] created_at: Time at which the restoration task is created.
        :param pulumi.Input[_builtins.str] error_code: Error code returned if DCS instance restoration fails.
        :param pulumi.Input[_builtins.str] progress: Restoration progress.
        :param pulumi.Input[_builtins.str] restore_id: ID of the restoration record.
        :param pulumi.Input[_builtins.str] restore_name: Name of the restoration record.
        :param pulumi.Input[_builtins.str] restore_remark: Description of DCS instance restoration.
        :param pulumi.Input[_builtins.str] status: Restoration status:
        :param pulumi.Input[_builtins.str] updated_at: Time at which DCS instance restoration completed.
        """
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_name is not None:
            pulumi.set(__self__, "backup_name", backup_name)
        if backup_remark is not None:
            pulumi.set(__self__, "backup_remark", backup_remark)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if restore_id is not None:
            pulumi.set(__self__, "restore_id", restore_id)
        if restore_name is not None:
            pulumi.set(__self__, "restore_name", restore_name)
        if restore_remark is not None:
            pulumi.set(__self__, "restore_remark", restore_remark)
        if source_instance_id is not None:
            pulumi.set(__self__, "source_instance_id", source_instance_id)
        if source_instance_name is not None:
            pulumi.set(__self__, "source_instance_name", source_instance_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the backup record.
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_id", value)

    @_builtins.property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the backup record.
        """
        return pulumi.get(self, "backup_name")

    @backup_name.setter
    def backup_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_name", value)

    @_builtins.property
    @pulumi.getter(name="backupRemark")
    def backup_remark(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of DCS instance backup.
        """
        return pulumi.get(self, "backup_remark")

    @backup_remark.setter
    def backup_remark(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_remark", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time at which the restoration task is created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Error code returned if DCS instance restoration fails.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter
    def progress(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Restoration progress.
        """
        return pulumi.get(self, "progress")

    @progress.setter
    def progress(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "progress", value)

    @_builtins.property
    @pulumi.getter(name="restoreId")
    def restore_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the restoration record.
        """
        return pulumi.get(self, "restore_id")

    @restore_id.setter
    def restore_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restore_id", value)

    @_builtins.property
    @pulumi.getter(name="restoreName")
    def restore_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the restoration record.
        """
        return pulumi.get(self, "restore_name")

    @restore_name.setter
    def restore_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restore_name", value)

    @_builtins.property
    @pulumi.getter(name="restoreRemark")
    def restore_remark(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of DCS instance restoration.
        """
        return pulumi.get(self, "restore_remark")

    @restore_remark.setter
    def restore_remark(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restore_remark", value)

    @_builtins.property
    @pulumi.getter(name="sourceInstanceId")
    def source_instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_instance_id")

    @source_instance_id.setter
    def source_instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_instance_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceInstanceName")
    def source_instance_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_instance_name")

    @source_instance_name.setter
    def source_instance_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_instance_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Restoration status:
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time at which DCS instance restoration completed.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class DdsParameterTemplateCompareDifferenceArgsDict(TypedDict):
        parameter_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter name.
        """
        source_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter value in the source parameter template.
        """
        target_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter value in the destination parameter template.
        """
elif False:
    DdsParameterTemplateCompareDifferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsParameterTemplateCompareDifferenceArgs:
    def __init__(__self__, *,
                 parameter_name: Optional[pulumi.Input[_builtins.str]] = None,
                 source_value: Optional[pulumi.Input[_builtins.str]] = None,
                 target_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter_name: Indicates the parameter name.
        :param pulumi.Input[_builtins.str] source_value: Indicates the parameter value in the source parameter template.
        :param pulumi.Input[_builtins.str] target_value: Indicates the parameter value in the destination parameter template.
        """
        if parameter_name is not None:
            pulumi.set(__self__, "parameter_name", parameter_name)
        if source_value is not None:
            pulumi.set(__self__, "source_value", source_value)
        if target_value is not None:
            pulumi.set(__self__, "target_value", target_value)

    @_builtins.property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter name.
        """
        return pulumi.get(self, "parameter_name")

    @parameter_name.setter
    def parameter_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter_name", value)

    @_builtins.property
    @pulumi.getter(name="sourceValue")
    def source_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter value in the source parameter template.
        """
        return pulumi.get(self, "source_value")

    @source_value.setter
    def source_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_value", value)

    @_builtins.property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter value in the destination parameter template.
        """
        return pulumi.get(self, "target_value")

    @target_value.setter
    def target_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_value", value)


if not MYPY:
    class DdsParameterTemplateCopyParameterArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of replicated parameter template.
        The value is left blank by default. The description must consist of a maximum of **256** characters and cannot contain
        the carriage return character or the following special characters: >!<"&'=
        Changing this creates a new resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of replicated parameter template.
        The parameter template name can contain **1** to **64** characters. It can contain only letters, digits, hyphens (-),
        underscores (_), and periods (.).
        Changing this creates a new resource.
        """
        readonly: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the parameter is read-only.
        + If the value is **true**, the parameter is read-only.
        + If the value is **false**, the parameter is not read-only.
        """
        restart_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the instance needs to be restarted.
        + If the value is **true**, restart is required.
        + If the value is **false**, restart is not required.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter type. The value can be integer, string, boolean, float, or list.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter value.
        """
        value_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the value range.
        """
elif False:
    DdsParameterTemplateCopyParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsParameterTemplateCopyParameterArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 readonly: Optional[pulumi.Input[_builtins.bool]] = None,
                 restart_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_range: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Specifies the description of replicated parameter template.
               The value is left blank by default. The description must consist of a maximum of **256** characters and cannot contain
               the carriage return character or the following special characters: >!<"&'=
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the name of replicated parameter template.
               The parameter template name can contain **1** to **64** characters. It can contain only letters, digits, hyphens (-),
               underscores (_), and periods (.).
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] readonly: Indicates whether the parameter is read-only.
               + If the value is **true**, the parameter is read-only.
               + If the value is **false**, the parameter is not read-only.
        :param pulumi.Input[_builtins.bool] restart_required: Indicates whether the instance needs to be restarted.
               + If the value is **true**, restart is required.
               + If the value is **false**, restart is not required.
        :param pulumi.Input[_builtins.str] type: Indicates the parameter type. The value can be integer, string, boolean, float, or list.
        :param pulumi.Input[_builtins.str] value: Indicates the parameter value.
        :param pulumi.Input[_builtins.str] value_range: Indicates the value range.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if restart_required is not None:
            pulumi.set(__self__, "restart_required", restart_required)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_range is not None:
            pulumi.set(__self__, "value_range", value_range)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of replicated parameter template.
        The value is left blank by default. The description must consist of a maximum of **256** characters and cannot contain
        the carriage return character or the following special characters: >!<"&'=
        Changing this creates a new resource.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of replicated parameter template.
        The parameter template name can contain **1** to **64** characters. It can contain only letters, digits, hyphens (-),
        underscores (_), and periods (.).
        Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the parameter is read-only.
        + If the value is **true**, the parameter is read-only.
        + If the value is **false**, the parameter is not read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "readonly", value)

    @_builtins.property
    @pulumi.getter(name="restartRequired")
    def restart_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the instance needs to be restarted.
        + If the value is **true**, restart is required.
        + If the value is **false**, restart is not required.
        """
        return pulumi.get(self, "restart_required")

    @restart_required.setter
    def restart_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "restart_required", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter type. The value can be integer, string, boolean, float, or list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueRange")
    def value_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the value range.
        """
        return pulumi.get(self, "value_range")

    @value_range.setter
    def value_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_range", value)


if not MYPY:
    class DdsParameterTemplateParameterArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the parameter template description.
        The description must consist of a maximum of 256 characters and cannot contain the carriage
        return character or the following special characters: >!<"&'=.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the parameter template name.
        The value must be 1 to 64 characters, which can contain only letters, digits, hyphens (-),
        underscores (_), and periods (.).
        """
        readonly: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the parameter is read-only.
        + If the value is **true**, the parameter is read-only.
        + If the value is **false**, the parameter is not read-only.
        """
        restart_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the instance needs to be restarted.
        + If the value is **true**, restart is required.
        + If the value is **false**, restart is not required.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter type. The value can be integer, string, boolean, float, or list.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the parameter value.
        """
        value_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the value range.
        """
elif False:
    DdsParameterTemplateParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsParameterTemplateParameterArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 readonly: Optional[pulumi.Input[_builtins.bool]] = None,
                 restart_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_range: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Specifies the parameter template description.
               The description must consist of a maximum of 256 characters and cannot contain the carriage
               return character or the following special characters: >!<"&'=.
        :param pulumi.Input[_builtins.str] name: Specifies the parameter template name.
               The value must be 1 to 64 characters, which can contain only letters, digits, hyphens (-),
               underscores (_), and periods (.).
        :param pulumi.Input[_builtins.bool] readonly: Indicates whether the parameter is read-only.
               + If the value is **true**, the parameter is read-only.
               + If the value is **false**, the parameter is not read-only.
        :param pulumi.Input[_builtins.bool] restart_required: Indicates whether the instance needs to be restarted.
               + If the value is **true**, restart is required.
               + If the value is **false**, restart is not required.
        :param pulumi.Input[_builtins.str] type: Indicates the parameter type. The value can be integer, string, boolean, float, or list.
        :param pulumi.Input[_builtins.str] value: Indicates the parameter value.
        :param pulumi.Input[_builtins.str] value_range: Indicates the value range.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if restart_required is not None:
            pulumi.set(__self__, "restart_required", restart_required)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_range is not None:
            pulumi.set(__self__, "value_range", value_range)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the parameter template description.
        The description must consist of a maximum of 256 characters and cannot contain the carriage
        return character or the following special characters: >!<"&'=.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the parameter template name.
        The value must be 1 to 64 characters, which can contain only letters, digits, hyphens (-),
        underscores (_), and periods (.).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the parameter is read-only.
        + If the value is **true**, the parameter is read-only.
        + If the value is **false**, the parameter is not read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "readonly", value)

    @_builtins.property
    @pulumi.getter(name="restartRequired")
    def restart_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the instance needs to be restarted.
        + If the value is **true**, restart is required.
        + If the value is **false**, restart is not required.
        """
        return pulumi.get(self, "restart_required")

    @restart_required.setter
    def restart_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "restart_required", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter type. The value can be integer, string, boolean, float, or list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the parameter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueRange")
    def value_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the value range.
        """
        return pulumi.get(self, "value_range")

    @value_range.setter
    def value_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_range", value)


if not MYPY:
    class DmsKafkaMessageProducePropertyListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    DmsKafkaMessageProducePropertyListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsKafkaMessageProducePropertyListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DmsRocketmqConsumptionVerifyResendResultArgsDict(TypedDict):
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error code.
        """
        error_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error message.
        """
        message_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the message ID.
        """
elif False:
    DmsRocketmqConsumptionVerifyResendResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqConsumptionVerifyResendResultArgs:
    def __init__(__self__, *,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_message: Optional[pulumi.Input[_builtins.str]] = None,
                 message_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_code: Indicates the error code.
        :param pulumi.Input[_builtins.str] error_message: Indicates the error message.
        :param pulumi.Input[_builtins.str] message_id: Indicates the message ID.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error code.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error message.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_message", value)

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the message ID.
        """
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_id", value)


if not MYPY:
    class DmsRocketmqDeadLetterResendResendResultArgsDict(TypedDict):
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error code.
        """
        error_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error message.
        """
        message_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the message ID.
        """
elif False:
    DmsRocketmqDeadLetterResendResendResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqDeadLetterResendResendResultArgs:
    def __init__(__self__, *,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_message: Optional[pulumi.Input[_builtins.str]] = None,
                 message_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_code: Indicates the error code.
        :param pulumi.Input[_builtins.str] error_message: Indicates the error message.
        :param pulumi.Input[_builtins.str] message_id: Indicates the message ID.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error code.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error message.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_message", value)

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the message ID.
        """
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_id", value)


if not MYPY:
    class DmsRocketmqInstanceConfigArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the config name.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the config value.

        > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
        """
elif False:
    DmsRocketmqInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqInstanceConfigArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the config name.
        :param pulumi.Input[_builtins.str] value: Specifies the config value.
               
               > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the config name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the config value.

        > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DmsRocketmqInstanceCrossVpcAccessArgsDict(TypedDict):
        advertised_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The advertised IP Address or domain name.
        """
        lisenter_ip: NotRequired[pulumi.Input[_builtins.str]]
        listener_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The listener IP address.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number.
        """
        port_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port ID associated with the address.
        """
elif False:
    DmsRocketmqInstanceCrossVpcAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqInstanceCrossVpcAccessArgs:
    def __init__(__self__, *,
                 advertised_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 lisenter_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 listener_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] advertised_ip: The advertised IP Address or domain name.
        :param pulumi.Input[_builtins.str] listener_ip: The listener IP address.
        :param pulumi.Input[_builtins.int] port: The port number.
        :param pulumi.Input[_builtins.str] port_id: The port ID associated with the address.
        """
        if advertised_ip is not None:
            pulumi.set(__self__, "advertised_ip", advertised_ip)
        if lisenter_ip is not None:
            warnings.warn("""typo in lisenter_ip, please use \"listener_ip\" instead.""", DeprecationWarning)
            pulumi.log.warn("""lisenter_ip is deprecated: typo in lisenter_ip, please use \"listener_ip\" instead.""")
        if lisenter_ip is not None:
            pulumi.set(__self__, "lisenter_ip", lisenter_ip)
        if listener_ip is not None:
            pulumi.set(__self__, "listener_ip", listener_ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="advertisedIp")
    def advertised_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The advertised IP Address or domain name.
        """
        return pulumi.get(self, "advertised_ip")

    @advertised_ip.setter
    def advertised_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "advertised_ip", value)

    @_builtins.property
    @pulumi.getter(name="lisenterIp")
    @_utilities.deprecated("""typo in lisenter_ip, please use \"listener_ip\" instead.""")
    def lisenter_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "lisenter_ip")

    @lisenter_ip.setter
    def lisenter_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lisenter_ip", value)

    @_builtins.property
    @pulumi.getter(name="listenerIp")
    def listener_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The listener IP address.
        """
        return pulumi.get(self, "listener_ip")

    @listener_ip.setter
    def listener_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port ID associated with the address.
        """
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_id", value)


if not MYPY:
    class DmsRocketmqMigrationTaskBindingArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the message target. Changing this creates a new resource.
        """
        destination_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the message target type.
        Changing this creates a new resource.
        """
        routing_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the routing key. Changing this creates a new resource.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the message source. Changing this creates a new resource.
        """
        vhost: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
elif False:
    DmsRocketmqMigrationTaskBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqMigrationTaskBindingArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_type: Optional[pulumi.Input[_builtins.str]] = None,
                 routing_key: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 vhost: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the message target. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] destination_type: Specifies the message target type.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] routing_key: Specifies the routing key. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] source: Specifies the message source. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the message target. Changing this creates a new resource.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the message target type.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the routing key. Changing this creates a new resource.
        """
        return pulumi.get(self, "routing_key")

    @routing_key.setter
    def routing_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "routing_key", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the message source. Changing this creates a new resource.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class DmsRocketmqMigrationTaskExchangeArgsDict(TypedDict):
        durable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the exchange type. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_bindings"></a>
        The `bindings` block supports:
        """
        vhost: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
elif False:
    DmsRocketmqMigrationTaskExchangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqMigrationTaskExchangeArgs:
    def __init__(__self__, *,
                 durable: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 vhost: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] durable: Specifies whether to enable data persistence.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the switch name. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] type: Specifies the exchange type. Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_bindings"></a>
               The `bindings` block supports:
        :param pulumi.Input[_builtins.str] vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if durable is not None:
            pulumi.set(__self__, "durable", durable)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def durable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "durable")

    @durable.setter
    def durable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "durable", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the exchange type. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_bindings"></a>
        The `bindings` block supports:
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class DmsRocketmqMigrationTaskQueueArgsDict(TypedDict):
        durable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        vhost: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
elif False:
    DmsRocketmqMigrationTaskQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqMigrationTaskQueueArgs:
    def __init__(__self__, *,
                 durable: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 vhost: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] durable: Specifies whether to enable data persistence.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the switch name. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if durable is not None:
            pulumi.set(__self__, "durable", durable)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def durable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "durable")

    @durable.setter
    def durable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "durable", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class DmsRocketmqMigrationTaskSubscriptionGroupArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of a consumer group.
        Changing this creates a new resource.
        """
        consume_broadcast_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable broadcast.
        Changing this creates a new resource.
        """
        consume_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable consumption.
        Changing this creates a new resource.
        """
        consume_from_min_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable consumption from the earliest
        offset. Changing this creates a new resource.
        """
        notify_consumerids_changed_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to notify changes of consumer IDs.
        Changing this creates a new resource.
        """
        retry_max_times: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum number of consumption retries.
        Changing this creates a new resource.
        """
        retry_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of retry queues.
        Changing this creates a new resource.
        """
        which_broker_when_consume_slow: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the ID of the broker selected for slow
        consumption. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_vhosts"></a>
        The `vhosts` block supports:
        """
elif False:
    DmsRocketmqMigrationTaskSubscriptionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqMigrationTaskSubscriptionGroupArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str],
                 consume_broadcast_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 consume_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 consume_from_min_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 notify_consumerids_changed_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 retry_max_times: Optional[pulumi.Input[_builtins.int]] = None,
                 retry_queue_num: Optional[pulumi.Input[_builtins.int]] = None,
                 which_broker_when_consume_slow: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] group_name: Specifies the name of a consumer group.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] consume_broadcast_enable: Specifies whether to enable broadcast.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] consume_enable: Specifies whether to enable consumption.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] consume_from_min_enable: Specifies whether to enable consumption from the earliest
               offset. Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] notify_consumerids_changed_enable: Specifies whether to notify changes of consumer IDs.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] retry_max_times: Specifies the maximum number of consumption retries.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] retry_queue_num: Specifies the number of retry queues.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] which_broker_when_consume_slow: Specifies the ID of the broker selected for slow
               consumption. Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_vhosts"></a>
               The `vhosts` block supports:
        """
        pulumi.set(__self__, "group_name", group_name)
        if consume_broadcast_enable is not None:
            pulumi.set(__self__, "consume_broadcast_enable", consume_broadcast_enable)
        if consume_enable is not None:
            pulumi.set(__self__, "consume_enable", consume_enable)
        if consume_from_min_enable is not None:
            pulumi.set(__self__, "consume_from_min_enable", consume_from_min_enable)
        if notify_consumerids_changed_enable is not None:
            pulumi.set(__self__, "notify_consumerids_changed_enable", notify_consumerids_changed_enable)
        if retry_max_times is not None:
            pulumi.set(__self__, "retry_max_times", retry_max_times)
        if retry_queue_num is not None:
            pulumi.set(__self__, "retry_queue_num", retry_queue_num)
        if which_broker_when_consume_slow is not None:
            pulumi.set(__self__, "which_broker_when_consume_slow", which_broker_when_consume_slow)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of a consumer group.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="consumeBroadcastEnable")
    def consume_broadcast_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable broadcast.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_broadcast_enable")

    @consume_broadcast_enable.setter
    def consume_broadcast_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "consume_broadcast_enable", value)

    @_builtins.property
    @pulumi.getter(name="consumeEnable")
    def consume_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable consumption.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_enable")

    @consume_enable.setter
    def consume_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "consume_enable", value)

    @_builtins.property
    @pulumi.getter(name="consumeFromMinEnable")
    def consume_from_min_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable consumption from the earliest
        offset. Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_from_min_enable")

    @consume_from_min_enable.setter
    def consume_from_min_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "consume_from_min_enable", value)

    @_builtins.property
    @pulumi.getter(name="notifyConsumeridsChangedEnable")
    def notify_consumerids_changed_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to notify changes of consumer IDs.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "notify_consumerids_changed_enable")

    @notify_consumerids_changed_enable.setter
    def notify_consumerids_changed_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_consumerids_changed_enable", value)

    @_builtins.property
    @pulumi.getter(name="retryMaxTimes")
    def retry_max_times(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum number of consumption retries.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "retry_max_times")

    @retry_max_times.setter
    def retry_max_times(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retry_max_times", value)

    @_builtins.property
    @pulumi.getter(name="retryQueueNum")
    def retry_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of retry queues.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "retry_queue_num")

    @retry_queue_num.setter
    def retry_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retry_queue_num", value)

    @_builtins.property
    @pulumi.getter(name="whichBrokerWhenConsumeSlow")
    def which_broker_when_consume_slow(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the ID of the broker selected for slow
        consumption. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_vhosts"></a>
        The `vhosts` block supports:
        """
        return pulumi.get(self, "which_broker_when_consume_slow")

    @which_broker_when_consume_slow.setter
    def which_broker_when_consume_slow(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "which_broker_when_consume_slow", value)


if not MYPY:
    class DmsRocketmqMigrationTaskTopicConfigArgsDict(TypedDict):
        topic_name: pulumi.Input[_builtins.str]
        """
        Specifies the topic name. Changing this creates a new resource.
        """
        order: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether a message is an ordered message.
        Changing this creates a new resource.
        """
        perm: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of permission. Changing this creates a new resource.
        """
        read_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of read queues.
        Changing this creates a new resource.
        """
        topic_filter_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the filter type of a topic.
        Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
        """
        topic_sys_flag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the system flag of a topic.
        Changing this creates a new resource.
        """
        write_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of write queues.
        Changing this creates a new resource.

        <a name="RocketMQ_migration_task_subscription_groups"></a>
        The `subscription_groups` block supports:
        """
elif False:
    DmsRocketmqMigrationTaskTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqMigrationTaskTopicConfigArgs:
    def __init__(__self__, *,
                 topic_name: pulumi.Input[_builtins.str],
                 order: Optional[pulumi.Input[_builtins.bool]] = None,
                 perm: Optional[pulumi.Input[_builtins.int]] = None,
                 read_queue_num: Optional[pulumi.Input[_builtins.int]] = None,
                 topic_filter_type: Optional[pulumi.Input[_builtins.str]] = None,
                 topic_sys_flag: Optional[pulumi.Input[_builtins.int]] = None,
                 write_queue_num: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] topic_name: Specifies the topic name. Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] order: Specifies whether a message is an ordered message.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] perm: Specifies the number of permission. Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] read_queue_num: Specifies the number of read queues.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] topic_filter_type: Specifies the filter type of a topic.
               Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] topic_sys_flag: Specifies the system flag of a topic.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] write_queue_num: Specifies the number of write queues.
               Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_subscription_groups"></a>
               The `subscription_groups` block supports:
        """
        pulumi.set(__self__, "topic_name", topic_name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)
        if read_queue_num is not None:
            pulumi.set(__self__, "read_queue_num", read_queue_num)
        if topic_filter_type is not None:
            pulumi.set(__self__, "topic_filter_type", topic_filter_type)
        if topic_sys_flag is not None:
            pulumi.set(__self__, "topic_sys_flag", topic_sys_flag)
        if write_queue_num is not None:
            pulumi.set(__self__, "write_queue_num", write_queue_num)

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic name. Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_name", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether a message is an ordered message.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of permission. Changing this creates a new resource.
        """
        return pulumi.get(self, "perm")

    @perm.setter
    def perm(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "perm", value)

    @_builtins.property
    @pulumi.getter(name="readQueueNum")
    def read_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of read queues.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "read_queue_num")

    @read_queue_num.setter
    def read_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_queue_num", value)

    @_builtins.property
    @pulumi.getter(name="topicFilterType")
    def topic_filter_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the filter type of a topic.
        Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_filter_type")

    @topic_filter_type.setter
    def topic_filter_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic_filter_type", value)

    @_builtins.property
    @pulumi.getter(name="topicSysFlag")
    def topic_sys_flag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the system flag of a topic.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_sys_flag")

    @topic_sys_flag.setter
    def topic_sys_flag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "topic_sys_flag", value)

    @_builtins.property
    @pulumi.getter(name="writeQueueNum")
    def write_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of write queues.
        Changing this creates a new resource.

        <a name="RocketMQ_migration_task_subscription_groups"></a>
        The `subscription_groups` block supports:
        """
        return pulumi.get(self, "write_queue_num")

    @write_queue_num.setter
    def write_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "write_queue_num", value)


if not MYPY:
    class DmsRocketmqMigrationTaskVhostArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the switch name. Changing this creates a new resource.
        """
elif False:
    DmsRocketmqMigrationTaskVhostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqMigrationTaskVhostArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the switch name. Changing this creates a new resource.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DmsRocketmqTopicBrokerArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the broker.

        <a name="DmsRocketMQTopic_QueueRef"></a>
        The `queues` block supports:
        """
        read_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
        write_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
elif False:
    DmsRocketmqTopicBrokerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqTopicBrokerArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 read_queue_num: Optional[pulumi.Input[_builtins.int]] = None,
                 write_queue_num: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the broker.
               
               <a name="DmsRocketMQTopic_QueueRef"></a>
               The `queues` block supports:
        :param pulumi.Input[_builtins.int] read_queue_num: Indicates the read queues number of the broker. It's useless when create a topic.
        :param pulumi.Input[_builtins.int] write_queue_num: Indicates the read queues number of the broker. It's useless when create a topic.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_queue_num is not None:
            pulumi.set(__self__, "read_queue_num", read_queue_num)
        if write_queue_num is not None:
            pulumi.set(__self__, "write_queue_num", write_queue_num)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the broker.

        <a name="DmsRocketMQTopic_QueueRef"></a>
        The `queues` block supports:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="readQueueNum")
    def read_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
        return pulumi.get(self, "read_queue_num")

    @read_queue_num.setter
    def read_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_queue_num", value)

    @_builtins.property
    @pulumi.getter(name="writeQueueNum")
    def write_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
        return pulumi.get(self, "write_queue_num")

    @write_queue_num.setter
    def write_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "write_queue_num", value)


if not MYPY:
    class DmsRocketmqTopicQueueArgsDict(TypedDict):
        broker: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the associated broker.
        """
        queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of the queues.
        """
elif False:
    DmsRocketmqTopicQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqTopicQueueArgs:
    def __init__(__self__, *,
                 broker: Optional[pulumi.Input[_builtins.str]] = None,
                 queue_num: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] broker: Specifies the associated broker.
        :param pulumi.Input[_builtins.int] queue_num: Specifies the number of the queues.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if queue_num is not None:
            pulumi.set(__self__, "queue_num", queue_num)

    @_builtins.property
    @pulumi.getter
    def broker(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the associated broker.
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "broker", value)

    @_builtins.property
    @pulumi.getter(name="queueNum")
    def queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of the queues.
        """
        return pulumi.get(self, "queue_num")

    @queue_num.setter
    def queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "queue_num", value)


if not MYPY:
    class DmsRocketmqUserGroupPermArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the name of a topic or consumer group.
        """
        perm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
elif False:
    DmsRocketmqUserGroupPermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqUserGroupPermArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 perm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Indicates the name of a topic or consumer group.
        :param pulumi.Input[_builtins.str] perm: Indicates the permissions of the topic or consumer group.
               Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the name of a topic or consumer group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        return pulumi.get(self, "perm")

    @perm.setter
    def perm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "perm", value)


if not MYPY:
    class DmsRocketmqUserTopicPermArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the name of a topic or consumer group.
        """
        perm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
elif False:
    DmsRocketmqUserTopicPermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsRocketmqUserTopicPermArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 perm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Indicates the name of a topic or consumer group.
        :param pulumi.Input[_builtins.str] perm: Indicates the permissions of the topic or consumer group.
               Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the name of a topic or consumer group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        return pulumi.get(self, "perm")

    @perm.setter
    def perm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "perm", value)


if not MYPY:
    class ElbIpgroupIpListArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        IP address or CIDR block.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description for the ip.
        """
elif False:
    ElbIpgroupIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbIpgroupIpListArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: IP address or CIDR block.
        :param pulumi.Input[_builtins.str] description: Human-readable description for the ip.
        """
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        IP address or CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description for the ip.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigArgsDict(TypedDict):
        status_code: pulumi.Input[_builtins.str]
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        insert_headers_config: NotRequired[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigArgsDict']]
        message_body: NotRequired[pulumi.Input[_builtins.str]]
        remove_headers_config: NotRequired[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigArgsDict']]
        traffic_limit_config: NotRequired[pulumi.Input['ElbL7policyFixedResponseConfigTrafficLimitConfigArgsDict']]
elif False:
    ElbL7policyFixedResponseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[_builtins.str],
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 insert_headers_config: Optional[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigArgs']] = None,
                 message_body: Optional[pulumi.Input[_builtins.str]] = None,
                 remove_headers_config: Optional[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs']] = None,
                 traffic_limit_config: Optional[pulumi.Input['ElbL7policyFixedResponseConfigTrafficLimitConfigArgs']] = None):
        pulumi.set(__self__, "status_code", status_code)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if insert_headers_config is not None:
            pulumi.set(__self__, "insert_headers_config", insert_headers_config)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if remove_headers_config is not None:
            pulumi.set(__self__, "remove_headers_config", remove_headers_config)
        if traffic_limit_config is not None:
            pulumi.set(__self__, "traffic_limit_config", traffic_limit_config)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="insertHeadersConfig")
    def insert_headers_config(self) -> Optional[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigArgs']]:
        return pulumi.get(self, "insert_headers_config")

    @insert_headers_config.setter
    def insert_headers_config(self, value: Optional[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigArgs']]):
        pulumi.set(self, "insert_headers_config", value)

    @_builtins.property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message_body")

    @message_body.setter
    def message_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_body", value)

    @_builtins.property
    @pulumi.getter(name="removeHeadersConfig")
    def remove_headers_config(self) -> Optional[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs']]:
        return pulumi.get(self, "remove_headers_config")

    @remove_headers_config.setter
    def remove_headers_config(self, value: Optional[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs']]):
        pulumi.set(self, "remove_headers_config", value)

    @_builtins.property
    @pulumi.getter(name="trafficLimitConfig")
    def traffic_limit_config(self) -> Optional[pulumi.Input['ElbL7policyFixedResponseConfigTrafficLimitConfigArgs']]:
        return pulumi.get(self, "traffic_limit_config")

    @traffic_limit_config.setter
    def traffic_limit_config(self, value: Optional[pulumi.Input['ElbL7policyFixedResponseConfigTrafficLimitConfigArgs']]):
        pulumi.set(self, "traffic_limit_config", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigInsertHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyFixedResponseConfigInsertHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigInsertHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        value_type: pulumi.Input[_builtins.str]
elif False:
    ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 value_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigRemoveHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyFixedResponseConfigRemoveHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
elif False:
    ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigTrafficLimitConfigArgsDict(TypedDict):
        burst: NotRequired[pulumi.Input[_builtins.int]]
        per_source_ip_qps: NotRequired[pulumi.Input[_builtins.int]]
        qps: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ElbL7policyFixedResponseConfigTrafficLimitConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigTrafficLimitConfigArgs:
    def __init__(__self__, *,
                 burst: Optional[pulumi.Input[_builtins.int]] = None,
                 per_source_ip_qps: Optional[pulumi.Input[_builtins.int]] = None,
                 qps: Optional[pulumi.Input[_builtins.int]] = None):
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if per_source_ip_qps is not None:
            pulumi.set(__self__, "per_source_ip_qps", per_source_ip_qps)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter
    def burst(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "burst")

    @burst.setter
    def burst(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "burst", value)

    @_builtins.property
    @pulumi.getter(name="perSourceIpQps")
    def per_source_ip_qps(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "per_source_ip_qps")

    @per_source_ip_qps.setter
    def per_source_ip_qps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "per_source_ip_qps", value)

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "qps")

    @qps.setter
    def qps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "qps", value)


if not MYPY:
    class ElbL7policyRedirectPoolsConfigArgsDict(TypedDict):
        pool_id: pulumi.Input[_builtins.str]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ElbL7policyRedirectPoolsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsConfigArgs:
    def __init__(__self__, *,
                 pool_id: pulumi.Input[_builtins.str],
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "pool_id", pool_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pool_id", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigArgsDict(TypedDict):
        insert_headers_config: NotRequired[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgsDict']]
        remove_headers_config: NotRequired[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgsDict']]
        rewrite_url_config: NotRequired[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgsDict']]
        rewrite_url_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        traffic_limit_config: NotRequired[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgsDict']]
elif False:
    ElbL7policyRedirectPoolsExtendConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigArgs:
    def __init__(__self__, *,
                 insert_headers_config: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs']] = None,
                 remove_headers_config: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs']] = None,
                 rewrite_url_config: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs']] = None,
                 rewrite_url_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 traffic_limit_config: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs']] = None):
        if insert_headers_config is not None:
            pulumi.set(__self__, "insert_headers_config", insert_headers_config)
        if remove_headers_config is not None:
            pulumi.set(__self__, "remove_headers_config", remove_headers_config)
        if rewrite_url_config is not None:
            pulumi.set(__self__, "rewrite_url_config", rewrite_url_config)
        if rewrite_url_enabled is not None:
            pulumi.set(__self__, "rewrite_url_enabled", rewrite_url_enabled)
        if traffic_limit_config is not None:
            pulumi.set(__self__, "traffic_limit_config", traffic_limit_config)

    @_builtins.property
    @pulumi.getter(name="insertHeadersConfig")
    def insert_headers_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs']]:
        return pulumi.get(self, "insert_headers_config")

    @insert_headers_config.setter
    def insert_headers_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs']]):
        pulumi.set(self, "insert_headers_config", value)

    @_builtins.property
    @pulumi.getter(name="removeHeadersConfig")
    def remove_headers_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs']]:
        return pulumi.get(self, "remove_headers_config")

    @remove_headers_config.setter
    def remove_headers_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs']]):
        pulumi.set(self, "remove_headers_config", value)

    @_builtins.property
    @pulumi.getter(name="rewriteUrlConfig")
    def rewrite_url_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs']]:
        return pulumi.get(self, "rewrite_url_config")

    @rewrite_url_config.setter
    def rewrite_url_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs']]):
        pulumi.set(self, "rewrite_url_config", value)

    @_builtins.property
    @pulumi.getter(name="rewriteUrlEnabled")
    def rewrite_url_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "rewrite_url_enabled")

    @rewrite_url_enabled.setter
    def rewrite_url_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "rewrite_url_enabled", value)

    @_builtins.property
    @pulumi.getter(name="trafficLimitConfig")
    def traffic_limit_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs']]:
        return pulumi.get(self, "traffic_limit_config")

    @traffic_limit_config.setter
    def traffic_limit_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs']]):
        pulumi.set(self, "traffic_limit_config", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        value_type: pulumi.Input[_builtins.str]
elif False:
    ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 value_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
elif False:
    ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        path: NotRequired[pulumi.Input[_builtins.str]]
        query: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgsDict(TypedDict):
        burst: NotRequired[pulumi.Input[_builtins.int]]
        per_source_ip_qps: NotRequired[pulumi.Input[_builtins.int]]
        qps: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs:
    def __init__(__self__, *,
                 burst: Optional[pulumi.Input[_builtins.int]] = None,
                 per_source_ip_qps: Optional[pulumi.Input[_builtins.int]] = None,
                 qps: Optional[pulumi.Input[_builtins.int]] = None):
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if per_source_ip_qps is not None:
            pulumi.set(__self__, "per_source_ip_qps", per_source_ip_qps)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter
    def burst(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "burst")

    @burst.setter
    def burst(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "burst", value)

    @_builtins.property
    @pulumi.getter(name="perSourceIpQps")
    def per_source_ip_qps(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "per_source_ip_qps")

    @per_source_ip_qps.setter
    def per_source_ip_qps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "per_source_ip_qps", value)

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "qps")

    @qps.setter
    def qps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "qps", value)


if not MYPY:
    class ElbL7policyRedirectPoolsStickySessionConfigArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ElbL7policyRedirectPoolsStickySessionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsStickySessionConfigArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigArgsDict(TypedDict):
        status_code: pulumi.Input[_builtins.str]
        host: NotRequired[pulumi.Input[_builtins.str]]
        insert_headers_config: NotRequired[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigArgsDict']]
        path: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.str]]
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        query: NotRequired[pulumi.Input[_builtins.str]]
        remove_headers_config: NotRequired[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgsDict']]
elif False:
    ElbL7policyRedirectUrlConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[_builtins.str],
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 insert_headers_config: Optional[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs']] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None,
                 remove_headers_config: Optional[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs']] = None):
        pulumi.set(__self__, "status_code", status_code)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if insert_headers_config is not None:
            pulumi.set(__self__, "insert_headers_config", insert_headers_config)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if remove_headers_config is not None:
            pulumi.set(__self__, "remove_headers_config", remove_headers_config)

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status_code", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="insertHeadersConfig")
    def insert_headers_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs']]:
        return pulumi.get(self, "insert_headers_config")

    @insert_headers_config.setter
    def insert_headers_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs']]):
        pulumi.set(self, "insert_headers_config", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter(name="removeHeadersConfig")
    def remove_headers_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs']]:
        return pulumi.get(self, "remove_headers_config")

    @remove_headers_config.setter
    def remove_headers_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs']]):
        pulumi.set(self, "remove_headers_config", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigInsertHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyRedirectUrlConfigInsertHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        value_type: pulumi.Input[_builtins.str]
elif False:
    ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 value_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
elif False:
    ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ElbL7ruleConditionArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
        """
        The value to use for the comparison.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ElbL7ruleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7ruleConditionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str],
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] value: The value to use for the comparison.
        """
        pulumi.set(__self__, "value", value)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to use for the comparison.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ElbListenerPortRangeArgsDict(TypedDict):
        end_port: pulumi.Input[_builtins.int]
        start_port: pulumi.Input[_builtins.int]
elif False:
    ElbListenerPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbListenerPortRangeArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[_builtins.int],
                 start_port: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @_builtins.property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "end_port", value)

    @_builtins.property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class ElbMemberReasonArgsDict(TypedDict):
        expected_response: NotRequired[pulumi.Input[_builtins.str]]
        healthcheck_response: NotRequired[pulumi.Input[_builtins.str]]
        reason_code: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ElbMemberReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbMemberReasonArgs:
    def __init__(__self__, *,
                 expected_response: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_response: Optional[pulumi.Input[_builtins.str]] = None,
                 reason_code: Optional[pulumi.Input[_builtins.str]] = None):
        if expected_response is not None:
            pulumi.set(__self__, "expected_response", expected_response)
        if healthcheck_response is not None:
            pulumi.set(__self__, "healthcheck_response", healthcheck_response)
        if reason_code is not None:
            pulumi.set(__self__, "reason_code", reason_code)

    @_builtins.property
    @pulumi.getter(name="expectedResponse")
    def expected_response(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expected_response")

    @expected_response.setter
    def expected_response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expected_response", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckResponse")
    def healthcheck_response(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "healthcheck_response")

    @healthcheck_response.setter
    def healthcheck_response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_response", value)

    @_builtins.property
    @pulumi.getter(name="reasonCode")
    def reason_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "reason_code")

    @reason_code.setter
    def reason_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason_code", value)


if not MYPY:
    class ElbMemberStatusArgsDict(TypedDict):
        listener_id: NotRequired[pulumi.Input[_builtins.str]]
        operating_status: NotRequired[pulumi.Input[_builtins.str]]
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElbMemberStatusReasonArgsDict']]]]
elif False:
    ElbMemberStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbMemberStatusArgs:
    def __init__(__self__, *,
                 listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 operating_status: Optional[pulumi.Input[_builtins.str]] = None,
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input['ElbMemberStatusReasonArgs']]]] = None):
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if operating_status is not None:
            pulumi.set(__self__, "operating_status", operating_status)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_id", value)

    @_builtins.property
    @pulumi.getter(name="operatingStatus")
    def operating_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operating_status")

    @operating_status.setter
    def operating_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operating_status", value)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElbMemberStatusReasonArgs']]]]:
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElbMemberStatusReasonArgs']]]]):
        pulumi.set(self, "reasons", value)


if not MYPY:
    class ElbMemberStatusReasonArgsDict(TypedDict):
        expected_response: NotRequired[pulumi.Input[_builtins.str]]
        healthcheck_response: NotRequired[pulumi.Input[_builtins.str]]
        reason_code: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ElbMemberStatusReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbMemberStatusReasonArgs:
    def __init__(__self__, *,
                 expected_response: Optional[pulumi.Input[_builtins.str]] = None,
                 healthcheck_response: Optional[pulumi.Input[_builtins.str]] = None,
                 reason_code: Optional[pulumi.Input[_builtins.str]] = None):
        if expected_response is not None:
            pulumi.set(__self__, "expected_response", expected_response)
        if healthcheck_response is not None:
            pulumi.set(__self__, "healthcheck_response", healthcheck_response)
        if reason_code is not None:
            pulumi.set(__self__, "reason_code", reason_code)

    @_builtins.property
    @pulumi.getter(name="expectedResponse")
    def expected_response(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expected_response")

    @expected_response.setter
    def expected_response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expected_response", value)

    @_builtins.property
    @pulumi.getter(name="healthcheckResponse")
    def healthcheck_response(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "healthcheck_response")

    @healthcheck_response.setter
    def healthcheck_response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck_response", value)

    @_builtins.property
    @pulumi.getter(name="reasonCode")
    def reason_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "reason_code")

    @reason_code.setter
    def reason_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason_code", value)


if not MYPY:
    class ElbPoolPersistenceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of persistence mode. The current specification supports SOURCE_IP,
        HTTP_COOKIE, and APP_COOKIE.
        """
        cookie_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the cookie if persistence mode is set appropriately. Required
        if `type = APP_COOKIE`.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the sticky session timeout duration in minutes. This parameter is
        invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
        + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
        + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
        """
elif False:
    ElbPoolPersistenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbPoolPersistenceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 cookie_name: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of persistence mode. The current specification supports SOURCE_IP,
               HTTP_COOKIE, and APP_COOKIE.
        :param pulumi.Input[_builtins.str] cookie_name: The name of the cookie if persistence mode is set appropriately. Required
               if `type = APP_COOKIE`.
        :param pulumi.Input[_builtins.int] timeout: Specifies the sticky session timeout duration in minutes. This parameter is
               invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
               + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
               + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
        """
        pulumi.set(__self__, "type", type)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of persistence mode. The current specification supports SOURCE_IP,
        HTTP_COOKIE, and APP_COOKIE.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the cookie if persistence mode is set appropriately. Required
        if `type = APP_COOKIE`.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the sticky session timeout duration in minutes. This parameter is
        invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
        + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
        + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ElbSecurityPolicyListenerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The listener id.
        """
elif False:
    ElbSecurityPolicyListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSecurityPolicyListenerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The listener id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The listener id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class FgsApplicationRepositoryArgsDict(TypedDict):
        https_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP address of the repository.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project ID of the repository.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository status.
        """
        web_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository link.
        """
elif False:
    FgsApplicationRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsApplicationRepositoryArgs:
    def __init__(__self__, *,
                 https_url: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 web_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] https_url: The HTTP address of the repository.
        :param pulumi.Input[_builtins.str] project_id: The project ID of the repository.
        :param pulumi.Input[_builtins.str] status: The repository status.
        :param pulumi.Input[_builtins.str] web_url: The repository link.
        """
        if https_url is not None:
            pulumi.set(__self__, "https_url", https_url)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="httpsUrl")
    def https_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP address of the repository.
        """
        return pulumi.get(self, "https_url")

    @https_url.setter
    def https_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "https_url", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project ID of the repository.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository link.
        """
        return pulumi.get(self, "web_url")

    @web_url.setter
    def web_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_url", value)


if not MYPY:
    class FgsApplicationStackResourceArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud service name.
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hyperlink.
        """
        logical_resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The logical resource name.
        """
        logical_resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The logical resource type.
        """
        physical_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The physical resource ID.
        """
        physical_resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The physical resource name.
        """
        resource_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of resource.
        """
        status_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status information.
        """
elif False:
    FgsApplicationStackResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsApplicationStackResourceArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 logical_resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 logical_resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 physical_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 physical_resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_status: Optional[pulumi.Input[_builtins.str]] = None,
                 status_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: The cloud service name.
        :param pulumi.Input[_builtins.str] href: The hyperlink.
        :param pulumi.Input[_builtins.str] logical_resource_name: The logical resource name.
        :param pulumi.Input[_builtins.str] logical_resource_type: The logical resource type.
        :param pulumi.Input[_builtins.str] physical_resource_id: The physical resource ID.
        :param pulumi.Input[_builtins.str] physical_resource_name: The physical resource name.
        :param pulumi.Input[_builtins.str] resource_status: The status of resource.
        :param pulumi.Input[_builtins.str] status_message: The status information.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if logical_resource_name is not None:
            pulumi.set(__self__, "logical_resource_name", logical_resource_name)
        if logical_resource_type is not None:
            pulumi.set(__self__, "logical_resource_type", logical_resource_type)
        if physical_resource_id is not None:
            pulumi.set(__self__, "physical_resource_id", physical_resource_id)
        if physical_resource_name is not None:
            pulumi.set(__self__, "physical_resource_name", physical_resource_name)
        if resource_status is not None:
            pulumi.set(__self__, "resource_status", resource_status)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud service name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hyperlink.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter(name="logicalResourceName")
    def logical_resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The logical resource name.
        """
        return pulumi.get(self, "logical_resource_name")

    @logical_resource_name.setter
    def logical_resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logical_resource_name", value)

    @_builtins.property
    @pulumi.getter(name="logicalResourceType")
    def logical_resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The logical resource type.
        """
        return pulumi.get(self, "logical_resource_type")

    @logical_resource_type.setter
    def logical_resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logical_resource_type", value)

    @_builtins.property
    @pulumi.getter(name="physicalResourceId")
    def physical_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The physical resource ID.
        """
        return pulumi.get(self, "physical_resource_id")

    @physical_resource_id.setter
    def physical_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "physical_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="physicalResourceName")
    def physical_resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The physical resource name.
        """
        return pulumi.get(self, "physical_resource_name")

    @physical_resource_name.setter
    def physical_resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "physical_resource_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceStatus")
    def resource_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of resource.
        """
        return pulumi.get(self, "resource_status")

    @resource_status.setter
    def resource_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_status", value)

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status information.
        """
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status_message", value)


if not MYPY:
    class FgsAsyncInvokeConfigurationOnFailureArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        Specifies the object type.  
        The valid values are as follows:
        + **OBS**
        + **SMN**
        + **DIS**
        + **FunctionGraph**
        """
        param: pulumi.Input[_builtins.str]
        """
        Specifies the parameters (map object in JSON format) corresponding to the target service.
        + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
        expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
        + The **SMN** objects include: `topic_urn`.
        + The **DIS** objects include: `stream_name`.
        + The **FunctionGraph** objects include: `func_urn` (function URN).

        > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
        corresponding service.
        """
elif False:
    FgsAsyncInvokeConfigurationOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsAsyncInvokeConfigurationOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 param: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the object type.  
               The valid values are as follows:
               + **OBS**
               + **SMN**
               + **DIS**
               + **FunctionGraph**
        :param pulumi.Input[_builtins.str] param: Specifies the parameters (map object in JSON format) corresponding to the target service.
               + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
               expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
               + The **SMN** objects include: `topic_urn`.
               + The **DIS** objects include: `stream_name`.
               + The **FunctionGraph** objects include: `func_urn` (function URN).
               
               > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
               corresponding service.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "param", param)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object type.  
        The valid values are as follows:
        + **OBS**
        + **SMN**
        + **DIS**
        + **FunctionGraph**
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def param(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameters (map object in JSON format) corresponding to the target service.
        + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
        expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
        + The **SMN** objects include: `topic_urn`.
        + The **DIS** objects include: `stream_name`.
        + The **FunctionGraph** objects include: `func_urn` (function URN).

        > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
        corresponding service.
        """
        return pulumi.get(self, "param")

    @param.setter
    def param(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param", value)


if not MYPY:
    class FgsAsyncInvokeConfigurationOnSuccessArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        Specifies the object type.  
        The valid values are as follows:
        + **OBS**
        + **SMN**
        + **DIS**
        + **FunctionGraph**
        """
        param: pulumi.Input[_builtins.str]
        """
        Specifies the parameters (map object in JSON format) corresponding to the target service.
        + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
        expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
        + The **SMN** objects include: `topic_urn`.
        + The **DIS** objects include: `stream_name`.
        + The **FunctionGraph** objects include: `func_urn` (function URN).

        > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
        corresponding service.
        """
elif False:
    FgsAsyncInvokeConfigurationOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsAsyncInvokeConfigurationOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 param: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the object type.  
               The valid values are as follows:
               + **OBS**
               + **SMN**
               + **DIS**
               + **FunctionGraph**
        :param pulumi.Input[_builtins.str] param: Specifies the parameters (map object in JSON format) corresponding to the target service.
               + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
               expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
               + The **SMN** objects include: `topic_urn`.
               + The **DIS** objects include: `stream_name`.
               + The **FunctionGraph** objects include: `func_urn` (function URN).
               
               > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
               corresponding service.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "param", param)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object type.  
        The valid values are as follows:
        + **OBS**
        + **SMN**
        + **DIS**
        + **FunctionGraph**
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def param(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameters (map object in JSON format) corresponding to the target service.
        + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
        expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
        + The **SMN** objects include: `topic_urn`.
        + The **DIS** objects include: `stream_name`.
        + The **FunctionGraph** objects include: `func_urn` (function URN).

        > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
        corresponding service.
        """
        return pulumi.get(self, "param")

    @param.setter
    def param(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param", value)


if not MYPY:
    class GesGraphEncryptionArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable data encryption The value can be true or false. The default value is false.
        """
        master_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the customer master key created by DEW in the project corresponding to the graph creation.
        """
elif False:
    GesGraphEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GesGraphEncryptionArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 master_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Whether to enable data encryption The value can be true or false. The default value is false.
        :param pulumi.Input[_builtins.str] master_key_id: ID of the customer master key created by DEW in the project corresponding to the graph creation.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if master_key_id is not None:
            pulumi.set(__self__, "master_key_id", master_key_id)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable data encryption The value can be true or false. The default value is false.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="masterKeyId")
    def master_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the customer master key created by DEW in the project corresponding to the graph creation.
        """
        return pulumi.get(self, "master_key_id")

    @master_key_id.setter
    def master_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_key_id", value)


if not MYPY:
    class GesGraphLtsOperationTraceArgsDict(TypedDict):
        audit_log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        LTS log group name.
        """
        enable_audit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable graph audit. The default value is false.
        """
elif False:
    GesGraphLtsOperationTraceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GesGraphLtsOperationTraceArgs:
    def __init__(__self__, *,
                 audit_log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_audit: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_log_group_name: LTS log group name.
        :param pulumi.Input[_builtins.bool] enable_audit: Whether to enable graph audit. The default value is false.
        """
        if audit_log_group_name is not None:
            pulumi.set(__self__, "audit_log_group_name", audit_log_group_name)
        if enable_audit is not None:
            pulumi.set(__self__, "enable_audit", enable_audit)

    @_builtins.property
    @pulumi.getter(name="auditLogGroupName")
    def audit_log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        LTS log group name.
        """
        return pulumi.get(self, "audit_log_group_name")

    @audit_log_group_name.setter
    def audit_log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="enableAudit")
    def enable_audit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable graph audit. The default value is false.
        """
        return pulumi.get(self, "enable_audit")

    @enable_audit.setter
    def enable_audit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_audit", value)


if not MYPY:
    class GesGraphPublicIpArgsDict(TypedDict):
        eip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the ID of an EIP.  Changing this parameter will create a new resource.
        """
        public_bind_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind type of public IP.
        """
elif False:
    GesGraphPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GesGraphPublicIpArgs:
    def __init__(__self__, *,
                 eip_id: Optional[pulumi.Input[_builtins.str]] = None,
                 public_bind_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] eip_id: Indicates the ID of an EIP.  Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] public_bind_type: The bind type of public IP.
        """
        if eip_id is not None:
            pulumi.set(__self__, "eip_id", eip_id)
        if public_bind_type is not None:
            pulumi.set(__self__, "public_bind_type", public_bind_type)

    @_builtins.property
    @pulumi.getter(name="eipId")
    def eip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the ID of an EIP.  Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "eip_id")

    @eip_id.setter
    def eip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eip_id", value)

    @_builtins.property
    @pulumi.getter(name="publicBindType")
    def public_bind_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind type of public IP.
        """
        return pulumi.get(self, "public_bind_type")

    @public_bind_type.setter
    def public_bind_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_bind_type", value)


if not MYPY:
    class GesGraphVertexIdTypeArgsDict(TypedDict):
        id_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of ID.
        """
        id_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vertex ID type.
        """
elif False:
    GesGraphVertexIdTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GesGraphVertexIdTypeArgs:
    def __init__(__self__, *,
                 id_length: Optional[pulumi.Input[_builtins.int]] = None,
                 id_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id_length: The length of ID.
        :param pulumi.Input[_builtins.str] id_type: Vertex ID type.
        """
        if id_length is not None:
            pulumi.set(__self__, "id_length", id_length)
        if id_type is not None:
            pulumi.set(__self__, "id_type", id_type)

    @_builtins.property
    @pulumi.getter(name="idLength")
    def id_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of ID.
        """
        return pulumi.get(self, "id_length")

    @id_length.setter
    def id_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id_length", value)

    @_builtins.property
    @pulumi.getter(name="idType")
    def id_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vertex ID type.
        """
        return pulumi.get(self, "id_type")

    @id_type.setter
    def id_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id_type", value)


if not MYPY:
    class ObsBucketAclAccountPermissionArgsDict(TypedDict):
        account_id: pulumi.Input[_builtins.str]
        """
        Specifies the account id to authorize. The account id cannot be the bucket owner,
        and must be unique.
        """
        access_to_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        access_to_buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
elif False:
    ObsBucketAclAccountPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketAclAccountPermissionArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[_builtins.str],
                 access_to_acls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 access_to_buckets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] account_id: Specifies the account id to authorize. The account id cannot be the bucket owner,
               and must be unique.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_to_acls: Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_to_buckets: Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        pulumi.set(__self__, "account_id", account_id)
        if access_to_acls is not None:
            pulumi.set(__self__, "access_to_acls", access_to_acls)
        if access_to_buckets is not None:
            pulumi.set(__self__, "access_to_buckets", access_to_buckets)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the account id to authorize. The account id cannot be the bucket owner,
        and must be unique.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="accessToAcls")
    def access_to_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        return pulumi.get(self, "access_to_acls")

    @access_to_acls.setter
    def access_to_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_to_acls", value)

    @_builtins.property
    @pulumi.getter(name="accessToBuckets")
    def access_to_buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        return pulumi.get(self, "access_to_buckets")

    @access_to_buckets.setter
    def access_to_buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_to_buckets", value)


if not MYPY:
    class ObsBucketAclLogDeliveryUserPermissionArgsDict(TypedDict):
        access_to_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        access_to_buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
elif False:
    ObsBucketAclLogDeliveryUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketAclLogDeliveryUserPermissionArgs:
    def __init__(__self__, *,
                 access_to_acls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 access_to_buckets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_to_acls: Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_to_buckets: Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        if access_to_acls is not None:
            pulumi.set(__self__, "access_to_acls", access_to_acls)
        if access_to_buckets is not None:
            pulumi.set(__self__, "access_to_buckets", access_to_buckets)

    @_builtins.property
    @pulumi.getter(name="accessToAcls")
    def access_to_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        return pulumi.get(self, "access_to_acls")

    @access_to_acls.setter
    def access_to_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_to_acls", value)

    @_builtins.property
    @pulumi.getter(name="accessToBuckets")
    def access_to_buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        return pulumi.get(self, "access_to_buckets")

    @access_to_buckets.setter
    def access_to_buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_to_buckets", value)


if not MYPY:
    class ObsBucketAclOwnerPermissionArgsDict(TypedDict):
        access_to_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        access_to_buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
elif False:
    ObsBucketAclOwnerPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketAclOwnerPermissionArgs:
    def __init__(__self__, *,
                 access_to_acls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 access_to_buckets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_to_acls: Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_to_buckets: Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        if access_to_acls is not None:
            pulumi.set(__self__, "access_to_acls", access_to_acls)
        if access_to_buckets is not None:
            pulumi.set(__self__, "access_to_buckets", access_to_buckets)

    @_builtins.property
    @pulumi.getter(name="accessToAcls")
    def access_to_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        return pulumi.get(self, "access_to_acls")

    @access_to_acls.setter
    def access_to_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_to_acls", value)

    @_builtins.property
    @pulumi.getter(name="accessToBuckets")
    def access_to_buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        return pulumi.get(self, "access_to_buckets")

    @access_to_buckets.setter
    def access_to_buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_to_buckets", value)


if not MYPY:
    class ObsBucketAclPublicPermissionArgsDict(TypedDict):
        access_to_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        access_to_buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
elif False:
    ObsBucketAclPublicPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketAclPublicPermissionArgs:
    def __init__(__self__, *,
                 access_to_acls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 access_to_buckets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_to_acls: Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_to_buckets: Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        if access_to_acls is not None:
            pulumi.set(__self__, "access_to_acls", access_to_acls)
        if access_to_buckets is not None:
            pulumi.set(__self__, "access_to_buckets", access_to_buckets)

    @_builtins.property
    @pulumi.getter(name="accessToAcls")
    def access_to_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        return pulumi.get(self, "access_to_acls")

    @access_to_acls.setter
    def access_to_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_to_acls", value)

    @_builtins.property
    @pulumi.getter(name="accessToBuckets")
    def access_to_buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        return pulumi.get(self, "access_to_buckets")

    @access_to_buckets.setter
    def access_to_buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_to_buckets", value)


if not MYPY:
    class ProviderAssumeRoleArgsDict(TypedDict):
        agency_name: pulumi.Input[_builtins.str]
        domain_name: pulumi.Input[_builtins.str]
elif False:
    ProviderAssumeRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderAssumeRoleArgs:
    def __init__(__self__, *,
                 agency_name: pulumi.Input[_builtins.str],
                 domain_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "agency_name", agency_name)
        pulumi.set(__self__, "domain_name", domain_name)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agency_name", value)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)


if not MYPY:
    class SfsTurboDuTaskDirUsageArgsDict(TypedDict):
        file_counts: NotRequired[pulumi.Input[Sequence[pulumi.Input['SfsTurboDuTaskDirUsageFileCountArgsDict']]]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        path: NotRequired[pulumi.Input[_builtins.str]]
        used_capacity: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    SfsTurboDuTaskDirUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboDuTaskDirUsageArgs:
    def __init__(__self__, *,
                 file_counts: Optional[pulumi.Input[Sequence[pulumi.Input['SfsTurboDuTaskDirUsageFileCountArgs']]]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 used_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        if file_counts is not None:
            pulumi.set(__self__, "file_counts", file_counts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if used_capacity is not None:
            pulumi.set(__self__, "used_capacity", used_capacity)

    @_builtins.property
    @pulumi.getter(name="fileCounts")
    def file_counts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SfsTurboDuTaskDirUsageFileCountArgs']]]]:
        return pulumi.get(self, "file_counts")

    @file_counts.setter
    def file_counts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SfsTurboDuTaskDirUsageFileCountArgs']]]]):
        pulumi.set(self, "file_counts", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="usedCapacity")
    def used_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "used_capacity")

    @used_capacity.setter
    def used_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "used_capacity", value)


if not MYPY:
    class SfsTurboDuTaskDirUsageFileCountArgsDict(TypedDict):
        block: NotRequired[pulumi.Input[_builtins.int]]
        char: NotRequired[pulumi.Input[_builtins.int]]
        dir: NotRequired[pulumi.Input[_builtins.int]]
        pipe: NotRequired[pulumi.Input[_builtins.int]]
        regular: NotRequired[pulumi.Input[_builtins.int]]
        socket: NotRequired[pulumi.Input[_builtins.int]]
        symlink: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    SfsTurboDuTaskDirUsageFileCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboDuTaskDirUsageFileCountArgs:
    def __init__(__self__, *,
                 block: Optional[pulumi.Input[_builtins.int]] = None,
                 char: Optional[pulumi.Input[_builtins.int]] = None,
                 dir: Optional[pulumi.Input[_builtins.int]] = None,
                 pipe: Optional[pulumi.Input[_builtins.int]] = None,
                 regular: Optional[pulumi.Input[_builtins.int]] = None,
                 socket: Optional[pulumi.Input[_builtins.int]] = None,
                 symlink: Optional[pulumi.Input[_builtins.int]] = None):
        if block is not None:
            pulumi.set(__self__, "block", block)
        if char is not None:
            pulumi.set(__self__, "char", char)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if regular is not None:
            pulumi.set(__self__, "regular", regular)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if symlink is not None:
            pulumi.set(__self__, "symlink", symlink)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def char(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "char")

    @char.setter
    def char(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "char", value)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "dir")

    @dir.setter
    def dir(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dir", value)

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "pipe")

    @pipe.setter
    def pipe(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pipe", value)

    @_builtins.property
    @pulumi.getter
    def regular(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "regular")

    @regular.setter
    def regular(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "regular", value)

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "socket")

    @socket.setter
    def socket(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "socket", value)

    @_builtins.property
    @pulumi.getter
    def symlink(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "symlink")

    @symlink.setter
    def symlink(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "symlink", value)


if not MYPY:
    class SfsTurboObsTargetObsArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        endpoint: pulumi.Input[_builtins.str]
        attributes: NotRequired[pulumi.Input['SfsTurboObsTargetObsAttributesArgsDict']]
        policy: NotRequired[pulumi.Input['SfsTurboObsTargetObsPolicyArgsDict']]
elif False:
    SfsTurboObsTargetObsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboObsTargetObsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 attributes: Optional[pulumi.Input['SfsTurboObsTargetObsAttributesArgs']] = None,
                 policy: Optional[pulumi.Input['SfsTurboObsTargetObsPolicyArgs']] = None):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "endpoint", endpoint)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input['SfsTurboObsTargetObsAttributesArgs']]:
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input['SfsTurboObsTargetObsAttributesArgs']]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['SfsTurboObsTargetObsPolicyArgs']]:
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['SfsTurboObsTargetObsPolicyArgs']]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class SfsTurboObsTargetObsAttributesArgsDict(TypedDict):
        dir_mode: NotRequired[pulumi.Input[_builtins.str]]
        file_mode: NotRequired[pulumi.Input[_builtins.str]]
        gid: NotRequired[pulumi.Input[_builtins.int]]
        uid: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    SfsTurboObsTargetObsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboObsTargetObsAttributesArgs:
    def __init__(__self__, *,
                 dir_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 file_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gid: Optional[pulumi.Input[_builtins.int]] = None,
                 uid: Optional[pulumi.Input[_builtins.int]] = None):
        if dir_mode is not None:
            pulumi.set(__self__, "dir_mode", dir_mode)
        if file_mode is not None:
            pulumi.set(__self__, "file_mode", file_mode)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="dirMode")
    def dir_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dir_mode")

    @dir_mode.setter
    def dir_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dir_mode", value)

    @_builtins.property
    @pulumi.getter(name="fileMode")
    def file_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_mode")

    @file_mode.setter
    def file_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_mode", value)

    @_builtins.property
    @pulumi.getter
    def gid(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gid", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class SfsTurboObsTargetObsPolicyArgsDict(TypedDict):
        auto_export_policy: NotRequired[pulumi.Input['SfsTurboObsTargetObsPolicyAutoExportPolicyArgsDict']]
elif False:
    SfsTurboObsTargetObsPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboObsTargetObsPolicyArgs:
    def __init__(__self__, *,
                 auto_export_policy: Optional[pulumi.Input['SfsTurboObsTargetObsPolicyAutoExportPolicyArgs']] = None):
        if auto_export_policy is not None:
            pulumi.set(__self__, "auto_export_policy", auto_export_policy)

    @_builtins.property
    @pulumi.getter(name="autoExportPolicy")
    def auto_export_policy(self) -> Optional[pulumi.Input['SfsTurboObsTargetObsPolicyAutoExportPolicyArgs']]:
        return pulumi.get(self, "auto_export_policy")

    @auto_export_policy.setter
    def auto_export_policy(self, value: Optional[pulumi.Input['SfsTurboObsTargetObsPolicyAutoExportPolicyArgs']]):
        pulumi.set(self, "auto_export_policy", value)


if not MYPY:
    class SfsTurboObsTargetObsPolicyAutoExportPolicyArgsDict(TypedDict):
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        suffix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SfsTurboObsTargetObsPolicyAutoExportPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboObsTargetObsPolicyAutoExportPolicyArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        if events is not None:
            pulumi.set(__self__, "events", events)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class SmnSubscriptionExtensionArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        header: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        keyword: NotRequired[pulumi.Input[_builtins.str]]
        sign_secret: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SmnSubscriptionExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmnSubscriptionExtensionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 header: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 keyword: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_secret: Optional[pulumi.Input[_builtins.str]] = None):
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)
        if sign_secret is not None:
            pulumi.set(__self__, "sign_secret", sign_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def keyword(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keyword", value)

    @_builtins.property
    @pulumi.getter(name="signSecret")
    def sign_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sign_secret")

    @sign_secret.setter
    def sign_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_secret", value)


if not MYPY:
    class SmnSubscriptionFilterPolicyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The filter policy name. The policy name must be unique.
        """
        string_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The string array for exact match.
        """
elif False:
    SmnSubscriptionFilterPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmnSubscriptionFilterPolicyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 string_equals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The filter policy name. The policy name must be unique.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] string_equals: The string array for exact match.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if string_equals is not None:
            pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The filter policy name. The policy name must be unique.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")

    @string_equals.setter
    def string_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "string_equals", value)


if not MYPY:
    class SwrOrganizationPermissionsSelfPermissionArgsDict(TypedDict):
        permission: NotRequired[pulumi.Input[_builtins.str]]
        """
        The permission of current user.
        """
        user_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of current user.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of current user.
        """
elif False:
    SwrOrganizationPermissionsSelfPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwrOrganizationPermissionsSelfPermissionArgs:
    def __init__(__self__, *,
                 permission: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] permission: The permission of current user.
        :param pulumi.Input[_builtins.str] user_id: The ID of current user.
        :param pulumi.Input[_builtins.str] user_name: The name of current user.
        """
        if permission is not None:
            pulumi.set(__self__, "permission", permission)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The permission of current user.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "permission", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of current user.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of current user.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class SwrOrganizationPermissionsUserArgsDict(TypedDict):
        permission: pulumi.Input[_builtins.str]
        """
        Specifies the permission of the existing SberCloud user.
        The values can be **Manage**, **Write** and **Read**.
        """
        user_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the existing SberCloud user.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the existing SberCloud user.
        """
elif False:
    SwrOrganizationPermissionsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwrOrganizationPermissionsUserArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[_builtins.str],
                 user_id: pulumi.Input[_builtins.str],
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] permission: Specifies the permission of the existing SberCloud user.
               The values can be **Manage**, **Write** and **Read**.
        :param pulumi.Input[_builtins.str] user_id: Specifies the ID of the existing SberCloud user.
        :param pulumi.Input[_builtins.str] user_name: Specifies the name of the existing SberCloud user.
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the permission of the existing SberCloud user.
        The values can be **Manage**, **Write** and **Read**.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the existing SberCloud user.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the existing SberCloud user.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class VpnConnectionIkepolicyArgsDict(TypedDict):
        authentication_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication algorithm. The value can be **sha1**, **md5**,
        **sha2-256**, **sha2-384**, **sha2-512**. Defaults to **sha2-256**. **sha1** and **md5** are less secure,
        please use them with caution.
        """
        authentication_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication method during IKE negotiation.
        The value can be **pre-share** and **digital-envelope-v2**. Defaults to **pre-share**.
        """
        dh_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the DH group used for key exchange in phase 1.
        The value can be **group1**, **group2**, **group5**, **group14**, **group15**, **group16**, **group19**, **group20**,
        or **group21**. Exercise caution when using **group1**, **group2**, **group5**,
        or **group14** as they have low security. Defaults to **group15**.
        """
        dpd: NotRequired[pulumi.Input['VpnConnectionIkepolicyDpdArgsDict']]
        """
        Specifies the dead peer detection (DPD) object.
        The dpd structure is documented below.

        <a name="Connection_DPD"></a>
        The `dpd` block supports:
        """
        encryption_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        The encryption algorithm. The value can be **3des**, **aes-128**, **aes-192**,
        **aes-256**, **aes-128-gcm-16**, **aes-256-gcm-16**, **aes-128-gcm-128**, **aes-256-gcm-128**. Defaults to **aes-128**.
        **3des** is less secure, please use it with caution.
        """
        ike_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IKE negotiation version. The value can be **v1** and **v2**. Defaults to **v2**.
        """
        lifetime_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lifecycle time of Ipsec tunnel in seconds.
        The value ranges from **60** to **604800**. Defaults to **3600**.
        """
        local_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The local ID.
        """
        local_id_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The local ID type. The value can be **ip** or **fqdn**. Defaults to **ip**.
        """
        peer_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The peer ID.
        """
        peer_id_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The peer ID type. The value can be **ip**, **fqdn** or **any**. Defaults to **ip**.
        """
        pfs: NotRequired[pulumi.Input[_builtins.str]]
        """
        The DH key group used by PFS. The value can be **group1**, **group2**, **group5**, **group14**
        **group16**, **group19**, **group20**, **group21**. Defaults to **group14**.
        """
        phase1_negotiation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The negotiation mode, only works when the ike_version is v1.
        The value can be **main** or **aggressive**. Defaults to **main**.
        """
elif False:
    VpnConnectionIkepolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionIkepolicyArgs:
    def __init__(__self__, *,
                 authentication_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 authentication_method: Optional[pulumi.Input[_builtins.str]] = None,
                 dh_group: Optional[pulumi.Input[_builtins.str]] = None,
                 dpd: Optional[pulumi.Input['VpnConnectionIkepolicyDpdArgs']] = None,
                 encryption_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 ike_version: Optional[pulumi.Input[_builtins.str]] = None,
                 lifetime_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 local_id: Optional[pulumi.Input[_builtins.str]] = None,
                 local_id_type: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_id: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_id_type: Optional[pulumi.Input[_builtins.str]] = None,
                 pfs: Optional[pulumi.Input[_builtins.str]] = None,
                 phase1_negotiation_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication_algorithm: The authentication algorithm. The value can be **sha1**, **md5**,
               **sha2-256**, **sha2-384**, **sha2-512**. Defaults to **sha2-256**. **sha1** and **md5** are less secure,
               please use them with caution.
        :param pulumi.Input[_builtins.str] authentication_method: The authentication method during IKE negotiation.
               The value can be **pre-share** and **digital-envelope-v2**. Defaults to **pre-share**.
        :param pulumi.Input[_builtins.str] dh_group: Specifies the DH group used for key exchange in phase 1.
               The value can be **group1**, **group2**, **group5**, **group14**, **group15**, **group16**, **group19**, **group20**,
               or **group21**. Exercise caution when using **group1**, **group2**, **group5**,
               or **group14** as they have low security. Defaults to **group15**.
        :param pulumi.Input['VpnConnectionIkepolicyDpdArgs'] dpd: Specifies the dead peer detection (DPD) object.
               The dpd structure is documented below.
               
               <a name="Connection_DPD"></a>
               The `dpd` block supports:
        :param pulumi.Input[_builtins.str] encryption_algorithm: The encryption algorithm. The value can be **3des**, **aes-128**, **aes-192**,
               **aes-256**, **aes-128-gcm-16**, **aes-256-gcm-16**, **aes-128-gcm-128**, **aes-256-gcm-128**. Defaults to **aes-128**.
               **3des** is less secure, please use it with caution.
        :param pulumi.Input[_builtins.str] ike_version: The IKE negotiation version. The value can be **v1** and **v2**. Defaults to **v2**.
        :param pulumi.Input[_builtins.int] lifetime_seconds: The lifecycle time of Ipsec tunnel in seconds.
               The value ranges from **60** to **604800**. Defaults to **3600**.
        :param pulumi.Input[_builtins.str] local_id: The local ID.
        :param pulumi.Input[_builtins.str] local_id_type: The local ID type. The value can be **ip** or **fqdn**. Defaults to **ip**.
        :param pulumi.Input[_builtins.str] peer_id: The peer ID.
        :param pulumi.Input[_builtins.str] peer_id_type: The peer ID type. The value can be **ip**, **fqdn** or **any**. Defaults to **ip**.
        :param pulumi.Input[_builtins.str] pfs: The DH key group used by PFS. The value can be **group1**, **group2**, **group5**, **group14**
               **group16**, **group19**, **group20**, **group21**. Defaults to **group14**.
        :param pulumi.Input[_builtins.str] phase1_negotiation_mode: The negotiation mode, only works when the ike_version is v1.
               The value can be **main** or **aggressive**. Defaults to **main**.
        """
        if authentication_algorithm is not None:
            pulumi.set(__self__, "authentication_algorithm", authentication_algorithm)
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if dpd is not None:
            pulumi.set(__self__, "dpd", dpd)
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        if ike_version is not None:
            pulumi.set(__self__, "ike_version", ike_version)
        if lifetime_seconds is not None:
            pulumi.set(__self__, "lifetime_seconds", lifetime_seconds)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if local_id_type is not None:
            pulumi.set(__self__, "local_id_type", local_id_type)
        if peer_id is not None:
            pulumi.set(__self__, "peer_id", peer_id)
        if peer_id_type is not None:
            pulumi.set(__self__, "peer_id_type", peer_id_type)
        if pfs is not None:
            pulumi.set(__self__, "pfs", pfs)
        if phase1_negotiation_mode is not None:
            pulumi.set(__self__, "phase1_negotiation_mode", phase1_negotiation_mode)

    @_builtins.property
    @pulumi.getter(name="authenticationAlgorithm")
    def authentication_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication algorithm. The value can be **sha1**, **md5**,
        **sha2-256**, **sha2-384**, **sha2-512**. Defaults to **sha2-256**. **sha1** and **md5** are less secure,
        please use them with caution.
        """
        return pulumi.get(self, "authentication_algorithm")

    @authentication_algorithm.setter
    def authentication_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication method during IKE negotiation.
        The value can be **pre-share** and **digital-envelope-v2**. Defaults to **pre-share**.
        """
        return pulumi.get(self, "authentication_method")

    @authentication_method.setter
    def authentication_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_method", value)

    @_builtins.property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the DH group used for key exchange in phase 1.
        The value can be **group1**, **group2**, **group5**, **group14**, **group15**, **group16**, **group19**, **group20**,
        or **group21**. Exercise caution when using **group1**, **group2**, **group5**,
        or **group14** as they have low security. Defaults to **group15**.
        """
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dh_group", value)

    @_builtins.property
    @pulumi.getter
    def dpd(self) -> Optional[pulumi.Input['VpnConnectionIkepolicyDpdArgs']]:
        """
        Specifies the dead peer detection (DPD) object.
        The dpd structure is documented below.

        <a name="Connection_DPD"></a>
        The `dpd` block supports:
        """
        return pulumi.get(self, "dpd")

    @dpd.setter
    def dpd(self, value: Optional[pulumi.Input['VpnConnectionIkepolicyDpdArgs']]):
        pulumi.set(self, "dpd", value)

    @_builtins.property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The encryption algorithm. The value can be **3des**, **aes-128**, **aes-192**,
        **aes-256**, **aes-128-gcm-16**, **aes-256-gcm-16**, **aes-128-gcm-128**, **aes-256-gcm-128**. Defaults to **aes-128**.
        **3des** is less secure, please use it with caution.
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="ikeVersion")
    def ike_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IKE negotiation version. The value can be **v1** and **v2**. Defaults to **v2**.
        """
        return pulumi.get(self, "ike_version")

    @ike_version.setter
    def ike_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ike_version", value)

    @_builtins.property
    @pulumi.getter(name="lifetimeSeconds")
    def lifetime_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lifecycle time of Ipsec tunnel in seconds.
        The value ranges from **60** to **604800**. Defaults to **3600**.
        """
        return pulumi.get(self, "lifetime_seconds")

    @lifetime_seconds.setter
    def lifetime_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lifetime_seconds", value)

    @_builtins.property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The local ID.
        """
        return pulumi.get(self, "local_id")

    @local_id.setter
    def local_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_id", value)

    @_builtins.property
    @pulumi.getter(name="localIdType")
    def local_id_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The local ID type. The value can be **ip** or **fqdn**. Defaults to **ip**.
        """
        return pulumi.get(self, "local_id_type")

    @local_id_type.setter
    def local_id_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_id_type", value)

    @_builtins.property
    @pulumi.getter(name="peerId")
    def peer_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The peer ID.
        """
        return pulumi.get(self, "peer_id")

    @peer_id.setter
    def peer_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_id", value)

    @_builtins.property
    @pulumi.getter(name="peerIdType")
    def peer_id_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The peer ID type. The value can be **ip**, **fqdn** or **any**. Defaults to **ip**.
        """
        return pulumi.get(self, "peer_id_type")

    @peer_id_type.setter
    def peer_id_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_id_type", value)

    @_builtins.property
    @pulumi.getter
    def pfs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The DH key group used by PFS. The value can be **group1**, **group2**, **group5**, **group14**
        **group16**, **group19**, **group20**, **group21**. Defaults to **group14**.
        """
        return pulumi.get(self, "pfs")

    @pfs.setter
    def pfs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pfs", value)

    @_builtins.property
    @pulumi.getter(name="phase1NegotiationMode")
    def phase1_negotiation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The negotiation mode, only works when the ike_version is v1.
        The value can be **main** or **aggressive**. Defaults to **main**.
        """
        return pulumi.get(self, "phase1_negotiation_mode")

    @phase1_negotiation_mode.setter
    def phase1_negotiation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phase1_negotiation_mode", value)


if not MYPY:
    class VpnConnectionIkepolicyDpdArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the DPD idle timeout period.
        The value ranges from **10** to **3600**, in seconds. Defaults to **30**.
        """
        msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the format of DPD packets. The value can be:
        + **seq-hash-notify**: indicates that the payload of DPD packets is in the sequence of hash-notify;
        + **seq-notify-hash**: indicates that the payload of DPD packets is in the sequence of notify-hash;

        Defaults to **seq-hash-notify**.

        <a name="Connection_CreateRequestIpsecPolicy"></a>
        The `ipsecpolicy` block supports:
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the interval for retransmitting DPD packets.
        The value ranges from **2** to **60**, in seconds. Defaults to **15**.
        """
elif False:
    VpnConnectionIkepolicyDpdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionIkepolicyDpdArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 msg: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Specifies the DPD idle timeout period.
               The value ranges from **10** to **3600**, in seconds. Defaults to **30**.
        :param pulumi.Input[_builtins.str] msg: Specifies the format of DPD packets. The value can be:
               + **seq-hash-notify**: indicates that the payload of DPD packets is in the sequence of hash-notify;
               + **seq-notify-hash**: indicates that the payload of DPD packets is in the sequence of notify-hash;
               
               Defaults to **seq-hash-notify**.
               
               <a name="Connection_CreateRequestIpsecPolicy"></a>
               The `ipsecpolicy` block supports:
        :param pulumi.Input[_builtins.int] timeout: Specifies the interval for retransmitting DPD packets.
               The value ranges from **2** to **60**, in seconds. Defaults to **15**.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the DPD idle timeout period.
        The value ranges from **10** to **3600**, in seconds. Defaults to **30**.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the format of DPD packets. The value can be:
        + **seq-hash-notify**: indicates that the payload of DPD packets is in the sequence of hash-notify;
        + **seq-notify-hash**: indicates that the payload of DPD packets is in the sequence of notify-hash;

        Defaults to **seq-hash-notify**.

        <a name="Connection_CreateRequestIpsecPolicy"></a>
        The `ipsecpolicy` block supports:
        """
        return pulumi.get(self, "msg")

    @msg.setter
    def msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "msg", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the interval for retransmitting DPD packets.
        The value ranges from **2** to **60**, in seconds. Defaults to **15**.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class VpnConnectionIpsecpolicyArgsDict(TypedDict):
        authentication_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authentication algorithm. The value can be **sha1**, **md5**,
        **sha2-256**, **sha2-384**, **sha2-512**. Defaults to **sha2-256**. **sha1** and **md5** are less secure,
        please use them with caution.
        """
        encapsulation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The encapsulation mode, only **tunnel** supported for now.
        Defaults to **tunnel**.

        <a name="Connection_PolicyRule"></a>
        The `policy_rules` block supports:
        """
        encryption_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        The encryption algorithm. The value can be **3des**, **aes-128**, **aes-192**,
        **aes-256**, **aes-128-gcm-16**, **aes-256-gcm-16**, **aes-128-gcm-128**, **aes-256-gcm-128**. Defaults to **aes-128**.
        **3des** is less secure, please use it with caution.
        """
        lifetime_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lifecycle time of Ipsec tunnel in seconds.
        The value ranges from **60** to **604800**. Defaults to **3600**.
        """
        pfs: NotRequired[pulumi.Input[_builtins.str]]
        """
        The DH key group used by PFS. The value can be **group1**, **group2**, **group5**, **group14**
        **group16**, **group19**, **group20**, **group21**. Defaults to **group14**.
        """
        transform_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The transform protocol. Only **esp** supported for now.
        Defaults to **esp**.
        """
elif False:
    VpnConnectionIpsecpolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionIpsecpolicyArgs:
    def __init__(__self__, *,
                 authentication_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 encapsulation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 lifetime_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 pfs: Optional[pulumi.Input[_builtins.str]] = None,
                 transform_protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authentication_algorithm: The authentication algorithm. The value can be **sha1**, **md5**,
               **sha2-256**, **sha2-384**, **sha2-512**. Defaults to **sha2-256**. **sha1** and **md5** are less secure,
               please use them with caution.
        :param pulumi.Input[_builtins.str] encapsulation_mode: The encapsulation mode, only **tunnel** supported for now.
               Defaults to **tunnel**.
               
               <a name="Connection_PolicyRule"></a>
               The `policy_rules` block supports:
        :param pulumi.Input[_builtins.str] encryption_algorithm: The encryption algorithm. The value can be **3des**, **aes-128**, **aes-192**,
               **aes-256**, **aes-128-gcm-16**, **aes-256-gcm-16**, **aes-128-gcm-128**, **aes-256-gcm-128**. Defaults to **aes-128**.
               **3des** is less secure, please use it with caution.
        :param pulumi.Input[_builtins.int] lifetime_seconds: The lifecycle time of Ipsec tunnel in seconds.
               The value ranges from **60** to **604800**. Defaults to **3600**.
        :param pulumi.Input[_builtins.str] pfs: The DH key group used by PFS. The value can be **group1**, **group2**, **group5**, **group14**
               **group16**, **group19**, **group20**, **group21**. Defaults to **group14**.
        :param pulumi.Input[_builtins.str] transform_protocol: The transform protocol. Only **esp** supported for now.
               Defaults to **esp**.
        """
        if authentication_algorithm is not None:
            pulumi.set(__self__, "authentication_algorithm", authentication_algorithm)
        if encapsulation_mode is not None:
            pulumi.set(__self__, "encapsulation_mode", encapsulation_mode)
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        if lifetime_seconds is not None:
            pulumi.set(__self__, "lifetime_seconds", lifetime_seconds)
        if pfs is not None:
            pulumi.set(__self__, "pfs", pfs)
        if transform_protocol is not None:
            pulumi.set(__self__, "transform_protocol", transform_protocol)

    @_builtins.property
    @pulumi.getter(name="authenticationAlgorithm")
    def authentication_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authentication algorithm. The value can be **sha1**, **md5**,
        **sha2-256**, **sha2-384**, **sha2-512**. Defaults to **sha2-256**. **sha1** and **md5** are less secure,
        please use them with caution.
        """
        return pulumi.get(self, "authentication_algorithm")

    @authentication_algorithm.setter
    def authentication_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authentication_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="encapsulationMode")
    def encapsulation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The encapsulation mode, only **tunnel** supported for now.
        Defaults to **tunnel**.

        <a name="Connection_PolicyRule"></a>
        The `policy_rules` block supports:
        """
        return pulumi.get(self, "encapsulation_mode")

    @encapsulation_mode.setter
    def encapsulation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encapsulation_mode", value)

    @_builtins.property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The encryption algorithm. The value can be **3des**, **aes-128**, **aes-192**,
        **aes-256**, **aes-128-gcm-16**, **aes-256-gcm-16**, **aes-128-gcm-128**, **aes-256-gcm-128**. Defaults to **aes-128**.
        **3des** is less secure, please use it with caution.
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="lifetimeSeconds")
    def lifetime_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lifecycle time of Ipsec tunnel in seconds.
        The value ranges from **60** to **604800**. Defaults to **3600**.
        """
        return pulumi.get(self, "lifetime_seconds")

    @lifetime_seconds.setter
    def lifetime_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lifetime_seconds", value)

    @_builtins.property
    @pulumi.getter
    def pfs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The DH key group used by PFS. The value can be **group1**, **group2**, **group5**, **group14**
        **group16**, **group19**, **group20**, **group21**. Defaults to **group14**.
        """
        return pulumi.get(self, "pfs")

    @pfs.setter
    def pfs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pfs", value)

    @_builtins.property
    @pulumi.getter(name="transformProtocol")
    def transform_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The transform protocol. Only **esp** supported for now.
        Defaults to **esp**.
        """
        return pulumi.get(self, "transform_protocol")

    @transform_protocol.setter
    def transform_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transform_protocol", value)


if not MYPY:
    class VpnConnectionPolicyRuleArgsDict(TypedDict):
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of destination CIDRs.
        """
        rule_index: NotRequired[pulumi.Input[_builtins.int]]
        """
        The rule index.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source CIDR.
        """
elif False:
    VpnConnectionPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionPolicyRuleArgs:
    def __init__(__self__, *,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 rule_index: Optional[pulumi.Input[_builtins.int]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destinations: The list of destination CIDRs.
        :param pulumi.Input[_builtins.int] rule_index: The rule index.
        :param pulumi.Input[_builtins.str] source: The source CIDR.
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if rule_index is not None:
            pulumi.set(__self__, "rule_index", rule_index)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of destination CIDRs.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter(name="ruleIndex")
    def rule_index(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The rule index.
        """
        return pulumi.get(self, "rule_index")

    @rule_index.setter
    def rule_index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rule_index", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source CIDR.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class VpnGatewayCertificateArgsDict(TypedDict):
        certificate_chain: pulumi.Input[_builtins.str]
        """
        The certificate chain of the gateway certificate.
        """
        content: pulumi.Input[_builtins.str]
        """
        The content of the gateway certificate.
        """
        enc_certificate: pulumi.Input[_builtins.str]
        """
        The enc certificate of the gateway certificate.
        """
        enc_private_key: pulumi.Input[_builtins.str]
        """
        The enc private key of the gateway certificate.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the gateway certificate.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        The private of the gateway certificate.
        """
        certificate_chain_expire_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expire time of the certificate.
        """
        certificate_chain_serial_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial number of the certificate chain.
        """
        certificate_chain_subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subject of the certificate chain.
        """
        certificate_expire_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expire time of the certificate.
        """
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate ID.
        """
        certificate_serial_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial number of the certificate.
        """
        certificate_subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subject of the certificate.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The create time of the gateway certificate.
        """
        enc_certificate_expire_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expire time of the enc certificate.
        """
        enc_certificate_serial_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The serial number of the enc certificate.
        """
        enc_certificate_subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subject of the enc certificate.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The issuer of the certificate.
        """
        signature_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        The signature algorithm of the certificate.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the certificate.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The update time of the gateway certificate.
        """
elif False:
    VpnGatewayCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewayCertificateArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[_builtins.str],
                 content: pulumi.Input[_builtins.str],
                 enc_certificate: pulumi.Input[_builtins.str],
                 enc_private_key: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str],
                 certificate_chain_expire_time: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_chain_serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_chain_subject: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_expire_time: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_subject: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 enc_certificate_expire_time: Optional[pulumi.Input[_builtins.str]] = None,
                 enc_certificate_serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 enc_certificate_subject: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 signature_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_chain: The certificate chain of the gateway certificate.
        :param pulumi.Input[_builtins.str] content: The content of the gateway certificate.
        :param pulumi.Input[_builtins.str] enc_certificate: The enc certificate of the gateway certificate.
        :param pulumi.Input[_builtins.str] enc_private_key: The enc private key of the gateway certificate.
        :param pulumi.Input[_builtins.str] name: The name of the gateway certificate.
        :param pulumi.Input[_builtins.str] private_key: The private of the gateway certificate.
        :param pulumi.Input[_builtins.str] certificate_chain_expire_time: The expire time of the certificate.
        :param pulumi.Input[_builtins.str] certificate_chain_serial_number: The serial number of the certificate chain.
        :param pulumi.Input[_builtins.str] certificate_chain_subject: The subject of the certificate chain.
        :param pulumi.Input[_builtins.str] certificate_expire_time: The expire time of the certificate.
        :param pulumi.Input[_builtins.str] certificate_id: The certificate ID.
        :param pulumi.Input[_builtins.str] certificate_serial_number: The serial number of the certificate.
        :param pulumi.Input[_builtins.str] certificate_subject: The subject of the certificate.
        :param pulumi.Input[_builtins.str] created_at: The create time of the gateway certificate.
        :param pulumi.Input[_builtins.str] enc_certificate_expire_time: The expire time of the enc certificate.
        :param pulumi.Input[_builtins.str] enc_certificate_serial_number: The serial number of the enc certificate.
        :param pulumi.Input[_builtins.str] enc_certificate_subject: The subject of the enc certificate.
        :param pulumi.Input[_builtins.str] issuer: The issuer of the certificate.
        :param pulumi.Input[_builtins.str] signature_algorithm: The signature algorithm of the certificate.
        :param pulumi.Input[_builtins.str] status: The status of the certificate.
        :param pulumi.Input[_builtins.str] updated_at: The update time of the gateway certificate.
        """
        pulumi.set(__self__, "certificate_chain", certificate_chain)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "enc_certificate", enc_certificate)
        pulumi.set(__self__, "enc_private_key", enc_private_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_key", private_key)
        if certificate_chain_expire_time is not None:
            pulumi.set(__self__, "certificate_chain_expire_time", certificate_chain_expire_time)
        if certificate_chain_serial_number is not None:
            pulumi.set(__self__, "certificate_chain_serial_number", certificate_chain_serial_number)
        if certificate_chain_subject is not None:
            pulumi.set(__self__, "certificate_chain_subject", certificate_chain_subject)
        if certificate_expire_time is not None:
            pulumi.set(__self__, "certificate_expire_time", certificate_expire_time)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_serial_number is not None:
            pulumi.set(__self__, "certificate_serial_number", certificate_serial_number)
        if certificate_subject is not None:
            pulumi.set(__self__, "certificate_subject", certificate_subject)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if enc_certificate_expire_time is not None:
            pulumi.set(__self__, "enc_certificate_expire_time", enc_certificate_expire_time)
        if enc_certificate_serial_number is not None:
            pulumi.set(__self__, "enc_certificate_serial_number", enc_certificate_serial_number)
        if enc_certificate_subject is not None:
            pulumi.set(__self__, "enc_certificate_subject", enc_certificate_subject)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[_builtins.str]:
        """
        The certificate chain of the gateway certificate.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "certificate_chain", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        The content of the gateway certificate.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="encCertificate")
    def enc_certificate(self) -> pulumi.Input[_builtins.str]:
        """
        The enc certificate of the gateway certificate.
        """
        return pulumi.get(self, "enc_certificate")

    @enc_certificate.setter
    def enc_certificate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "enc_certificate", value)

    @_builtins.property
    @pulumi.getter(name="encPrivateKey")
    def enc_private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The enc private key of the gateway certificate.
        """
        return pulumi.get(self, "enc_private_key")

    @enc_private_key.setter
    def enc_private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "enc_private_key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the gateway certificate.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The private of the gateway certificate.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="certificateChainExpireTime")
    def certificate_chain_expire_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expire time of the certificate.
        """
        return pulumi.get(self, "certificate_chain_expire_time")

    @certificate_chain_expire_time.setter
    def certificate_chain_expire_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_chain_expire_time", value)

    @_builtins.property
    @pulumi.getter(name="certificateChainSerialNumber")
    def certificate_chain_serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial number of the certificate chain.
        """
        return pulumi.get(self, "certificate_chain_serial_number")

    @certificate_chain_serial_number.setter
    def certificate_chain_serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_chain_serial_number", value)

    @_builtins.property
    @pulumi.getter(name="certificateChainSubject")
    def certificate_chain_subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subject of the certificate chain.
        """
        return pulumi.get(self, "certificate_chain_subject")

    @certificate_chain_subject.setter
    def certificate_chain_subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_chain_subject", value)

    @_builtins.property
    @pulumi.getter(name="certificateExpireTime")
    def certificate_expire_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expire time of the certificate.
        """
        return pulumi.get(self, "certificate_expire_time")

    @certificate_expire_time.setter
    def certificate_expire_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_expire_time", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate ID.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="certificateSerialNumber")
    def certificate_serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial number of the certificate.
        """
        return pulumi.get(self, "certificate_serial_number")

    @certificate_serial_number.setter
    def certificate_serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_serial_number", value)

    @_builtins.property
    @pulumi.getter(name="certificateSubject")
    def certificate_subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subject of the certificate.
        """
        return pulumi.get(self, "certificate_subject")

    @certificate_subject.setter
    def certificate_subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_subject", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The create time of the gateway certificate.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="encCertificateExpireTime")
    def enc_certificate_expire_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expire time of the enc certificate.
        """
        return pulumi.get(self, "enc_certificate_expire_time")

    @enc_certificate_expire_time.setter
    def enc_certificate_expire_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enc_certificate_expire_time", value)

    @_builtins.property
    @pulumi.getter(name="encCertificateSerialNumber")
    def enc_certificate_serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The serial number of the enc certificate.
        """
        return pulumi.get(self, "enc_certificate_serial_number")

    @enc_certificate_serial_number.setter
    def enc_certificate_serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enc_certificate_serial_number", value)

    @_builtins.property
    @pulumi.getter(name="encCertificateSubject")
    def enc_certificate_subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subject of the enc certificate.
        """
        return pulumi.get(self, "enc_certificate_subject")

    @enc_certificate_subject.setter
    def enc_certificate_subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enc_certificate_subject", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The issuer of the certificate.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The signature algorithm of the certificate.
        """
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "signature_algorithm", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the certificate.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The update time of the gateway certificate.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class VpnGatewayEip1ArgsDict(TypedDict):
        bandwidth_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth ID.
        """
        bandwidth_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth name.

        Changing this parameter will create a new resource.
        """
        bandwidth_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
        cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
        When the `flavor` is **Professional2**, the value cannot be greater than **1000**.

        Changing this parameter will create a new resource.
        """
        charge_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.

        Changing this parameter will create a new resource.

        > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
        create a new EIP.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP ID.

        Changing this parameter will create a new resource.
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP address.
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The public IP version.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.

        Changing this parameter will create a new resource.
        """
elif False:
    VpnGatewayEip1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewayEip1Args:
    def __init__(__self__, *,
                 bandwidth_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[_builtins.int]] = None,
                 charge_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bandwidth_id: The bandwidth ID.
        :param pulumi.Input[_builtins.str] bandwidth_name: The bandwidth name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] bandwidth_size: Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
               cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
               When the `flavor` is **Professional2**, the value cannot be greater than **1000**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] charge_mode: The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
               
               Changing this parameter will create a new resource.
               
               > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
               create a new EIP.
        :param pulumi.Input[_builtins.str] id: The public IP ID.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] ip_address: The public IP address.
        :param pulumi.Input[_builtins.int] ip_version: The public IP version.
        :param pulumi.Input[_builtins.str] type: The EIP type. The value can be **5_bgp** and **5_sbgp**.
               
               Changing this parameter will create a new resource.
        """
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_name is not None:
            pulumi.set(__self__, "bandwidth_name", bandwidth_name)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth ID.
        """
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthName")
    def bandwidth_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bandwidth_name")

    @bandwidth_name.setter
    def bandwidth_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_name", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
        cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
        When the `flavor` is **Professional2**, the value cannot be greater than **1000**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @_builtins.property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.

        Changing this parameter will create a new resource.

        > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
        create a new EIP.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP ID.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The public IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VpnGatewayEip2ArgsDict(TypedDict):
        bandwidth_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth ID.
        """
        bandwidth_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth name.

        Changing this parameter will create a new resource.
        """
        bandwidth_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
        cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
        When the `flavor` is **Professional2**, the value cannot be greater than **1000**.

        Changing this parameter will create a new resource.
        """
        charge_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.

        Changing this parameter will create a new resource.

        > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
        create a new EIP.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP ID.

        Changing this parameter will create a new resource.
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP address.
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The public IP version.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.

        Changing this parameter will create a new resource.
        """
elif False:
    VpnGatewayEip2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewayEip2Args:
    def __init__(__self__, *,
                 bandwidth_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[_builtins.int]] = None,
                 charge_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bandwidth_id: The bandwidth ID.
        :param pulumi.Input[_builtins.str] bandwidth_name: The bandwidth name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] bandwidth_size: Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
               cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
               When the `flavor` is **Professional2**, the value cannot be greater than **1000**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] charge_mode: The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
               
               Changing this parameter will create a new resource.
               
               > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
               create a new EIP.
        :param pulumi.Input[_builtins.str] id: The public IP ID.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] ip_address: The public IP address.
        :param pulumi.Input[_builtins.int] ip_version: The public IP version.
        :param pulumi.Input[_builtins.str] type: The EIP type. The value can be **5_bgp** and **5_sbgp**.
               
               Changing this parameter will create a new resource.
        """
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_name is not None:
            pulumi.set(__self__, "bandwidth_name", bandwidth_name)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth ID.
        """
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthName")
    def bandwidth_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bandwidth_name")

    @bandwidth_name.setter
    def bandwidth_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_name", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
        cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
        When the `flavor` is **Professional2**, the value cannot be greater than **1000**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @_builtins.property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.

        Changing this parameter will create a new resource.

        > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
        create a new EIP.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP ID.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The public IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VpnGatewayMasterEipArgsDict(TypedDict):
        bandwidth_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth ID.
        """
        bandwidth_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth name.

        Changing this parameter will create a new resource.
        """
        bandwidth_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
        cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
        When the `flavor` is **Professional2**, the value cannot be greater than **1000**.

        Changing this parameter will create a new resource.
        """
        charge_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.

        Changing this parameter will create a new resource.

        > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
        create a new EIP.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP ID.

        Changing this parameter will create a new resource.
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP address.
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The public IP version.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.

        Changing this parameter will create a new resource.
        """
elif False:
    VpnGatewayMasterEipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewayMasterEipArgs:
    def __init__(__self__, *,
                 bandwidth_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[_builtins.int]] = None,
                 charge_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bandwidth_id: The bandwidth ID.
        :param pulumi.Input[_builtins.str] bandwidth_name: The bandwidth name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] bandwidth_size: Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
               cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
               When the `flavor` is **Professional2**, the value cannot be greater than **1000**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] charge_mode: The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
               
               Changing this parameter will create a new resource.
               
               > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
               create a new EIP.
        :param pulumi.Input[_builtins.str] id: The public IP ID.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] ip_address: The public IP address.
        :param pulumi.Input[_builtins.int] ip_version: The public IP version.
        :param pulumi.Input[_builtins.str] type: The EIP type. The value can be **5_bgp** and **5_sbgp**.
               
               Changing this parameter will create a new resource.
        """
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_name is not None:
            pulumi.set(__self__, "bandwidth_name", bandwidth_name)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth ID.
        """
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthName")
    def bandwidth_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bandwidth_name")

    @bandwidth_name.setter
    def bandwidth_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_name", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
        cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
        When the `flavor` is **Professional2**, the value cannot be greater than **1000**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @_builtins.property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.

        Changing this parameter will create a new resource.

        > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
        create a new EIP.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP ID.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The public IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VpnGatewaySlaveEipArgsDict(TypedDict):
        bandwidth_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth ID.
        """
        bandwidth_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth name.

        Changing this parameter will create a new resource.
        """
        bandwidth_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
        cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
        When the `flavor` is **Professional2**, the value cannot be greater than **1000**.

        Changing this parameter will create a new resource.
        """
        charge_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.

        Changing this parameter will create a new resource.

        > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
        create a new EIP.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP ID.

        Changing this parameter will create a new resource.
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public IP address.
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The public IP version.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.

        Changing this parameter will create a new resource.
        """
elif False:
    VpnGatewaySlaveEipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewaySlaveEipArgs:
    def __init__(__self__, *,
                 bandwidth_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[_builtins.int]] = None,
                 charge_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bandwidth_id: The bandwidth ID.
        :param pulumi.Input[_builtins.str] bandwidth_name: The bandwidth name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] bandwidth_size: Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
               cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
               When the `flavor` is **Professional2**, the value cannot be greater than **1000**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] charge_mode: The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
               
               Changing this parameter will create a new resource.
               
               > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
               create a new EIP.
        :param pulumi.Input[_builtins.str] id: The public IP ID.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] ip_address: The public IP address.
        :param pulumi.Input[_builtins.int] ip_version: The public IP version.
        :param pulumi.Input[_builtins.str] type: The EIP type. The value can be **5_bgp** and **5_sbgp**.
               
               Changing this parameter will create a new resource.
        """
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_name is not None:
            pulumi.set(__self__, "bandwidth_name", bandwidth_name)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth ID.
        """
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthName")
    def bandwidth_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bandwidth_name")

    @bandwidth_name.setter
    def bandwidth_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_name", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
        cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
        When the `flavor` is **Professional2**, the value cannot be greater than **1000**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @_builtins.property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.

        Changing this parameter will create a new resource.

        > You can use `id` to specify an existing EIP or use `type`, `bandwidth_name`, `bandwidth_size` and `charge_mode` to
        create a new EIP.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP ID.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The public IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


