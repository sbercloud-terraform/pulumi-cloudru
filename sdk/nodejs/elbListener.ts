// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class ElbListener extends pulumi.CustomResource {
    /**
     * Get an existing ElbListener resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ElbListenerState, opts?: pulumi.CustomResourceOptions): ElbListener {
        return new ElbListener(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'sbercloud:index/elbListener:ElbListener';

    /**
     * Returns true if the given object is an instance of ElbListener.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ElbListener {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ElbListener.__pulumiType;
    }

    declare public readonly accessPolicy: pulumi.Output<string | undefined>;
    declare public readonly advancedForwardingEnabled: pulumi.Output<boolean>;
    declare public readonly caCertificate: pulumi.Output<string | undefined>;
    declare public readonly cps: pulumi.Output<number>;
    declare public /*out*/ readonly createdAt: pulumi.Output<string>;
    declare public readonly defaultPoolId: pulumi.Output<string>;
    declare public readonly description: pulumi.Output<string | undefined>;
    declare public readonly enableMemberRetry: pulumi.Output<boolean>;
    declare public readonly enableQuicUpgrade: pulumi.Output<string | undefined>;
    declare public /*out*/ readonly enterpriseProjectId: pulumi.Output<string>;
    declare public readonly forceDelete: pulumi.Output<boolean | undefined>;
    declare public readonly forwardEip: pulumi.Output<boolean>;
    declare public readonly forwardElb: pulumi.Output<boolean>;
    declare public readonly forwardHost: pulumi.Output<boolean | undefined>;
    declare public readonly forwardPort: pulumi.Output<boolean>;
    declare public readonly forwardProto: pulumi.Output<boolean>;
    declare public readonly forwardRequestPort: pulumi.Output<boolean>;
    declare public readonly forwardTlsCertificate: pulumi.Output<boolean>;
    declare public readonly forwardTlsCipher: pulumi.Output<boolean>;
    declare public readonly forwardTlsProtocol: pulumi.Output<boolean>;
    declare public readonly gzipEnable: pulumi.Output<boolean>;
    declare public readonly http2Enable: pulumi.Output<boolean>;
    declare public readonly idleTimeout: pulumi.Output<number>;
    declare public readonly ipGroup: pulumi.Output<string | undefined>;
    declare public readonly ipGroupEnable: pulumi.Output<string>;
    declare public readonly loadbalancerId: pulumi.Output<string>;
    declare public readonly maxConnection: pulumi.Output<number>;
    declare public readonly name: pulumi.Output<string>;
    declare public readonly portRanges: pulumi.Output<outputs.ElbListenerPortRange[] | undefined>;
    declare public readonly protectionReason: pulumi.Output<string | undefined>;
    declare public readonly protectionStatus: pulumi.Output<string>;
    declare public readonly protocol: pulumi.Output<string>;
    declare public readonly protocolPort: pulumi.Output<number>;
    declare public readonly proxyProtocolEnable: pulumi.Output<boolean>;
    declare public readonly quicListenerId: pulumi.Output<string | undefined>;
    declare public readonly realIp: pulumi.Output<boolean>;
    declare public readonly region: pulumi.Output<string>;
    declare public readonly requestTimeout: pulumi.Output<number>;
    declare public readonly responseTimeout: pulumi.Output<number>;
    declare public readonly securityPolicyId: pulumi.Output<string | undefined>;
    declare public readonly serverCertificate: pulumi.Output<string | undefined>;
    declare public readonly sniCertificates: pulumi.Output<string[] | undefined>;
    declare public readonly sniMatchAlgo: pulumi.Output<string>;
    declare public readonly sslEarlyDataEnable: pulumi.Output<boolean | undefined>;
    declare public readonly tags: pulumi.Output<{[key: string]: string}>;
    declare public readonly tlsCiphersPolicy: pulumi.Output<string>;
    declare public /*out*/ readonly updatedAt: pulumi.Output<string>;

    /**
     * Create a ElbListener resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ElbListenerArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ElbListenerArgs | ElbListenerState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ElbListenerState | undefined;
            resourceInputs["accessPolicy"] = state?.accessPolicy;
            resourceInputs["advancedForwardingEnabled"] = state?.advancedForwardingEnabled;
            resourceInputs["caCertificate"] = state?.caCertificate;
            resourceInputs["cps"] = state?.cps;
            resourceInputs["createdAt"] = state?.createdAt;
            resourceInputs["defaultPoolId"] = state?.defaultPoolId;
            resourceInputs["description"] = state?.description;
            resourceInputs["enableMemberRetry"] = state?.enableMemberRetry;
            resourceInputs["enableQuicUpgrade"] = state?.enableQuicUpgrade;
            resourceInputs["enterpriseProjectId"] = state?.enterpriseProjectId;
            resourceInputs["forceDelete"] = state?.forceDelete;
            resourceInputs["forwardEip"] = state?.forwardEip;
            resourceInputs["forwardElb"] = state?.forwardElb;
            resourceInputs["forwardHost"] = state?.forwardHost;
            resourceInputs["forwardPort"] = state?.forwardPort;
            resourceInputs["forwardProto"] = state?.forwardProto;
            resourceInputs["forwardRequestPort"] = state?.forwardRequestPort;
            resourceInputs["forwardTlsCertificate"] = state?.forwardTlsCertificate;
            resourceInputs["forwardTlsCipher"] = state?.forwardTlsCipher;
            resourceInputs["forwardTlsProtocol"] = state?.forwardTlsProtocol;
            resourceInputs["gzipEnable"] = state?.gzipEnable;
            resourceInputs["http2Enable"] = state?.http2Enable;
            resourceInputs["idleTimeout"] = state?.idleTimeout;
            resourceInputs["ipGroup"] = state?.ipGroup;
            resourceInputs["ipGroupEnable"] = state?.ipGroupEnable;
            resourceInputs["loadbalancerId"] = state?.loadbalancerId;
            resourceInputs["maxConnection"] = state?.maxConnection;
            resourceInputs["name"] = state?.name;
            resourceInputs["portRanges"] = state?.portRanges;
            resourceInputs["protectionReason"] = state?.protectionReason;
            resourceInputs["protectionStatus"] = state?.protectionStatus;
            resourceInputs["protocol"] = state?.protocol;
            resourceInputs["protocolPort"] = state?.protocolPort;
            resourceInputs["proxyProtocolEnable"] = state?.proxyProtocolEnable;
            resourceInputs["quicListenerId"] = state?.quicListenerId;
            resourceInputs["realIp"] = state?.realIp;
            resourceInputs["region"] = state?.region;
            resourceInputs["requestTimeout"] = state?.requestTimeout;
            resourceInputs["responseTimeout"] = state?.responseTimeout;
            resourceInputs["securityPolicyId"] = state?.securityPolicyId;
            resourceInputs["serverCertificate"] = state?.serverCertificate;
            resourceInputs["sniCertificates"] = state?.sniCertificates;
            resourceInputs["sniMatchAlgo"] = state?.sniMatchAlgo;
            resourceInputs["sslEarlyDataEnable"] = state?.sslEarlyDataEnable;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["tlsCiphersPolicy"] = state?.tlsCiphersPolicy;
            resourceInputs["updatedAt"] = state?.updatedAt;
        } else {
            const args = argsOrState as ElbListenerArgs | undefined;
            if (args?.loadbalancerId === undefined && !opts.urn) {
                throw new Error("Missing required property 'loadbalancerId'");
            }
            if (args?.protocol === undefined && !opts.urn) {
                throw new Error("Missing required property 'protocol'");
            }
            resourceInputs["accessPolicy"] = args?.accessPolicy;
            resourceInputs["advancedForwardingEnabled"] = args?.advancedForwardingEnabled;
            resourceInputs["caCertificate"] = args?.caCertificate;
            resourceInputs["cps"] = args?.cps;
            resourceInputs["defaultPoolId"] = args?.defaultPoolId;
            resourceInputs["description"] = args?.description;
            resourceInputs["enableMemberRetry"] = args?.enableMemberRetry;
            resourceInputs["enableQuicUpgrade"] = args?.enableQuicUpgrade;
            resourceInputs["forceDelete"] = args?.forceDelete;
            resourceInputs["forwardEip"] = args?.forwardEip;
            resourceInputs["forwardElb"] = args?.forwardElb;
            resourceInputs["forwardHost"] = args?.forwardHost;
            resourceInputs["forwardPort"] = args?.forwardPort;
            resourceInputs["forwardProto"] = args?.forwardProto;
            resourceInputs["forwardRequestPort"] = args?.forwardRequestPort;
            resourceInputs["forwardTlsCertificate"] = args?.forwardTlsCertificate;
            resourceInputs["forwardTlsCipher"] = args?.forwardTlsCipher;
            resourceInputs["forwardTlsProtocol"] = args?.forwardTlsProtocol;
            resourceInputs["gzipEnable"] = args?.gzipEnable;
            resourceInputs["http2Enable"] = args?.http2Enable;
            resourceInputs["idleTimeout"] = args?.idleTimeout;
            resourceInputs["ipGroup"] = args?.ipGroup;
            resourceInputs["ipGroupEnable"] = args?.ipGroupEnable;
            resourceInputs["loadbalancerId"] = args?.loadbalancerId;
            resourceInputs["maxConnection"] = args?.maxConnection;
            resourceInputs["name"] = args?.name;
            resourceInputs["portRanges"] = args?.portRanges;
            resourceInputs["protectionReason"] = args?.protectionReason;
            resourceInputs["protectionStatus"] = args?.protectionStatus;
            resourceInputs["protocol"] = args?.protocol;
            resourceInputs["protocolPort"] = args?.protocolPort;
            resourceInputs["proxyProtocolEnable"] = args?.proxyProtocolEnable;
            resourceInputs["quicListenerId"] = args?.quicListenerId;
            resourceInputs["realIp"] = args?.realIp;
            resourceInputs["region"] = args?.region;
            resourceInputs["requestTimeout"] = args?.requestTimeout;
            resourceInputs["responseTimeout"] = args?.responseTimeout;
            resourceInputs["securityPolicyId"] = args?.securityPolicyId;
            resourceInputs["serverCertificate"] = args?.serverCertificate;
            resourceInputs["sniCertificates"] = args?.sniCertificates;
            resourceInputs["sniMatchAlgo"] = args?.sniMatchAlgo;
            resourceInputs["sslEarlyDataEnable"] = args?.sslEarlyDataEnable;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["tlsCiphersPolicy"] = args?.tlsCiphersPolicy;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["enterpriseProjectId"] = undefined /*out*/;
            resourceInputs["updatedAt"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ElbListener.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ElbListener resources.
 */
export interface ElbListenerState {
    accessPolicy?: pulumi.Input<string>;
    advancedForwardingEnabled?: pulumi.Input<boolean>;
    caCertificate?: pulumi.Input<string>;
    cps?: pulumi.Input<number>;
    createdAt?: pulumi.Input<string>;
    defaultPoolId?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    enableMemberRetry?: pulumi.Input<boolean>;
    enableQuicUpgrade?: pulumi.Input<string>;
    enterpriseProjectId?: pulumi.Input<string>;
    forceDelete?: pulumi.Input<boolean>;
    forwardEip?: pulumi.Input<boolean>;
    forwardElb?: pulumi.Input<boolean>;
    forwardHost?: pulumi.Input<boolean>;
    forwardPort?: pulumi.Input<boolean>;
    forwardProto?: pulumi.Input<boolean>;
    forwardRequestPort?: pulumi.Input<boolean>;
    forwardTlsCertificate?: pulumi.Input<boolean>;
    forwardTlsCipher?: pulumi.Input<boolean>;
    forwardTlsProtocol?: pulumi.Input<boolean>;
    gzipEnable?: pulumi.Input<boolean>;
    http2Enable?: pulumi.Input<boolean>;
    idleTimeout?: pulumi.Input<number>;
    ipGroup?: pulumi.Input<string>;
    ipGroupEnable?: pulumi.Input<string>;
    loadbalancerId?: pulumi.Input<string>;
    maxConnection?: pulumi.Input<number>;
    name?: pulumi.Input<string>;
    portRanges?: pulumi.Input<pulumi.Input<inputs.ElbListenerPortRange>[]>;
    protectionReason?: pulumi.Input<string>;
    protectionStatus?: pulumi.Input<string>;
    protocol?: pulumi.Input<string>;
    protocolPort?: pulumi.Input<number>;
    proxyProtocolEnable?: pulumi.Input<boolean>;
    quicListenerId?: pulumi.Input<string>;
    realIp?: pulumi.Input<boolean>;
    region?: pulumi.Input<string>;
    requestTimeout?: pulumi.Input<number>;
    responseTimeout?: pulumi.Input<number>;
    securityPolicyId?: pulumi.Input<string>;
    serverCertificate?: pulumi.Input<string>;
    sniCertificates?: pulumi.Input<pulumi.Input<string>[]>;
    sniMatchAlgo?: pulumi.Input<string>;
    sslEarlyDataEnable?: pulumi.Input<boolean>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    tlsCiphersPolicy?: pulumi.Input<string>;
    updatedAt?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a ElbListener resource.
 */
export interface ElbListenerArgs {
    accessPolicy?: pulumi.Input<string>;
    advancedForwardingEnabled?: pulumi.Input<boolean>;
    caCertificate?: pulumi.Input<string>;
    cps?: pulumi.Input<number>;
    defaultPoolId?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    enableMemberRetry?: pulumi.Input<boolean>;
    enableQuicUpgrade?: pulumi.Input<string>;
    forceDelete?: pulumi.Input<boolean>;
    forwardEip?: pulumi.Input<boolean>;
    forwardElb?: pulumi.Input<boolean>;
    forwardHost?: pulumi.Input<boolean>;
    forwardPort?: pulumi.Input<boolean>;
    forwardProto?: pulumi.Input<boolean>;
    forwardRequestPort?: pulumi.Input<boolean>;
    forwardTlsCertificate?: pulumi.Input<boolean>;
    forwardTlsCipher?: pulumi.Input<boolean>;
    forwardTlsProtocol?: pulumi.Input<boolean>;
    gzipEnable?: pulumi.Input<boolean>;
    http2Enable?: pulumi.Input<boolean>;
    idleTimeout?: pulumi.Input<number>;
    ipGroup?: pulumi.Input<string>;
    ipGroupEnable?: pulumi.Input<string>;
    loadbalancerId: pulumi.Input<string>;
    maxConnection?: pulumi.Input<number>;
    name?: pulumi.Input<string>;
    portRanges?: pulumi.Input<pulumi.Input<inputs.ElbListenerPortRange>[]>;
    protectionReason?: pulumi.Input<string>;
    protectionStatus?: pulumi.Input<string>;
    protocol: pulumi.Input<string>;
    protocolPort?: pulumi.Input<number>;
    proxyProtocolEnable?: pulumi.Input<boolean>;
    quicListenerId?: pulumi.Input<string>;
    realIp?: pulumi.Input<boolean>;
    region?: pulumi.Input<string>;
    requestTimeout?: pulumi.Input<number>;
    responseTimeout?: pulumi.Input<number>;
    securityPolicyId?: pulumi.Input<string>;
    serverCertificate?: pulumi.Input<string>;
    sniCertificates?: pulumi.Input<pulumi.Input<string>[]>;
    sniMatchAlgo?: pulumi.Input<string>;
    sslEarlyDataEnable?: pulumi.Input<boolean>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    tlsCiphersPolicy?: pulumi.Input<string>;
}
