// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApigApplicationQuotaAssociateApplication {
    /**
     * The binding time, in RFC3339 format.
     */
    bindTime: string;
    /**
     * The application ID bound to the application quota.
     */
    id: string;
}

export interface ApigChannelHealthCheck {
    /**
     * Whether to enable two-way authentication.
     */
    enableClientSsl: boolean;
    /**
     * The response codes for determining a successful HTTP response.
     */
    httpCodes: string;
    /**
     * The interval between consecutive check, in second.
     */
    interval: number;
    /**
     * The request method for health check.
     */
    method: string;
    /**
     * The destination path for health check.
     */
    path: string;
    /**
     * The destination host port for health check.
     */
    port: number;
    /**
     * The rotocol for performing health check on backend servers.
     */
    protocol: string;
    /**
     * The status of health check.
     */
    status: number;
    /**
     * The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
     */
    thresholdAbnormal: number;
    /**
     * The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
     */
    thresholdNormal: number;
    /**
     * The timeout for determining whether a health check fails, in second.
     */
    timeout: number;
}

export interface ApigChannelMember {
    /**
     * The group name of the backend server.
     */
    groupName: string;
    /**
     * The IP address of the backend server.
     */
    host: string;
    /**
     * The ID of the backend server.
     */
    id: string;
    /**
     * Whether this member is the backup member.
     */
    isBackup: boolean;
    /**
     * The name of the backend server.
     */
    name: string;
    /**
     * The port of the backend server.
     */
    port: number;
    /**
     * The status of the backend server.
     */
    status: number;
    /**
     * The weight of current backend server.
     */
    weight: number;
}

export interface ApigChannelMemberGroup {
    /**
     * The description of the member group.
     */
    description: string;
    /**
     * The microservice tags of the backend server group.
     */
    microserviceLabels: {[key: string]: string};
    /**
     * The microservice port of the backend server group.
     */
    microservicePort: number;
    /**
     * The microservice version of the backend server group.
     */
    microserviceVersion: string;
    /**
     * The name of the member group.
     */
    name: string;
    /**
     * The ID of the reference load balance channel.
     */
    referenceVpcChannelId: string;
    /**
     * The weight of the current member group.
     */
    weight: number;
}

export interface ApigChannelMicroservice {
    /**
     * The CCE microservice details.
     */
    cceConfig: outputs.ApigChannelMicroserviceCceConfig;
    /**
     * schema:Internal; The CSE microservice details.
     */
    cseConfig: outputs.ApigChannelMicroserviceCseConfig;
}

export interface ApigChannelMicroserviceCceConfig {
    /**
     * The ID of the CCE cluster.
     */
    clusterId: string;
    /**
     * The service label key.
     */
    labelKey?: string;
    /**
     * The service label value.
     */
    labelValue?: string;
    /**
     * The name of the CCE namespace.
     */
    namespace: string;
    /**
     * The workload name.
     */
    workloadName?: string;
    /**
     * The workload type.
     */
    workloadType: string;
}

export interface ApigChannelMicroserviceCseConfig {
    /**
     * schema:Internal; The microservice engine ID.
     */
    engineId: string;
    /**
     * schema:Internal; The microservice ID.
     */
    serviceId: string;
}

export interface CbrBackupShareMember {
    /**
     * The creation time of the backup shared member.
     */
    createdAt: string;
    /**
     * The ID of the project with which the backup is shared.
     */
    destProjectId: string;
    /**
     * The ID of the backup shared member record.
     */
    id: string;
    /**
     * The ID of the image registered with the shared backup copy.
     */
    imageId: string;
    /**
     * The backup shared status.
     */
    status: string;
    /**
     * The latest update time of the backup shared member.
     */
    updatedAt: string;
    /**
     * The ID of the vault where the shared backup is stored.
     */
    vaultId: string;
}

export interface CbrCheckpointBackup {
    /**
     * The backup ID.
     */
    id: string;
    /**
     * The backup time.
     */
    protectedAt: string;
    /**
     * The ID of backup resource.
     */
    resourceId: string;
    /**
     * The backup resource size.
     */
    resourceSize: number;
    /**
     * The backup status.
     */
    status: string;
    /**
     * The type of the backup resource.
     */
    type: string;
    /**
     * The latest update time of the backup.
     */
    updatedAt: string;
}

export interface DcsParametersConfigurationParameter {
    /**
     * Indicates the parameter name.
     */
    name: string;
    /**
     * Indicates whether a restart is required.
     */
    needRestart: boolean;
    /**
     * Indicates the parameter type.
     */
    type: string;
    /**
     * Indicates a user permission
     */
    userPermission: string;
    /**
     * Indicates the parameter value.
     */
    value: string;
}

export interface DcsRestoreRestoreRecord {
    /**
     * ID of the backup record.
     */
    backupId: string;
    /**
     * Name of the backup record.
     */
    backupName: string;
    /**
     * Description of DCS instance backup.
     */
    backupRemark: string;
    /**
     * Time at which the restoration task is created.
     */
    createdAt: string;
    /**
     * Error code returned if DCS instance restoration fails.
     */
    errorCode: string;
    /**
     * Restoration progress.
     */
    progress: string;
    /**
     * ID of the restoration record.
     */
    restoreId: string;
    /**
     * Name of the restoration record.
     */
    restoreName: string;
    /**
     * Description of DCS instance restoration.
     */
    restoreRemark: string;
    sourceInstanceId: string;
    sourceInstanceName: string;
    /**
     * Restoration status:
     */
    status: string;
    /**
     * Time at which DCS instance restoration completed.
     */
    updatedAt: string;
}

export interface DdsParameterTemplateCompareDifference {
    /**
     * Indicates the parameter name.
     */
    parameterName: string;
    /**
     * Indicates the parameter value in the source parameter template.
     */
    sourceValue: string;
    /**
     * Indicates the parameter value in the destination parameter template.
     */
    targetValue: string;
}

export interface DdsParameterTemplateCopyParameter {
    /**
     * Specifies the description of replicated parameter template.
     * The value is left blank by default. The description must consist of a maximum of **256** characters and cannot contain
     * the carriage return character or the following special characters: >!<"&'=
     * Changing this creates a new resource.
     */
    description: string;
    /**
     * Specifies the name of replicated parameter template.
     * The parameter template name can contain **1** to **64** characters. It can contain only letters, digits, hyphens (-),
     * underscores (_), and periods (.).
     * Changing this creates a new resource.
     */
    name: string;
    /**
     * Indicates whether the parameter is read-only.
     * + If the value is **true**, the parameter is read-only.
     * + If the value is **false**, the parameter is not read-only.
     */
    readonly: boolean;
    /**
     * Indicates whether the instance needs to be restarted.
     * + If the value is **true**, restart is required.
     * + If the value is **false**, restart is not required.
     */
    restartRequired: boolean;
    /**
     * Indicates the parameter type. The value can be integer, string, boolean, float, or list.
     */
    type: string;
    /**
     * Indicates the parameter value.
     */
    value: string;
    /**
     * Indicates the value range.
     */
    valueRange: string;
}

export interface DdsParameterTemplateParameter {
    /**
     * Specifies the parameter template description.
     * The description must consist of a maximum of 256 characters and cannot contain the carriage
     * return character or the following special characters: >!<"&'=.
     */
    description: string;
    /**
     * Specifies the parameter template name.
     * The value must be 1 to 64 characters, which can contain only letters, digits, hyphens (-),
     * underscores (_), and periods (.).
     */
    name: string;
    /**
     * Indicates whether the parameter is read-only.
     * + If the value is **true**, the parameter is read-only.
     * + If the value is **false**, the parameter is not read-only.
     */
    readonly: boolean;
    /**
     * Indicates whether the instance needs to be restarted.
     * + If the value is **true**, restart is required.
     * + If the value is **false**, restart is not required.
     */
    restartRequired: boolean;
    /**
     * Indicates the parameter type. The value can be integer, string, boolean, float, or list.
     */
    type: string;
    /**
     * Indicates the parameter value.
     */
    value: string;
    /**
     * Indicates the value range.
     */
    valueRange: string;
}

export interface DmsKafkaMessageProducePropertyList {
    name: string;
    value: string;
}

export interface DmsRocketmqConsumptionVerifyResendResult {
    /**
     * Indicates the error code.
     */
    errorCode: string;
    /**
     * Indicates the error message.
     */
    errorMessage: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
}

export interface DmsRocketmqDeadLetterResendResendResult {
    /**
     * Indicates the error code.
     */
    errorCode: string;
    /**
     * Indicates the error message.
     */
    errorMessage: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
}

export interface DmsRocketmqInstanceConfig {
    /**
     * Specifies the config name.
     */
    name: string;
    /**
     * Specifies the config value.
     *
     * > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
     */
    value: string;
}

export interface DmsRocketmqInstanceCrossVpcAccess {
    /**
     * The advertised IP Address or domain name.
     */
    advertisedIp: string;
    /**
     * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
     */
    lisenterIp: string;
    /**
     * The listener IP address.
     */
    listenerIp: string;
    /**
     * The port number.
     */
    port: number;
    /**
     * The port ID associated with the address.
     */
    portId: string;
}

export interface DmsRocketmqMigrationTaskBinding {
    /**
     * Specifies the message target. Changing this creates a new resource.
     */
    destination?: string;
    /**
     * Specifies the message target type.
     * Changing this creates a new resource.
     */
    destinationType: string;
    /**
     * Specifies the routing key. Changing this creates a new resource.
     */
    routingKey: string;
    /**
     * Specifies the message source. Changing this creates a new resource.
     */
    source: string;
    /**
     * Specifies the virtual host name. Changing this creates a new resource.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskExchange {
    /**
     * Specifies whether to enable data persistence.
     * Changing this creates a new resource.
     */
    durable: boolean;
    /**
     * Specifies the switch name. Changing this creates a new resource.
     */
    name: string;
    /**
     * Specifies the exchange type. Changing this creates a new resource.
     *
     * <a name="RocketMQ_migration_task_bindings"></a>
     * The `bindings` block supports:
     */
    type: string;
    /**
     * Specifies the virtual host name. Changing this creates a new resource.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskQueue {
    /**
     * Specifies whether to enable data persistence.
     * Changing this creates a new resource.
     */
    durable: boolean;
    /**
     * Specifies the switch name. Changing this creates a new resource.
     */
    name: string;
    /**
     * Specifies the virtual host name. Changing this creates a new resource.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskSubscriptionGroup {
    /**
     * Specifies whether to enable broadcast.
     * Changing this creates a new resource.
     */
    consumeBroadcastEnable: boolean;
    /**
     * Specifies whether to enable consumption.
     * Changing this creates a new resource.
     */
    consumeEnable: boolean;
    /**
     * Specifies whether to enable consumption from the earliest
     * offset. Changing this creates a new resource.
     */
    consumeFromMinEnable: boolean;
    /**
     * Specifies the name of a consumer group.
     * Changing this creates a new resource.
     */
    groupName: string;
    /**
     * Specifies whether to notify changes of consumer IDs.
     * Changing this creates a new resource.
     */
    notifyConsumeridsChangedEnable: boolean;
    /**
     * Specifies the maximum number of consumption retries.
     * Changing this creates a new resource.
     */
    retryMaxTimes: number;
    /**
     * Specifies the number of retry queues.
     * Changing this creates a new resource.
     */
    retryQueueNum: number;
    /**
     * Specifies the ID of the broker selected for slow
     * consumption. Changing this creates a new resource.
     *
     * <a name="RocketMQ_migration_task_vhosts"></a>
     * The `vhosts` block supports:
     */
    whichBrokerWhenConsumeSlow: number;
}

export interface DmsRocketmqMigrationTaskTopicConfig {
    /**
     * Specifies whether a message is an ordered message.
     * Changing this creates a new resource.
     */
    order: boolean;
    /**
     * Specifies the number of permission. Changing this creates a new resource.
     */
    perm: number;
    /**
     * Specifies the number of read queues.
     * Changing this creates a new resource.
     */
    readQueueNum: number;
    /**
     * Specifies the filter type of a topic.
     * Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
     */
    topicFilterType: string;
    /**
     * Specifies the topic name. Changing this creates a new resource.
     */
    topicName: string;
    /**
     * Specifies the system flag of a topic.
     * Changing this creates a new resource.
     */
    topicSysFlag: number;
    /**
     * Specifies the number of write queues.
     * Changing this creates a new resource.
     *
     * <a name="RocketMQ_migration_task_subscription_groups"></a>
     * The `subscriptionGroups` block supports:
     */
    writeQueueNum: number;
}

export interface DmsRocketmqMigrationTaskVhost {
    /**
     * Specifies the switch name. Changing this creates a new resource.
     */
    name: string;
}

export interface DmsRocketmqTopicBroker {
    /**
     * Specifies the name of the broker.
     *
     * <a name="DmsRocketMQTopic_QueueRef"></a>
     * The `queues` block supports:
     */
    name: string;
    /**
     * Indicates the read queues number of the broker. It's useless when create a topic.
     */
    readQueueNum: number;
    /**
     * Indicates the read queues number of the broker. It's useless when create a topic.
     */
    writeQueueNum: number;
}

export interface DmsRocketmqTopicQueue {
    /**
     * Specifies the associated broker.
     */
    broker?: string;
    /**
     * Specifies the number of the queues.
     */
    queueNum?: number;
}

export interface DmsRocketmqUserGroupPerm {
    /**
     * Indicates the name of a topic or consumer group.
     */
    name: string;
    /**
     * Indicates the permissions of the topic or consumer group.
     * Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
     */
    perm: string;
}

export interface DmsRocketmqUserTopicPerm {
    /**
     * Indicates the name of a topic or consumer group.
     */
    name: string;
    /**
     * Indicates the permissions of the topic or consumer group.
     * Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
     */
    perm: string;
}

export interface ElbIpgroupIpList {
    /**
     * Human-readable description for the ip.
     */
    description?: string;
    /**
     * IP address or CIDR block.
     */
    ip: string;
}

export interface ElbL7policyFixedResponseConfig {
    contentType: string;
    insertHeadersConfig?: outputs.ElbL7policyFixedResponseConfigInsertHeadersConfig;
    messageBody?: string;
    removeHeadersConfig?: outputs.ElbL7policyFixedResponseConfigRemoveHeadersConfig;
    statusCode: string;
    trafficLimitConfig?: outputs.ElbL7policyFixedResponseConfigTrafficLimitConfig;
}

export interface ElbL7policyFixedResponseConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyFixedResponseConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyFixedResponseConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyFixedResponseConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyFixedResponseConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyFixedResponseConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7policyFixedResponseConfigTrafficLimitConfig {
    burst?: number;
    perSourceIpQps?: number;
    qps?: number;
}

export interface ElbL7policyRedirectPoolsConfig {
    poolId: string;
    weight: number;
}

export interface ElbL7policyRedirectPoolsExtendConfig {
    insertHeadersConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfig;
    removeHeadersConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfig;
    rewriteUrlConfig: outputs.ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfig;
    rewriteUrlEnabled: boolean;
    trafficLimitConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfig;
}

export interface ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfig {
    host: string;
    path: string;
    query?: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfig {
    burst?: number;
    perSourceIpQps?: number;
    qps?: number;
}

export interface ElbL7policyRedirectPoolsStickySessionConfig {
    enable: boolean;
    timeout: number;
}

export interface ElbL7policyRedirectUrlConfig {
    host: string;
    insertHeadersConfig?: outputs.ElbL7policyRedirectUrlConfigInsertHeadersConfig;
    path: string;
    port: string;
    protocol: string;
    query?: string;
    removeHeadersConfig?: outputs.ElbL7policyRedirectUrlConfigRemoveHeadersConfig;
    statusCode: string;
}

export interface ElbL7policyRedirectUrlConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyRedirectUrlConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyRedirectUrlConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyRedirectUrlConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7ruleCondition {
    key?: string;
    /**
     * The value to use for the comparison.
     */
    value: string;
}

export interface ElbListenerPortRange {
    endPort: number;
    startPort: number;
}

export interface ElbMemberReason {
    expectedResponse: string;
    healthcheckResponse: string;
    reasonCode: string;
}

export interface ElbMemberStatus {
    listenerId: string;
    operatingStatus: string;
    reasons: outputs.ElbMemberStatusReason[];
}

export interface ElbMemberStatusReason {
    expectedResponse: string;
    healthcheckResponse: string;
    reasonCode: string;
}

export interface ElbPoolPersistence {
    /**
     * The name of the cookie if persistence mode is set appropriately. Required
     * if `type = APP_COOKIE`.
     */
    cookieName?: string;
    /**
     * Specifies the sticky session timeout duration in minutes. This parameter is
     * invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
     * + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
     * + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
     */
    timeout: number;
    /**
     * The type of persistence mode. The current specification supports SOURCE_IP,
     * HTTP_COOKIE, and APP_COOKIE.
     */
    type: string;
}

export interface ElbSecurityPolicyListener {
    /**
     * The listener id.
     */
    id: string;
}

export interface FgsApplicationRepository {
    /**
     * The HTTP address of the repository.
     */
    httpsUrl: string;
    /**
     * The project ID of the repository.
     */
    projectId: string;
    /**
     * The repository status.
     */
    status: string;
    /**
     * The repository link.
     */
    webUrl: string;
}

export interface FgsApplicationStackResource {
    /**
     * The cloud service name.
     */
    displayName: string;
    /**
     * The hyperlink.
     */
    href: string;
    /**
     * The logical resource name.
     */
    logicalResourceName: string;
    /**
     * The logical resource type.
     */
    logicalResourceType: string;
    /**
     * The physical resource ID.
     */
    physicalResourceId: string;
    /**
     * The physical resource name.
     */
    physicalResourceName: string;
    /**
     * The status of resource.
     */
    resourceStatus: string;
    /**
     * The status information.
     */
    statusMessage: string;
}

export interface FgsAsyncInvokeConfigurationOnFailure {
    /**
     * Specifies the object type.  
     * The valid values are as follows:
     * + **OBS**
     * + **SMN**
     * + **DIS**
     * + **FunctionGraph**
     */
    destination: string;
    /**
     * Specifies the parameters (map object in JSON format) corresponding to the target service.
     * + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
     * expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
     * + The **SMN** objects include: `topicUrn`.
     * + The **DIS** objects include: `streamName`.
     * + The **FunctionGraph** objects include: `funcUrn` (function URN).
     *
     * > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
     * corresponding service.
     */
    param: string;
}

export interface FgsAsyncInvokeConfigurationOnSuccess {
    /**
     * Specifies the object type.  
     * The valid values are as follows:
     * + **OBS**
     * + **SMN**
     * + **DIS**
     * + **FunctionGraph**
     */
    destination: string;
    /**
     * Specifies the parameters (map object in JSON format) corresponding to the target service.
     * + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
     * expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
     * + The **SMN** objects include: `topicUrn`.
     * + The **DIS** objects include: `streamName`.
     * + The **FunctionGraph** objects include: `funcUrn` (function URN).
     *
     * > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
     * corresponding service.
     */
    param: string;
}

export interface GesGraphEncryption {
    /**
     * Whether to enable data encryption The value can be true or false. The default value is false.
     */
    enable: boolean;
    /**
     * ID of the customer master key created by DEW in the project corresponding to the graph creation.
     */
    masterKeyId: string;
}

export interface GesGraphLtsOperationTrace {
    /**
     * LTS log group name.
     */
    auditLogGroupName: string;
    /**
     * Whether to enable graph audit. The default value is false.
     */
    enableAudit: boolean;
}

export interface GesGraphPublicIp {
    /**
     * Indicates the ID of an EIP.  Changing this parameter will create a new resource.
     */
    eipId: string;
    /**
     * The bind type of public IP.
     */
    publicBindType: string;
}

export interface GesGraphVertexIdType {
    /**
     * The length of ID.
     */
    idLength: number;
    /**
     * Vertex ID type.
     */
    idType: string;
}

export interface GetApigAclPoliciesPolicy {
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The entity type of the ACL policy.
     */
    entityType: string;
    /**
     * The ID of the ACL policy.
     */
    id: string;
    /**
     * The name of the ACL policy.
     */
    name: string;
    /**
     * The type of the ACL policy.
     */
    type: string;
    /**
     * The latest update time of the policy.
     */
    updatedAt: string;
    /**
     * The value of the ACL policy.
     */
    value: string;
}

export interface GetApigApiAssociatedAclPoliciesPolicy {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the ACL policy is bound to the API.
     */
    bindTime: string;
    /**
     * The entity type of the ACL policy.
     */
    entityType: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the ACL policy.
     */
    id: string;
    /**
     * The name of the ACL policy.
     */
    name: string;
    /**
     * The type of the ACL policy.
     */
    type: string;
    /**
     * One or more objects from which the access will be controlled.
     */
    value: string;
}

export interface GetApigApiAssociatedApplicationsApplication {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the application is bound to the API.
     */
    bindTime: string;
    /**
     * The description of the application.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the application.
     */
    id: string;
    /**
     * The name of the application.
     */
    name: string;
}

export interface GetApigApiAssociatedPluginsPlugin {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the plugin is bound to the API.
     */
    bindTime: string;
    /**
     * The configuration details for the plugin.
     */
    content: string;
    /**
     * The description of the plugin.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the plugin.
     */
    id: string;
    /**
     * The name of the plugin.
     */
    name: string;
    /**
     * The type of the plugin.
     */
    type: string;
}

export interface GetApigApiAssociatedSignaturesSignature {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the signature is bound to the API.
     */
    bindTime: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the signature.
     */
    id: string;
    /**
     * The signature key.
     */
    key: string;
    /**
     * The name of the signature.
     */
    name: string;
    /**
     * The signature secret.
     */
    secret: string;
    /**
     * The type of the signature.
     */
    type: string;
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicy {
    /**
     * The array of one or more special throttling policies for APP limit.
     */
    appThrottles: outputs.GetApigApiAssociatedThrottlingPoliciesPolicyAppThrottle[];
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the throttling policy is bound to the API, in RFC3339 format.
     */
    bindTime: string;
    /**
     * The creation time of the throttling policy, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of the throttling policy.
     */
    description: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The maximum number of times the API can be accessed by an app within the same period.
     */
    maxAppRequests: number;
    /**
     * The maximum number of times the API can be accessed by an IP address within the same period.
     */
    maxIpRequests: number;
    /**
     * The maximum number of times the API can be accessed by a user within the same period.
     */
    maxUserRequests: number;
    /**
     * The name of the throttling policy.
     */
    name: string;
    /**
     * The period of time for limiting the number of API calls.
     */
    period: number;
    /**
     * The time unit for limiting the number of API calls.
     */
    periodUnit: string;
    /**
     * The type of the throttling policy.
     */
    type: string;
    /**
     * The array of one or more special throttling policies for IAM user limit.
     */
    userThrottles: outputs.GetApigApiAssociatedThrottlingPoliciesPolicyUserThrottle[];
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicyAppThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicyUserThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigApiBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiBasicConfigurationsConfiguration {
    /**
     * The ID of the authorizer to which the API request used.
     */
    authorizerId: string;
    /**
     * The backend type of the API.
     */
    backendType: string;
    /**
     * Whether CORS is supported.
     */
    cors: boolean;
    /**
     * The description of the API.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of group corresponding to the API.
     */
    groupId: string;
    /**
     * The name of group corresponding to the API.
     */
    groupName: string;
    /**
     * The version of group corresponding to the API.
     */
    groupVersion: string;
    /**
     * The ID of the API.
     */
    id: string;
    /**
     * The matching mode of the API.
     */
    matching: string;
    /**
     * The name of the API.
     */
    name: string;
    /**
     * The ID of publish corresponding to the API.
     */
    publishId: string;
    /**
     * The published time of the API, in RFC3339 format.
     */
    publishedAt: string;
    /**
     * The registered time of the API, in RFC3339 format.
     */
    registeredAt: string;
    /**
     * The request method of the API.
     */
    requestMethod: string;
    /**
     * The request address of the API.
     */
    requestPath: string;
    /**
     * The request protocol of the API.
     */
    requestProtocol: string;
    /**
     * The security authentication mode of the API request.
     */
    securityAuthentication: string;
    /**
     * Whether the authentication of the application code is enabled.
     */
    simpleAuthentication: boolean;
    /**
     * The list of tags configuration.
     */
    tags: string[];
    /**
     * The type of the API.
     */
    type: string;
    /**
     * The latest update time of the API, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigApiFuncGraph {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The ID of the FunctionGraph backend configuration.
     */
    id: string;
    /**
     * The invocation type.
     */
    invocationType: string;
    /**
     * The network architecture (framework) type of the FunctionGraph function.
     */
    networkType: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The version of the FunctionGraph function.
     */
    version: string;
}

export interface GetApigApiFuncGraphPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The configaiton list of the backend parameters.
     */
    backendParams: outputs.GetApigApiFuncGraphPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiFuncGraphPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The ID of the FunctionGraph backend policy.
     */
    id: string;
    /**
     * The invocation mode of the FunctionGraph function.
     */
    invocationType: string;
    /**
     * The name of the backend policy.
     */
    name: string;
    /**
     * The network (framework) type of the FunctionGraph function.
     */
    networkType: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The version of the FunctionGraph function.
     */
    version: string;
}

export interface GetApigApiFuncGraphPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiFuncGraphPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigApiMock {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The ID of the mock backend configuration.
     */
    id: string;
    /**
     * The response of the mock backend configuration.
     */
    response: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface GetApigApiMockPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The configuration list of backend parameters.
     */
    backendParams: outputs.GetApigApiMockPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiMockPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The ID of the mock backend policy.
     */
    id: string;
    /**
     * The backend policy name.
     */
    name: string;
    /**
     * The response of the backend policy.
     */
    response: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface GetApigApiMockPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiMockPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigApiRequestParam {
    /**
     * The default value of the parameter.
     */
    default: string;
    /**
     * The parameter description.
     */
    description: string;
    /**
     * The enumerated value.
     */
    enumeration: string;
    /**
     * The parameter example.
     */
    example: string;
    /**
     * The ID of the request parameter.
     */
    id: string;
    /**
     * Where this parameter is located.
     */
    location: string;
    /**
     * The maximum value or length (string parameter) for parameter.
     */
    maximum: number;
    /**
     * The minimum value or length (string parameter) for parameter.
     */
    minimum: number;
    /**
     * The name of the request parameter.
     */
    name: string;
    /**
     * Whether to transparently transfer the parameter.
     */
    passthrough: boolean;
    /**
     * Whether this parameter is required.
     */
    required: boolean;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * Whether to enable the parameter validation.
     */
    validEnable: number;
}

export interface GetApigApiWeb {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The backend service address.
     */
    backendAddress: string;
    /**
     * The proxy host header.
     */
    hostHeader: string;
    /**
     * The ID of the backend configuration.
     */
    id: string;
    /**
     * The backend request path.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod: string;
    /**
     * The web protocol type of the API request.
     */
    requestProtocol: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount: number;
    /**
     * Whether to enable two-way authentication.
     */
    sslEnable: boolean;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId: string;
}

export interface GetApigApiWebPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The backend service address
     */
    backendAddress: string;
    /**
     * The configuration list of the backend parameters.
     */
    backendParams: outputs.GetApigApiWebPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiWebPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The proxy host header.
     */
    hostHeader: string;
    /**
     * The ID of the web policy.
     */
    id: string;
    /**
     * The name of the web policy.
     */
    name: string;
    /**
     * The backend request address.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod: string;
    /**
     * The backend request protocol.
     */
    requestProtocol: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount: number;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId: string;
}

export interface GetApigApiWebPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiWebPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigAppcodesAppcode {
    /**
     * The ID of the application.
     */
    applicationId: string;
    /**
     * The creation time of the APPCODE, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The ID of the APPCODE.
     */
    id: string;
    /**
     * The APPCODE value (content).
     */
    value: string;
}

export interface GetApigApplicationQuotasQuota {
    /**
     * The number of applications bound to the quota policy.
     */
    boundAppNum: number;
    /**
     * The maximum number of times a application quota can be called.
     */
    callLimits: number;
    /**
     * The creation time of the application quota, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of the application quota.
     */
    description: string;
    /**
     * The ID of the application quota.
     */
    id: string;
    /**
     * The name of the application quota.
     */
    name: string;
    /**
     * The time limit of a quota.
     */
    timeInterval: number;
    /**
     * The time unit.
     */
    timeUnit: string;
}

export interface GetApigApplicationsApplication {
    /**
     * The key of the application.
     */
    appKey: string;
    /**
     * The secret of the application.
     */
    appSecret: string;
    /**
     * The type of the application.
     */
    appType: string;
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The creation time of the application.
     */
    createdAt: string;
    /**
     * The creator of the application.
     */
    createdBy: string;
    /**
     * The description of the application.
     */
    description: string;
    /**
     * The ID of the application.
     */
    id: string;
    /**
     * The name of the application.
     */
    name: string;
    /**
     * The status of the application.
     */
    status: number;
    /**
     * The latest update time of the application.
     */
    updatedAt: string;
}

export interface GetApigChannelsVpcChannel {
    /**
     * The distribution algorithm.
     */
    balanceStrategy: number;
    /**
     * The creation time of channel, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The ID of the VPC channel.
     */
    id: string;
    /**
     * The parameter member groups of the VPC channels.
     */
    memberGroups: outputs.GetApigChannelsVpcChannelMemberGroup[];
    /**
     * The member type of the VPC channel.
     */
    memberType: string;
    /**
     * The name of the VPC channel.
     */
    name: string;
    /**
     * The port of the backend server.
     */
    port: number;
    /**
     * The type of the VPC channel.
     */
    type: number;
}

export interface GetApigChannelsVpcChannelMemberGroup {
    /**
     * The description of the member group.
     */
    description: string;
    /**
     * The ID of the member group.
     */
    id: string;
    /**
     * The microservice tags of the backend server group.
     */
    microserviceLabels: outputs.GetApigChannelsVpcChannelMemberGroupMicroserviceLabel[];
    /**
     * The microservice port of the backend server group.
     */
    microservicePort: number;
    /**
     * The microservice version of the backend server group.
     */
    microserviceVersion: string;
    /**
     * The name of the member group.
     */
    name: string;
    /**
     * The weight of the current member group.
     */
    weight: number;
}

export interface GetApigChannelsVpcChannelMemberGroupMicroserviceLabel {
    /**
     * The name of the microservice label.
     */
    name: string;
    /**
     * The value of the microservice label.
     */
    value: string;
}

export interface GetApigCustomAuthorizersAuthorizer {
    /**
     * The maximum cache age of custom authorizer.
     */
    cacheAge: number;
    /**
     * The creation time of custom authorizer.
     */
    createdAt: string;
    /**
     * The version alias URI of the FGS function.
     */
    functionAliasUri: string;
    /**
     * The type of the FGS function.
     */
    functionType: string;
    /**
     * The URN of the FGS function.
     */
    functionUrn: string;
    /**
     * The version of the FGS function.
     */
    functionVersion: string;
    /**
     * The ID of the custom authorizer.
     */
    id: string;
    /**
     * The parameter identities of the custom authorizer.
     */
    identities: outputs.GetApigCustomAuthorizersAuthorizerIdentity[];
    /**
     * Whether to send the body of custom authorizer.
     */
    isBodySend: boolean;
    /**
     * The name of the custom authorizer.
     */
    name: string;
    /**
     * The network architecture types of function.
     */
    networkType: string;
    /**
     * The type of the custom authorizer.
     */
    type: string;
    /**
     * The user data of custom authorizer.
     */
    userData: string;
}

export interface GetApigCustomAuthorizersAuthorizerIdentity {
    /**
     * The parameter location of identity.
     */
    location: string;
    /**
     * The name of the parameter to be verified.
     */
    name: string;
    /**
     * The parameter verification expression of identity.
     */
    validation: string;
}

export interface GetApigEndpointConnectionsConnection {
    /**
     * The creation time of the endpoint connection, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The IAM account ID of the endpoint connection creator.
     */
    domainId: string;
    /**
     * The ID of the endpoint connection.
     */
    id: string;
    /**
     * The packet ID of the endpoint connection.
     */
    packetId: number;
    /**
     * The current status of the endpoint connection.
     */
    status: string;
    /**
     * The latest time of the endpoint connection, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigEnvironmentVariablesVariable {
    /**
     * The environment ID corresponding to the environment variable.
     */
    envId: string;
    /**
     * The group ID corresponding to the environment variable.
     */
    groupId: string;
    /**
     * The ID of the environment variable.
     */
    id: string;
    /**
     * The name of the environment variable.
     */
    name: string;
    /**
     * The value of the environment variable.
     */
    value: string;
}

export interface GetApigGroupsGroup {
    createdAt: string;
    description: string;
    /**
     * The array of one or more environments of the associated group.
     */
    environments: outputs.GetApigGroupsGroupEnvironment[];
    id: string;
    isDefault: number;
    name: string;
    onSellStatus: number;
    slDomain: string;
    slDomains: string[];
    status: number;
    updatedAt: string;
    urlDomains: outputs.GetApigGroupsGroupUrlDomain[];
}

export interface GetApigGroupsGroupEnvironment {
    /**
     * The ID of the environment to which the variables belongs.
     */
    environmentId: string;
    /**
     * The array of one or more environment variables.
     */
    variables: outputs.GetApigGroupsGroupEnvironmentVariable[];
}

export interface GetApigGroupsGroupEnvironmentVariable {
    /**
     * The ID of the variable that the group has.
     */
    id: string;
    /**
     * The variable name.
     */
    name: string;
    /**
     * The variable value.
     */
    value: string;
}

export interface GetApigGroupsGroupUrlDomain {
    cnameStatus: number;
    id: string;
    isHasTrustedRootCa: boolean;
    minSslVersion: string;
    name: string;
    sslId: string;
    sslName: string;
    verifiedClientCertificateEnabled: boolean;
}

export interface GetApigInstanceFeaturesFeature {
    /**
     * The detailed configuration of the instance feature.
     */
    config: string;
    /**
     * Whether the feature is enabled.
     */
    enabled: boolean;
    /**
     * The ID of the feature.
     */
    id: string;
    /**
     * The name of the feature.
     */
    name: string;
    /**
     * The latest update time of the feature, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigInstancesInstance {
    /**
     * The creation time of the instance, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The edition of instance.
     */
    edition: string;
    /**
     * The elastic IP address of instance binding.
     */
    eipAddress: string;
    /**
     * The enterprise project ID of the instance.
     */
    enterpriseProjectId: string;
    /**
     * The ID of instance.
     */
    id: string;
    /**
     * The type of load balancer used by the instance.
     */
    loadbalancerProvider: string;
    /**
     * The name of instance.
     */
    name: string;
    /**
     * The status of instance.
     */
    status: string;
    /**
     * The type of instance.
     */
    type: string;
}

export interface GetApigSignaturesSignature {
    /**
     * The algorithm of the signature.
     */
    algorithm: string;
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The creation time of the signature.
     */
    createdAt: string;
    /**
     * The ID of the signature.
     */
    id: string;
    /**
     * The key of the signature.
     */
    key: string;
    /**
     * The name of the signature.
     */
    name: string;
    /**
     * The secret of the signature.
     */
    secret: string;
    /**
     * The type of the signature.
     */
    type: string;
    /**
     * The latest update time of the signature.
     */
    updatedAt: string;
}

export interface GetApigThrottlingPoliciesPolicy {
    /**
     * The array of one or more special throttling policies for APP limit.
     */
    appThrottles: outputs.GetApigThrottlingPoliciesPolicyAppThrottle[];
    /**
     * The number of APIs bound to the throttling policy.
     */
    bindNum: number;
    /**
     * The creation time of the throttling policy, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of throttling policy.
     */
    description: string;
    /**
     * The ID of the throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The maximum number of times the API can be accessed by an app within the same period.
     */
    maxAppRequests: number;
    /**
     * The maximum number of times the API can be accessed by an IP address within the same period.
     */
    maxIpRequests: number;
    /**
     * The maximum number of times the API can be accessed by a user within the same period.
     */
    maxUserRequests: number;
    /**
     * The name of the throttling policy.
     */
    name: string;
    /**
     * The period of time for limiting the number of API calls.
     */
    period: number;
    /**
     * The time unit for limiting the number of API calls.
     */
    periodUnit: string;
    /**
     * The type of the throttling policy.
     */
    type: string;
    /**
     * The array of one or more special throttling policies for IAM user limit.
     */
    userThrottles: outputs.GetApigThrottlingPoliciesPolicyUserThrottle[];
}

export interface GetApigThrottlingPoliciesPolicyAppThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigThrottlingPoliciesPolicyUserThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetCbhAvailabilityZonesAvailabilityZone {
    /**
     * Specifies the display name of the availability zone to be queried.
     */
    displayName: string;
    /**
     * Specifies the name of the availability zone to be queried.
     */
    name: string;
    /**
     * The ID of the region in which the availability zone belongs.
     */
    regionId: string;
    /**
     * The status of the availability zone. The value can be **Running**.
     */
    status: string;
    /**
     * The type of the availability zone. The valid values are as follows:
     * + **Core**: Core availability zone.
     * + **Dedicated**: Exclusive availability zone, only open to internal customers.
     */
    type: string;
}

export interface GetCbhFlavorsFlavor {
    /**
     * Specifies the number of CBH assets.
     */
    asset: number;
    /**
     * The size of the CBH data disk, in TB.
     */
    dataDiskSize: number;
    /**
     * The disk size of the CBH system disk, in GB.
     */
    ecsSystemDataSize: number;
    /**
     * Indicates the ID of the specification.
     */
    id: string;
    /**
     * Specifies the maximum number of connections to the CBH.
     */
    maxConnection: number;
    /**
     * Specifies the memory size of the CBH, in GB.
     */
    memory: number;
    /**
     * Specifies the type of CBH specification. The value can be:
     * + **basic**: Standard version.
     * + **enhance**: Professional version.
     */
    type: string;
    /**
     * Specifies the number of CPU cores of the CBH.
     */
    vcpus: number;
}

export interface GetCbhInstancesInstance {
    /**
     * Indicates the availability zone name.
     */
    availabilityZone: string;
    /**
     * Specifies the specification of the instance.
     */
    flavorId: string;
    /**
     * Indicates the ID of the instance.
     */
    id: string;
    /**
     * Specifies the instance name.
     */
    name: string;
    /**
     * Indicates the private IP address of the instance.
     */
    privateIp: string;
    /**
     * Indicates the elastic IP address.
     */
    publicIp: string;
    /**
     * Indicates the ID of the elastic IP.
     */
    publicIpId: string;
    /**
     * Specifies the ID of a security group.
     */
    securityGroupId: string;
    /**
     * Indicates the status of the instance.
     */
    status: string;
    /**
     * Specifies the ID of a subnet.
     */
    subnetId: string;
    /**
     * Specifies the current version of the instance image.
     */
    version: string;
    /**
     * Specifies the ID of a VPC.
     */
    vpcId: string;
}

export interface GetCbrBackupChildren {
    /**
     * The restore point ID of the sub-backup resource.
     */
    checkpointId: string;
    /**
     * The creation time of the sub-backup.
     */
    createdAt: string;
    /**
     * The sub-backup description.
     */
    description: string;
    /**
     * The enterprise project to which the backup sub-backup resource belongs.
     */
    enterpriseProjectId: string;
    /**
     * The expiration time of the sub-backup.
     */
    expiredAt: string;
    /**
     * The extended information.
     */
    extendInfos: outputs.GetCbrBackupChildrenExtendInfo[];
    /**
     * Specifies the backup ID.
     */
    id: string;
    /**
     * The sub-backup name.
     */
    name: string;
    /**
     * The replication records.
     */
    replicationRecords: outputs.GetCbrBackupChildrenReplicationRecord[];
    /**
     * The availability zone where the backup sub-backup resource is located.
     */
    resourceAz: string;
    /**
     * The sub-backup resource ID.
     */
    resourceId: string;
    /**
     * The sub-backup resource name.
     */
    resourceName: string;
    /**
     * The sub-backup resource size, in GB.
     */
    resourceSize: number;
    /**
     * The sub-backup resource type.
     */
    resourceType: string;
    /**
     * The sub-backup status.
     */
    status: string;
    /**
     * The sub-backup type.
     */
    type: string;
    /**
     * The latest update time of the sub-backup.
     */
    updatedAt: string;
    /**
     * The vault to which the backup resource belongs.
     */
    vaultId: string;
}

export interface GetCbrBackupChildrenExtendInfo {
    /**
     * Whether the backup is automatically generated.
     */
    autoTrigger: boolean;
    /**
     * Whether the backup is a system disk backup.
     */
    bootable: boolean;
    /**
     * Whether the VM backup data contains system disk data.
     */
    containSystemDisk: boolean;
    /**
     * Whether the backup is encrypted.
     */
    encrypted: boolean;
    /**
     * Whether the backup is an incremental backup.
     */
    incremental: boolean;
    /**
     * Whether the disk is a system disk.
     */
    isSystemDisk: boolean;
    /**
     * The ID list of images created using backups.
     */
    osRegistryImages: string[];
    /**
     * Snapshot ID of the disk backup.
     */
    snapshotId: string;
    /**
     * Whether to allow lazyloading for fast restoration.
     */
    supportLld: boolean;
    /**
     * The restoration mode.
     */
    supportedRestoreMode: string;
}

export interface GetCbrBackupChildrenReplicationRecord {
    /**
     * The creation time of the sub-backup.
     */
    createdAt: string;
    /**
     * The ID of the destination backup used for replication.
     */
    destinationBackupId: string;
    /**
     * The record ID of the destination backup used for replication.
     */
    destinationCheckpointId: string;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The replication destination region.
     */
    destinationRegion: string;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The additional information of the replication.
     * The object structure is documented below.
     */
    extraInfos: outputs.GetCbrBackupChildrenReplicationRecordExtraInfo[];
    /**
     * Specifies the backup ID.
     */
    id: string;
    /**
     * The ID of the source backup used for replication.
     */
    sourceBackupId: string;
    /**
     * The ID of the source backup record used for replication.
     */
    sourceCheckpointId: string;
    /**
     * The ID of the replication source project.
     */
    sourceProjectId: string;
    /**
     * The replication source region.
     */
    sourceRegion: string;
    /**
     * The sub-backup status.
     */
    status: string;
    /**
     * The vault to which the backup resource belongs.
     */
    vaultId: string;
}

export interface GetCbrBackupChildrenReplicationRecordExtraInfo {
    /**
     * Whether the backup is automatically generated.
     */
    autoTrigger: boolean;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The error code.
     */
    failCode: string;
    /**
     * The error cause.
     */
    failReason: string;
    /**
     * The replication progress.
     */
    progress: number;
}

export interface GetCbrBackupExtendInfo {
    /**
     * Whether the backup is automatically generated.
     */
    autoTrigger: boolean;
    /**
     * Whether the backup is a system disk backup.
     */
    bootable: boolean;
    /**
     * Whether the VM backup data contains system disk data.
     */
    containSystemDisk: boolean;
    /**
     * Whether the backup is encrypted.
     */
    encrypted: boolean;
    /**
     * Whether the backup is an incremental backup.
     */
    incremental: boolean;
    /**
     * Whether the disk is a system disk.
     */
    isSystemDisk: boolean;
    /**
     * The ID list of images created using backups.
     */
    osRegistryImages: string[];
    /**
     * Snapshot ID of the disk backup.
     */
    snapshotId: string;
    /**
     * Whether to allow lazyloading for fast restoration.
     */
    supportLld: boolean;
    /**
     * The restoration mode.
     */
    supportedRestoreMode: string;
}

export interface GetCbrBackupReplicationRecord {
    /**
     * The creation time of the sub-backup.
     */
    createdAt: string;
    /**
     * The ID of the destination backup used for replication.
     */
    destinationBackupId: string;
    /**
     * The record ID of the destination backup used for replication.
     */
    destinationCheckpointId: string;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The replication destination region.
     */
    destinationRegion: string;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The additional information of the replication.
     * The object structure is documented below.
     */
    extraInfos: outputs.GetCbrBackupReplicationRecordExtraInfo[];
    /**
     * Specifies the backup ID.
     */
    id: string;
    /**
     * The ID of the source backup used for replication.
     */
    sourceBackupId: string;
    /**
     * The ID of the source backup record used for replication.
     */
    sourceCheckpointId: string;
    /**
     * The ID of the replication source project.
     */
    sourceProjectId: string;
    /**
     * The replication source region.
     */
    sourceRegion: string;
    /**
     * The sub-backup status.
     */
    status: string;
    /**
     * The vault to which the backup resource belongs.
     */
    vaultId: string;
}

export interface GetCbrBackupReplicationRecordExtraInfo {
    /**
     * Whether the backup is automatically generated.
     */
    autoTrigger: boolean;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The error code.
     */
    failCode: string;
    /**
     * The error cause.
     */
    failReason: string;
    /**
     * The replication progress.
     */
    progress: number;
}

export interface GetCbrPoliciesPolicy {
    /**
     * The vault associated with the CBR policy.
     * The associatedVaults structure is documented below.
     */
    associatedVaults: outputs.GetCbrPoliciesPolicyAssociatedVault[];
    /**
     * The scheduling rule for the policy backup execution.
     * The backupCycle structure is documented below.
     */
    backupCycles: outputs.GetCbrPoliciesPolicyBackupCycle[];
    /**
     * The maximum number of retained backups. The value ranges from `2` to `99,999`.
     * This parameter and `timePeriod` are alternative.
     */
    backupQuantity: number;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The name of the replication destination region.
     */
    destinationRegion: string;
    /**
     * Whether to enable the acceleration function to shorten the replication time for cross-region.
     * The valid values are as follows:
     * + **true**: Enabled acceleration
     * + **false**: Not enabled acceleration
     */
    enableAcceleration: boolean;
    /**
     * Specifies the policy enabling status to query. The valid values are as follows:
     * + **true**: Policy enabled
     * + **false**: Policy not enabled
     */
    enabled: boolean;
    /**
     * The policy ID.
     */
    id: string;
    /**
     * The long-term retention rules, which is an advanced options of the `backupQuantity`.
     * The longTermRetention structure is documented below.
     */
    longTermRetentions: outputs.GetCbrPoliciesPolicyLongTermRetention[];
    /**
     * Specifies the policy name used to query.
     */
    name: string;
    /**
     * The duration (in days) for retained backups. The value ranges from `2` to `99,999`.
     */
    timePeriod: number;
    /**
     * The UTC time zone, e.g. `UTC+08:00`. Only available when `longTermRetention` is set.
     */
    timeZone: string;
    /**
     * Specifies the policy type used to query. The valid values are as follows:
     * + **backup**: Backup policy
     * + **replication**: Replication policy
     */
    type: string;
}

export interface GetCbrPoliciesPolicyAssociatedVault {
    /**
     * The destination vault ID associated with CBR policy.
     */
    destinationVaultId: string;
    /**
     * Specifies the vault ID of the associated policy used to query.
     */
    vaultId: string;
}

export interface GetCbrPoliciesPolicyBackupCycle {
    /**
     * The weekly backup day of backup schedule. It supports seven days a week (MO, TU, WE, TH, FR, SA, SU)
     * and this parameter is separated by a comma (,) without spaces between the date and date.
     */
    days: string;
    /**
     * The backup time. Automated backups will be triggered at the backup
     * time. The current time is in the UTC format (HH:MM).
     */
    executionTimes: string[];
    /**
     * The interval (in days) of backup schedule. The value range is `1` to `30`.
     */
    interval: number;
}

export interface GetCbrPoliciesPolicyLongTermRetention {
    /**
     * The latest backup of each day is saved in the long term.
     */
    daily: number;
    /**
     * How often (after how many incremental backups) a full backup is performed.
     * The valid value ranges from `-1` to `100`. If `-1` is specified, full backup will not be performed.
     */
    fullBackupInterval: number;
    /**
     * The latest backup of each month is saved in the long term.
     */
    monthly: number;
    /**
     * The latest backup of each week is saved in the long term.
     */
    weekly: number;
    /**
     * The latest backup of each year is saved in the long term.
     */
    yearly: number;
}

export interface GetCdmFlavorsFlavor {
    cpu: string;
    /**
     * The id of the cdm flavor.
     */
    id: string;
    memory: string;
    /**
     * The name of the cdm flavor.
     */
    name: string;
}

export interface GetDcsAccountsAccount {
    /**
     * Account name.
     */
    accountName: string;
    /**
     * Account permissions.
     */
    accountRole: string;
    /**
     * Account type.
     */
    accountType: string;
    /**
     * Account description.
     */
    description: string;
    /**
     * Account ID.
     */
    id: string;
    /**
     * Account status.
     */
    status: string;
}

export interface GetDmsKafkaConsumerGroupsGroup {
    /**
     * Indicates the partition assignment strategy.
     */
    assignmentStrategy: string;
    /**
     * Specifies the coordinator ID.
     */
    coordinatorId: number;
    /**
     * Indicates the create time.
     */
    createdAt: string;
    /**
     * Specifies the group description.
     */
    description: string;
    /**
     * Indicates the group message offsets.
     */
    groupMessageOffsets: outputs.GetDmsKafkaConsumerGroupsGroupGroupMessageOffset[];
    /**
     * Specifies the number of accumulated messages.
     */
    lag: number;
    /**
     * Indicates the consumer group members
     */
    members: outputs.GetDmsKafkaConsumerGroupsGroupMember[];
    /**
     * Specifies the group name.
     */
    name: string;
    /**
     * Specifies the consumer group status.
     */
    state: string;
}

export interface GetDmsKafkaConsumerGroupsGroupGroupMessageOffset {
    /**
     * Specifies the number of accumulated messages.
     */
    lag: number;
    /**
     * Indicates the message current offset.
     */
    messageCurrentOffset: number;
    /**
     * Indicates the message log end offset.
     */
    messageLogEndOffset: number;
    /**
     * Indicates the partition.
     */
    partition: number;
    /**
     * Indicates the topic name.
     */
    topic: string;
}

export interface GetDmsKafkaConsumerGroupsGroupMember {
    /**
     * Indicates the details about the partition assigned to the consumer.
     */
    assignments: outputs.GetDmsKafkaConsumerGroupsGroupMemberAssignment[];
    /**
     * Indicates the client ID.
     */
    clientId: string;
    /**
     * Indicates the consumer address.
     */
    host: string;
    /**
     * Indicates the member ID.
     */
    memberId: string;
}

export interface GetDmsKafkaConsumerGroupsGroupMemberAssignment {
    /**
     * Indicates the partitions.
     */
    partitions: number[];
    /**
     * Indicates the topic name.
     */
    topic: string;
}

export interface GetDmsKafkaMessagesMessage {
    /**
     * Indicates the application ID.
     */
    appId: string;
    /**
     * Indicates the big data flag.
     */
    hugeMessage: boolean;
    /**
     * Indicates the message key.
     */
    key: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
    /**
     * Specifies the message offset.
     * This parameter is mandatory when you query the message content by offset.
     */
    messageOffset: number;
    /**
     * Specifies the partition.
     * This parameter is mandatory when you query the message content by offset.
     */
    partition: number;
    /**
     * Indicates the message size.
     */
    size: number;
    /**
     * Indicates the message label.
     */
    tag: string;
    /**
     * Indicates the message production time.
     */
    timestamp: string;
    /**
     * Indicates the message content.
     */
    value: string;
}

export interface GetDmsKafkaUsersUser {
    /**
     * Indicates the create time.
     */
    createdAt: string;
    /**
     * Indicates whether the application is the default application.
     */
    defaultApp: boolean;
    /**
     * Specifies the user description.
     */
    description: string;
    /**
     * Specifies the user name.
     */
    name: string;
    /**
     * Indicates the user role.
     */
    role: string;
}

export interface GetDmsRabbitmqFlavorsFlavor {
    /**
     * Indicates the list of supported CPU architectures.
     */
    archTypes: string[];
    /**
     * Indicates the list of supported billing modes.
     */
    chargingModes: string[];
    /**
     * Indicates the flavor ID.
     */
    id: string;
    /**
     * Indicates the list of supported disk IO types.
     * The object structure is documented below.
     */
    ios: outputs.GetDmsRabbitmqFlavorsFlavorIo[];
    /**
     * Indicates the function property details.
     * The object structure is documented below.
     */
    properties: outputs.GetDmsRabbitmqFlavorsFlavorProperty[];
    /**
     * Indicates the list of features supported by the current specification.
     * The object structure is documented below.
     */
    supportFeatures: outputs.GetDmsRabbitmqFlavorsFlavorSupportFeature[];
    /**
     * Specifies flavor type. The valid values are **single** and **cluster**.
     */
    type: string;
    /**
     * Indicates the underlying VM specification.
     */
    vmSpecification: string;
}

export interface GetDmsRabbitmqFlavorsFlavorIo {
    /**
     * Specifies the list of availability zones with available resources.
     */
    availabilityZones: string[];
    /**
     * Specifies the disk IO encoding.
     * + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
     * + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
     */
    storageSpecCode: string;
    /**
     * Specifies flavor type. The valid values are **single** and **cluster**.
     */
    type: string;
    /**
     * Indicates the list of unavailability zones with available resources.
     */
    unavailabilityZones: string[];
}

export interface GetDmsRabbitmqFlavorsFlavorProperty {
    /**
     * Indicates the flavor ID alias.
     */
    flavorAlias: string;
    /**
     * Indicates the maximum bandwidth per broker.
     */
    maxBandwidthPerBroker: number;
    /**
     * Indicates the maximum number of brokers.
     */
    maxBroker: number;
    /**
     * Indicates the maximum number of consumers per broker.
     */
    maxConsumerPerBroker: number;
    /**
     * Indicates the maximum number of partitions per broker.
     */
    maxPartitionPerBroker: number;
    /**
     * Indicates the maximum storage per node. The unit is GB.
     */
    maxStoragePerNode: number;
    /**
     * Indicates the maximum TPS per broker.
     */
    maxTpsPerBroker: number;
    /**
     * Indicates the minimum number of brokers.
     */
    minBroker: number;
    /**
     * Indicates the minimum storage per node. The unit is GB.
     */
    minStoragePerNode: number;
}

export interface GetDmsRabbitmqFlavorsFlavorSupportFeature {
    /**
     * Indicates the function name, e.g. **connector_obs**.
     */
    name: string;
    /**
     * Indicates the function property details.
     * The object structure is documented below.
     */
    properties: outputs.GetDmsRabbitmqFlavorsFlavorSupportFeatureProperty[];
}

export interface GetDmsRabbitmqFlavorsFlavorSupportFeatureProperty {
    /**
     * Indicates the maximum number of nodes for the dump function.
     */
    maxNode: number;
    /**
     * Indicates the maximum number of tasks for the dump function.
     */
    maxTask: number;
    /**
     * Indicates the minimum number of nodes for the dump function.
     */
    minNode: number;
    /**
     * Indicates the minimum number of tasks for the dump function.
     */
    minTask: number;
}

export interface GetDmsRocketmqConsumerGroupAccessUsersPolicy {
    /**
     * Indicates the user name.
     */
    accessKey: string;
    /**
     * Indicates whether the user is an administrator.
     */
    admin: boolean;
    /**
     * Indicates the permissions.
     */
    perm: string;
    /**
     * Indicates the IP address whitelist.
     */
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqConsumerGroupsGroup {
    /**
     * Specifies whether to broadcast the consumer group. Defaults to **false**.
     */
    broadcast: boolean;
    /**
     * Indicates the list of associated brokers of the consumer group.
     */
    brokers: string[];
    /**
     * Indicates the description of the consumer group.
     */
    description: string;
    /**
     * Specifies the consumer group is enabled or not. Defaults to **true**.
     */
    enabled: boolean;
    /**
     * Specifies the name of the consumer group.
     */
    name: string;
    /**
     * Specifies the maximum number of retry times.
     */
    retryMaxTimes: number;
}

export interface GetDmsRocketmqConsumersClient {
    /**
     * Indicates the client address.
     */
    clientAddress: string;
    /**
     * Indicates the client ID.
     */
    clientId: string;
    /**
     * Indicates the client language.
     */
    language: string;
    /**
     * Indicates the subscription list.
     */
    subscriptions: outputs.GetDmsRocketmqConsumersClientSubscription[];
    /**
     * Indicates the client version.
     */
    version: string;
}

export interface GetDmsRocketmqConsumersClientSubscription {
    /**
     * Indicates the subscription tag.
     */
    expression: string;
    /**
     * Indicates the name of the subscribed topic.
     */
    topic: string;
    /**
     * Indicates the subscription type. The value can be **TAG** and **SQL92**.
     */
    type: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavor {
    /**
     * Indicates the list of supported CPU architectures.
     */
    archTypes: string[];
    /**
     * Indicates the list of availability zones with available resources.
     */
    availableZones: string[];
    /**
     * Indicates the billing code.
     */
    billingCode: string;
    /**
     * Indicates the list of supported billing modes.
     */
    chargingModes: string[];
    /**
     * Indicates the flavor ID.
     */
    id: string;
    /**
     * Indicates the list of supported disk IO types.
     */
    ios: outputs.GetDmsRocketmqExtendFlavorsFlavorIo[];
    /**
     * Indicates the key-value pair of a feature.
     */
    properties: outputs.GetDmsRocketmqExtendFlavorsFlavorProperty[];
    /**
     * Indicates the supported features.
     */
    supportFeatures: outputs.GetDmsRocketmqExtendFlavorsFlavorSupportFeature[];
    /**
     * Specifies the flavor type.
     */
    type: string;
    /**
     * Indicates the list of unavailability zones with available resources.
     */
    unavailableZones: string[];
    /**
     * Indicates the underlying VM specification.
     */
    vmSpecification: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavorIo {
    /**
     * Indicates the list of availability zones with available resources.
     */
    availableZones: string[];
    /**
     * Specifies the disk IO encoding, e.g. **dms.physical.storage.high.v2**.
     */
    storageSpecCode: string;
    /**
     * Specifies the flavor type.
     */
    type: string;
    /**
     * Indicates the list of unavailability zones with available resources.
     */
    unavailableZones: string[];
}

export interface GetDmsRocketmqExtendFlavorsFlavorProperty {
    /**
     * Indicates the version of the message engine.
     */
    engineVersions: string;
    /**
     * Indicates the alias of **flavor_id**.
     */
    flavorAlias: string;
    /**
     * Indicates the maximum number of brokers.
     */
    maxBroker: string;
    /**
     * Indicates the maximum number of consumers of each broker.
     */
    maxConsumerPerBroker: string;
    /**
     * Indicates the maximum storage space of each broker. Unit: GB.
     */
    maxStoragePerNode: string;
    /**
     * Indicates the maximum number of topics that can be created on each broker.
     */
    maxTopicPerBroker: string;
    /**
     * Indicates the minimum number of brokers.
     */
    minBroker: string;
    /**
     * Indicates the minimum storage space of each broker. Unit: GB.
     */
    minStoragePerNode: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavorSupportFeature {
    /**
     * Indicates the feature name.
     */
    name: string;
    /**
     * Indicates the key-value pair of a feature.
     */
    properties: {[key: string]: string};
}

export interface GetDmsRocketmqFlavorsFlavor {
    /**
     * Indicates the list of the types of CPU architecture.
     */
    archTypes: string[];
    /**
     * Indicates the list of the billing modes.
     */
    chargingModes: string[];
    /**
     * Indicates the ID of the flavor.
     */
    id: string;
    /**
     * Indicates the list of disk IO types.
     * The ios structure is documented below.
     */
    ios: outputs.GetDmsRocketmqFlavorsFlavorIo[];
    /**
     * Indicates the list of the function property details.
     * The properties structure is documented below.
     */
    properties: outputs.GetDmsRocketmqFlavorsFlavorProperty[];
    /**
     * Indicates the list of features supported by the current specification.
     * The supportFeatures structure is documented below.
     */
    supportFeatures: outputs.GetDmsRocketmqFlavorsFlavorSupportFeature[];
    /**
     * Specifies the type of the flavor. Value options: **single** and **cluster**.
     */
    type: string;
    /**
     * Indicates the underlying VM specification, e.g. **c6.large.2**
     */
    vmSpecification: string;
}

export interface GetDmsRocketmqFlavorsFlavorIo {
    /**
     * Specifies the list of availability zone names.
     */
    availabilityZones: string[];
    /**
     * Specifies the disk IO encoding.
     * Value options:
     * + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
     * + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
     */
    storageSpecCode: string;
    /**
     * Specifies the type of the flavor. Value options: **single** and **cluster**.
     */
    type: string;
    /**
     * Indicates the list of unavailability zone names.
     */
    unavailabilityZones: string[];
}

export interface GetDmsRocketmqFlavorsFlavorProperty {
    /**
     * Indicates the alias of the flavor.
     */
    flavorAlias: string;
    /**
     * Indicates the maximum bandwidth per broker.
     */
    maxBandwidthPerBroker: number;
    /**
     * Indicates the maximum number of brokers.
     */
    maxBroker: number;
    /**
     * Indicates the maximum number of consumers per broker.
     */
    maxConsumerPerBroker: number;
    /**
     * Indicates the maximum number of partitions per broker.
     */
    maxPartitionPerBroker: number;
    /**
     * Indicates the maximum storage per node. The unit is GB.
     */
    maxStoragePerNode: number;
    /**
     * Indicates the maximum TPS per broker.
     */
    maxTpsPerBroker: number;
    /**
     * Indicates the minimum number of brokers.
     */
    minBroker: number;
    /**
     * Indicates the minimum storage per node. The unit is GB.
     */
    minStoragePerNode: number;
}

export interface GetDmsRocketmqFlavorsFlavorSupportFeature {
    /**
     * Indicates the function name, e.g. **connector_obs**.
     */
    name: string;
    /**
     * Indicates the list of the function property details.
     * The properties structure is documented below.
     */
    properties: outputs.GetDmsRocketmqFlavorsFlavorSupportFeatureProperty[];
}

export interface GetDmsRocketmqFlavorsFlavorSupportFeatureProperty {
    /**
     * Indicates the maximum number of nodes for the dump function.
     */
    maxNode: number;
    /**
     * Indicates the maximum number of tasks for the dump function.
     */
    maxTask: number;
    /**
     * Indicates the minimum number of nodes for the dump function.
     */
    minNode: number;
    /**
     * Indicates the minimum number of tasks for the dump function.
     */
    minTask: number;
}

export interface GetDmsRocketmqInstancesInstance {
    /**
     * Indicates the list of availability zone names, where
     * instance brokers reside and which has available resources.
     */
    availabilityZones: string[];
    /**
     * Indicates the service data address.
     */
    brokerAddress: string;
    /**
     * Specifies the broker numbers. Defaults to 1.
     */
    brokerNum: number;
    /**
     * Indicates the Cross-VPC access information.
     * The CrossVpc structure is documented below.
     */
    crossVpcAccesses: outputs.GetDmsRocketmqInstancesInstanceCrossVpcAccess[];
    /**
     * Indicates the description of the DMS RocketMQ instance.
     */
    description: string;
    /**
     * Indicates whether access control is enabled.
     */
    enableAcl: boolean;
    /**
     * Indicates whether to enable public access.
     */
    enablePublicip: boolean;
    /**
     * Indicates the version of the RocketMQ engine.
     */
    engineVersion: string;
    /**
     * Indicates a product ID.
     */
    flavorId: string;
    /**
     * Indicates the ID of the DMS RocketMQ instance.
     */
    id: string;
    /**
     * Indicates whether to support IPv6. Defaults to false.
     */
    ipv6Enable: boolean;
    /**
     * Indicates the time at which the maintenance window starts. The format is HH:mm:ss.
     */
    maintainBegin: string;
    /**
     * Indicates the time at which the maintenance window ends. The format is HH:mm:ss.
     */
    maintainEnd: string;
    /**
     * Specifies the name of the DMS RocketMQ instance.
     */
    name: string;
    /**
     * Indicates the metadata address.
     */
    namesrvAddress: string;
    /**
     * Indicates the whether billing based on new specifications is enabled.
     */
    newSpecBillingEnable: boolean;
    /**
     * Indicates the node quantity.
     */
    nodeNum: number;
    /**
     * Indicates the public network service data address.
     */
    publicBrokerAddress: string;
    /**
     * Indicates the public network metadata address.
     */
    publicNamesrvAddress: string;
    /**
     * Indicates the public IP address.
     */
    publicipAddress: string;
    /**
     * Indicates the ID of the EIP bound to the instance.
     * Use commas (,) to separate multiple EIP IDs.
     * This parameter is mandatory if public access is enabled (that is, enablePublicip is set to true).
     */
    publicipId: string;
    /**
     * Indicates the resource specifications.
     */
    resourceSpecCode: string;
    /**
     * Indicates the ID of a security group.
     */
    securityGroupId: string;
    /**
     * Indicates the instance specification. For a cluster DMS RocketMQ instance, VM specifications
     * and the number of nodes are returned.
     */
    specification: string;
    /**
     * Indicates whether the RocketMQ SASL_SSL is enabled. Defaults to false.
     */
    sslEnable: boolean;
    /**
     * Specifies the status of the DMS RocketMQ instance.
     */
    status: string;
    /**
     * Indicates the message storage capacity. Unit: GB.
     */
    storageSpace: number;
    /**
     * Indicates the storage I/O specification.
     */
    storageSpecCode: string;
    /**
     * Indicates the ID of a subnet.
     */
    subnetId: string;
    /**
     * Indicates the DMS RocketMQ instance type.
     */
    type: string;
    /**
     * Indicates the used message storage space. Unit: GB.
     */
    usedStorageSpace: number;
    /**
     * Indicates the ID of a VPC.
     */
    vpcId: string;
}

export interface GetDmsRocketmqInstancesInstanceCrossVpcAccess {
    /**
     * Indicates the advertised IP.
     */
    advertisedIp: string;
    /**
     * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
     */
    lisenterIp: string;
    /**
     * Indicates the IP of the listener.
     */
    listenerIp: string;
    /**
     * Indicates the port.
     */
    port: number;
    /**
     * Indicates the port ID associated with the address.
     */
    portId: string;
}

export interface GetDmsRocketmqMessageTracesTrace {
    /**
     * Specifies the message body length.
     */
    bodyLength: number;
    /**
     * Specifies the IP address of the host that generates the message.
     */
    clientHost: string;
    /**
     * Specifies the consumption status.
     * + **0**: successful
     * + **1**: timeout
     * + **2**: abnormal
     * + **3**: null
     * + **5**: failed
     */
    consumeStatus: number;
    /**
     * Specifies the time spent.
     */
    costTime: number;
    /**
     * Specifies whether the response is a transaction check response.
     */
    fromTransactionCheck: boolean;
    /**
     * Specifies the producer group or consumer group.
     */
    groupName: string;
    /**
     * Specifies the message keys.
     */
    keys: string;
    /**
     * Specifies the message ID.
     */
    messageId: string;
    /**
     * Specifies the message type.
     */
    messageType: string;
    /**
     * Specifies the offset message ID.
     */
    offsetMessageId: string;
    /**
     * Specifies the request ID.
     */
    requestId: string;
    /**
     * Specifies the number of retry times.
     */
    retryTimes: number;
    /**
     * Specifies the IP address of the host that stores the message.
     */
    storeHost: string;
    /**
     * Specifies whether the request is successful.
     */
    success: boolean;
    /**
     * Specifies the message tag.
     */
    tags: string;
    /**
     * Specifies the time.
     */
    time: string;
    /**
     * Specifies the topic name.
     */
    topic: string;
    /**
     * Specifies the trace type.
     */
    traceType: string;
    /**
     * Specifies the transaction ID.
     */
    transactionId: string;
    /**
     * Specifies the transaction status.
     */
    transactionState: string;
}

export interface GetDmsRocketmqMessagesMessage {
    /**
     * Indicates the message body. Only return when querying message by message ID.
     */
    body: string;
    /**
     * Indicates the message body checksum.
     */
    bodyCrc: number;
    /**
     * Indicates the IP address of the host that generates the message.
     */
    bornHost: string;
    /**
     * Indicates the message generated time.
     */
    bornTime: string;
    /**
     * Specifies the message ID.
     */
    messageId: string;
    /**
     * Indicates the property list.
     * The propertyList structure is documented below.
     */
    propertyLists: outputs.GetDmsRocketmqMessagesMessagePropertyList[];
    /**
     * Indicates the queue ID.
     */
    queueId: number;
    /**
     * Indicates the offset in the queue.
     */
    queueOffset: number;
    /**
     * Indicates the number of retry times.
     */
    reconsumeTimes: number;
    /**
     * Indicates the IP address of the host that stores the message.
     */
    storeHost: string;
    /**
     * Indicates the storage size.
     */
    storeSize: number;
    /**
     * Indicates the message stored time.
     */
    storeTime: string;
}

export interface GetDmsRocketmqMessagesMessagePropertyList {
    /**
     * Indicates the property name.
     */
    name: string;
    /**
     * Indicates the property value.
     */
    value: string;
}

export interface GetDmsRocketmqMigrationTasksTask {
    /**
     * Indicates the ID of a metadata migration task.
     */
    id: string;
    /**
     * Specifies the RocketMQ migration task name.
     */
    name: string;
    /**
     * Indicates the start time of a metadata migration task.
     */
    startDate: string;
    /**
     * Indicates the status of a metadata migration task.
     */
    status: string;
    /**
     * Specifies the RocketMQ migration task type.
     * Valid values are **rocketmq** and **rabbitToRocket**.
     */
    type: string;
}

export interface GetDmsRocketmqTopicAccessUsersPolicy {
    /**
     * Indicates the user name.
     */
    accessKey: string;
    /**
     * Indicates whether the user is an administrator.
     */
    admin: boolean;
    /**
     * Indicates the permissions.
     */
    perm: string;
    /**
     * Indicates the IP address whitelist.
     */
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqTopicsTopic {
    /**
     * The list of brokers.
     * The brokers structure is documented below.
     */
    brokers: outputs.GetDmsRocketmqTopicsTopicBroker[];
    /**
     * Specifies the topic name.
     */
    name: string;
    /**
     * Specifies the permission. Value options: **sub**, **pub** or **all**.
     */
    permission: string;
    /**
     * Specifies the number of total read queue.
     */
    totalReadQueueNum: number;
    /**
     * Specifies the number of total write queue.
     */
    totalWriteQueueNum: number;
}

export interface GetDmsRocketmqTopicsTopicBroker {
    /**
     * Indicates the broker name.
     */
    brokerName: string;
    /**
     * Indicates the number of read queue.
     */
    readQueueNum: number;
    /**
     * Indicates the number of write queue.
     */
    writeQueueNum: number;
}

export interface GetDmsRocketmqUsersUser {
    /**
     * Specifies the user name.
     */
    accessKey: string;
    /**
     * Specifies whether the user is an administrator.
     */
    admin: boolean;
    /**
     * Specifies the default consumer group permissions.
     * Value options: **SUB**, **DENY**.
     */
    defaultGroupPerm: string;
    /**
     * Specifies the default topic permissions.
     * Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
     */
    defaultTopicPerm: string;
    /**
     * The list of the special consumer group permissions.
     * The groupPerms structure is documented below.
     */
    groupPerms: outputs.GetDmsRocketmqUsersUserGroupPerm[];
    /**
     * The list of the special topic permissions.
     * The topicPerms structure is documented below.
     */
    topicPerms: outputs.GetDmsRocketmqUsersUserTopicPerm[];
    /**
     * Specifies the IP address whitelist.
     */
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqUsersUserGroupPerm {
    /**
     * Indicates the name of consumer group.
     */
    name: string;
    /**
     * Indicates the permissions of consumer group.
     * Value options: **SUB**, **DENY**.
     */
    perm: string;
}

export interface GetDmsRocketmqUsersUserTopicPerm {
    /**
     * Indicates the name of consumer group.
     */
    name: string;
    /**
     * Indicates the permissions of consumer group.
     * Value options: **SUB**, **DENY**.
     */
    perm: string;
}

export interface GetElbFlavorsFlavor {
    /**
     * Specifies the bandwidth size(Mbit/s) in the flavor.
     */
    bandwidth: number;
    category: number;
    /**
     * Specifies the cps in the flavor.
     */
    cps: number;
    flavorSoldOut: boolean;
    httpsCps: number;
    /**
     * ID of the flavor.
     */
    id: string;
    lcu: number;
    /**
     * Specifies the maximum connections in the flavor.
     */
    maxConnections: number;
    /**
     * Name of the flavor.
     */
    name: string;
    publicBorderGroup: string;
    /**
     * Specifies the qps in the L7 flavor.
     */
    qps: number;
    shared: boolean;
    /**
     * Specifies the flavor type. Valid values are L4 and L7.
     */
    type: string;
}

export interface GetElbPoolsPool {
    anyPortEnable: boolean;
    /**
     * Whether to enable delayed logout.
     */
    connectionDrainEnabled: boolean;
    /**
     * The timeout of the delayed logout in seconds.
     */
    connectionDrainTimeout: number;
    createdAt: string;
    /**
     * Specifies the description of the ELB pool.
     */
    description: string;
    enterpriseProjectId: string;
    /**
     * Specifies the health monitor ID of the ELB pool.
     */
    healthmonitorId: string;
    /**
     * The listener, loadbalancer or member ID.
     */
    id: string;
    /**
     * The IP version of the LB pool.
     */
    ipVersion: string;
    /**
     * Specifies the method of the ELB pool. Must be one of ROUND_ROBIN, LEAST_CONNECTIONS,
     * or SOURCE_IP.
     */
    lbMethod: string;
    /**
     * The listener list. The object structure is documented below.
     */
    listeners: outputs.GetElbPoolsPoolListener[];
    /**
     * The loadbalancer list. The object structure is documented below.
     */
    loadbalancers: outputs.GetElbPoolsPoolLoadbalancer[];
    memberDeletionProtectionEnable: boolean;
    /**
     * The member list. The object structure is documented below.
     */
    members: outputs.GetElbPoolsPoolMember[];
    /**
     * The timeout of the delayed logout in seconds.
     */
    minimumHealthyMemberCount: number;
    /**
     * Specifies the name of the ELB pool.
     */
    name: string;
    /**
     * Indicates whether connections in the same session will be processed by the same pool member or not.
     * The object structure is documented below.
     */
    persistences: outputs.GetElbPoolsPoolPersistence[];
    /**
     * The reason for update protection.
     */
    protectionReason: string;
    /**
     * The protection status for update.
     */
    protectionStatus: string;
    /**
     * Specifies the protocol of the ELB pool. This can either be TCP, UDP or HTTP.
     */
    protocol: string;
    publicBorderGroup: string;
    quicCidHashStrategies: outputs.GetElbPoolsPoolQuicCidHashStrategy[];
    /**
     * The slow start duration, in seconds.
     */
    slowStartDuration: number;
    /**
     * Whether to enable slow start.
     */
    slowStartEnabled: boolean;
    /**
     * The type of persistence mode.
     */
    type: string;
    updatedAt: string;
    /**
     * The ID of the VPC where the backend server group works.
     */
    vpcId: string;
}

export interface GetElbPoolsPoolListener {
    /**
     * The listener, loadbalancer or member ID.
     */
    id: string;
}

export interface GetElbPoolsPoolLoadbalancer {
    /**
     * The listener, loadbalancer or member ID.
     */
    id: string;
}

export interface GetElbPoolsPoolMember {
    /**
     * The listener, loadbalancer or member ID.
     */
    id: string;
}

export interface GetElbPoolsPoolPersistence {
    /**
     * The name of the cookie if persistence mode is set appropriately.
     */
    cookieName: string;
    /**
     * The stickiness duration, in minutes.
     */
    timeout: number;
    /**
     * The type of persistence mode.
     */
    type: string;
}

export interface GetElbPoolsPoolQuicCidHashStrategy {
    len: number;
    offset: number;
}

export interface GetFgsApplicationTemplatesTemplate {
    /**
     * Specifies the category used to query the application templates.
     */
    category: string;
    /**
     * The description of template.
     */
    description: string;
    /**
     * The template ID.
     */
    id: string;
    /**
     * The template name.
     */
    name: string;
    /**
     * Specifies the runtime name used to query the application templates.  
     * The valid values are as follows:
     * + **Node.js6.10**
     * + **Node.js8.10**
     * + **Node.js10.16**
     * + **Node.js12.13**
     * + **Node.js14.18**
     * + **Node.js16.17**
     * + **Node.js18.15**
     * + **Python2.7**
     * + **Python3.6**
     * + **Python3.9**
     * + **Python3.10**
     * + **Java8**
     * + **Java11**
     * + **Go1.x**
     * + **C#(.NET Core 2.1)**
     * + **C#(.NET Core 3.1)**
     * + **http**
     * + **PHP7.3**
     * + **Custom**
     */
    runtime: string;
    /**
     * The type of the function application.
     */
    type: string;
}

export interface GetFgsApplicationsApplication {
    /**
     * Specifies the description of the application to be queried.
     */
    description: string;
    /**
     * The ID of application.
     */
    id: string;
    /**
     * Specifies the application name used to query specified application.
     */
    name: string;
    /**
     * Specifies the status of the application to be queried.  
     * The valid values are as follows:
     * + **success**: The application created successfully.
     * + **repoFail**: The application repository creation failed.
     */
    status: string;
    /**
     * The latest update time of the application, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetFgsDependencyVersionsVersion {
    /**
     * Specifies the ID of the dependency package to which the versions belong.
     */
    dependencyId: string;
    /**
     * The name of the dependency package corresponding to the version.
     */
    dependencyName: string;
    /**
     * The description of the dependency package version.
     */
    description: string;
    /**
     * The unique ID of the dependency.
     */
    etag: string;
    /**
     * The ID of the dependency package version.
     */
    id: string;
    /**
     * The OBS bucket path where the dependency package version is located.
     */
    link: string;
    /**
     * The dependency owner, `public` indicates a public dependency.
     */
    owner: string;
    /**
     * Specifies the runtime of the dependency package version.  
     * The valid values are as follows:
     * + **Java8**
     * + **Java11**
     * + **Node.js6.10**
     * + **Node.js8.10**
     * + **Node.js10.16**
     * + **Node.js12.13**
     * + **Node.js14.18**
     * + **Python2.7**
     * + **Python3.6**
     * + **Python3.9**
     * + **Go1.8**
     * + **Go1.x**
     * + **C#(.NET Core 2.0)**
     * + **C#(.NET Core 2.1)**
     * + **C#(.NET Core 3.1)**
     * + **Custom**
     * + **PHP 7.3**
     * + **http**
     */
    runtime: string;
    /**
     * The size of the ZIP file used by the dependency package version, in bytes.
     */
    size: number;
    /**
     * Specifies the version of the dependency package.
     */
    version: number;
}

export interface GetFgsFunctionEventsEvent {
    /**
     * The event ID.
     */
    id: string;
    /**
     * The event name.
     */
    name: string;
    /**
     * The latest update time of the function event, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetFgsFunctionTriggersTrigger {
    /**
     * The creation time of the function trigger, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The detailed configuration of the function trigger.
     */
    eventData: string;
    /**
     * The ID of the function trigger.
     */
    id: string;
    /**
     * Specifies status of the function trigger.
     * The valid values are as follows:
     * + **ACTIVE**
     * + **DISABLED**
     */
    status: string;
    /**
     * Specifies type of the function trigger.
     * The valid values are as follows:
     * + **TIMER**
     * + **APIG**
     * + **CTS**
     * + **DDS**
     * + **DMS**
     * + **DIS**
     * + **LTS**
     * + **OBS**
     * + **SMN**
     * + **KAFKA**
     * + **RABBITMQ**
     * + **DEDICATEDGATEWAY**
     * + **OPENSOURCEKAFKA**
     * + **APIC**
     * + **GAUSSMONGO**
     * + **EVENTGRID**
     * + **IOTDA**
     */
    type: string;
    /**
     * The latest update time of the function trigger, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetFgsFunctionsFunction {
    /**
     * The IAM agency name for the function configuration.
     */
    agency: string;
    /**
     * The IAM agency name for the function execution.
     */
    appAgency: string;
    /**
     * The name of the function file.
     */
    codeFilename: string;
    /**
     * The function code type.
     * + **inline**: inline code.
     * + **zip**: ZIP file.
     * + **jar**: JAR file or java functions.
     * + **obs**: function code stored in an OBS bucket.
     */
    codeType: string;
    /**
     * The code URL.
     */
    codeUrl: string;
    /**
     * The description of the function.
     */
    description: string;
    /**
     * The custom user data (key/value pairs) defined to be encrypted for the function.
     */
    encryptedUserData: string;
    /**
     * Specifies the ID of the enterprise project to which the functions belong.
     */
    enterpriseProjectId: string;
    /**
     * The functionGraph version.
     */
    functiongraphVersion: string;
    /**
     * The entry point of the function.
     */
    handler: string;
    /**
     * The initializer of the function.
     */
    initializerHandler: string;
    /**
     * The maximum duration the function can be initialized.
     */
    initializerTimeout: number;
    /**
     * The LTS log group ID.
     */
    logGroupId: string;
    /**
     * The LTS log stream ID.
     */
    logStreamId: string;
    /**
     * The maximum number of instances for a single function.
     */
    maxInstanceNum: string;
    /**
     * The memory size allocated to the function, the unit is MB.
     */
    memorySize: number;
    /**
     * Specifies the function name used to query the specified function.
     */
    name: string;
    /**
     * The network ID of subnet to which the function belongs.
     */
    networkId: string;
    /**
     * The package name that the function used.
     */
    package: string;
    /**
     * Specifies the dependency package runtime used to query the functions.  
     * The valid values are as follows:
     * + **Java8**
     * + **Java11**
     * + **Node.js6.10**
     * + **Node.js8.10**
     * + **Node.js10.16**
     * + **Node.js12.13**
     * + **Node.js14.18**
     * + **Node.js16.17**
     * + **Node.js18.15**
     * + **Python2.7**
     * + **Python3.6**
     * + **Python3.9**
     * + **Python3.10**
     * + **Go1.x**
     * + **C#(.NET Core 2.1)**
     * + **C#(.NET Core 3.1)**
     * + **Custom**
     * + **PHP7.3**
     * + **http**
     * + **Custom Image**
     * + **Cangjie1.0**
     */
    runtime: string;
    /**
     * The timeout interval of the function.
     */
    timeout: number;
    /**
     * Specifies the function URN used to query the specified function.
     */
    urn: string;
    /**
     * The custom user data (key/value pairs) defined for the function.
     */
    userData: string;
    /**
     * The function version.
     */
    version: string;
    /**
     * The VPC ID to which the function belongs.
     */
    vpcId: string;
}

export interface GetFgsQuotasQuota {
    /**
     * The number of available quota.
     */
    limit: number;
    /**
     * The resource type corresponding to quota.
     * + **fgs_func_scale_down_timeout**: Release time of idle function instances in FunctionGraph `v1`.
     * + **fgs_func_occurs**: Indicates instance quota for functions in FunctionGraph `v1` and reserved instance quota for
     * functions in FunctionGraph `v2`.
     * + **fgs_func_pat_idle_time**: Release time of idle PAT in VPC function.
     * + **fgs_func_num**: User function quantity quota.
     * + **fgs_func_code_size**: Total code size quota of user functions.
     * + **fgs_workflow_num**: Function flow quantity quota.
     * + **fgs_on_demand_instance_limit**: Maximum number of instances per function in FunctionGraph `v2`.
     * + **fgs_func_qos_limit**: Instance quantity quota of user functions.
     */
    type: string;
    /**
     * The unit of usage.
     */
    unit: string;
    /**
     * The number of quota used.
     */
    used: number;
}

export interface GetKpsFailedTasksTask {
    /**
     * The ID of the task.
     */
    id: string;
    /**
     * The name of the keypair associated with the task.
     */
    keypairName: string;
    /**
     * The operation type of the task.
     * The value can be **FAILED_RESET**, **FAILED_REPLACE** or **FAILED_UNBIND**.
     */
    operateType: string;
    /**
     * The ID of the instance associated with the task.
     */
    serverId: string;
    /**
     * The name of the instance associated with the task.
     */
    serverName: string;
    /**
     * The error code of the task execution failure.
     */
    taskErrorCode: string;
    /**
     * The error information of the task execution failure.
     */
    taskErrorMsg: string;
    /**
     * The start time of the task, in RFC3339 format.
     */
    taskTime: string;
}

export interface GetKpsRunningTasksTask {
    /**
     * The ID of the task.
     */
    id: string;
    /**
     * The name of the keypair associated with the task.
     */
    keypairName: string;
    /**
     * The operation type of the task.
     * The value can be **RUNNING**.
     */
    operateType: string;
    /**
     * The ID of the instance associated with the task.
     */
    serverId: string;
    /**
     * The name of the instance associated with the task.
     */
    serverName: string;
    /**
     * The start time of the task, in RFC3339 format.
     */
    taskTime: string;
}

export interface GetSfsTurboDataTasksTask {
    /**
     * The destination path prefix of the data task.
     */
    destPrefix: string;
    /**
     * The target end information of the data task.
     */
    destTarget: string;
    /**
     * The end time of the data task, in RFC3339 format.
     */
    endTime: string;
    /**
     * The ID of the data task.
     */
    id: string;
    /**
     * The data task execution result information.
     */
    message: string;
    /**
     * The source path prefix of the data task.
     */
    srcPrefix: string;
    /**
     * The linkage directory name.
     */
    srcTarget: string;
    /**
     * The start time of the data task, in RFC3339 format.
     */
    startTime: string;
    /**
     * The status of the data task.
     */
    status: string;
    /**
     * The type of the data task.
     */
    type: string;
}

export interface GetSfsTurboDuTasksTask {
    /**
     * The start time of the DU task, in RFC3339 format.
     */
    beginTime: string;
    /**
     * The resource usages of a directory (including subdirectories).
     */
    dirUsages: outputs.GetSfsTurboDuTasksTaskDirUsage[];
    /**
     * The end time of the DU task, in RFC3339 format.
     */
    endTime: string;
    /**
     * The ID of the DU task.
     */
    id: string;
    /**
     * The status of the DU task.
     */
    status: string;
}

export interface GetSfsTurboDuTasksTaskDirUsage {
    /**
     * The total number of files in the directory.
     */
    fileCounts: outputs.GetSfsTurboDuTasksTaskDirUsageFileCount[];
    /**
     * The error message.
     */
    message: string;
    /**
     * The full path to a legal directory in the file system.
     */
    path: string;
    /**
     * The used capacity, in byte.
     */
    usedCapacity: number;
}

export interface GetSfsTurboDuTasksTaskDirUsageFileCount {
    /**
     * The number of block devices.
     */
    block: number;
    /**
     * The number of character devices.
     */
    char: number;
    /**
     * The number of directories.
     */
    dir: number;
    /**
     * The number of pipe files.
     */
    pipe: number;
    /**
     * The number of common files.
     */
    regular: number;
    /**
     * The number of sockets.
     */
    socket: number;
    /**
     * The number of symbolic links.
     */
    symlink: number;
}

export interface GetSfsTurboObsTargetsTarget {
    /**
     * The creation time of the OBS target.
     */
    createdAt: string;
    /**
     * The linkage directory name of the OBS target.
     */
    fileSystemPath: string;
    /**
     * The ID of the OBS target.
     */
    id: string;
    /**
     * The detail of the OBS bucket.
     */
    obs: outputs.GetSfsTurboObsTargetsTargetOb[];
    /**
     * The status of the OBS target.
     */
    status: string;
}

export interface GetSfsTurboObsTargetsTargetOb {
    /**
     * The name of the OBS bucket associated with the OBS target.
     */
    bucket: string;
    /**
     * The domain name of the region where the OBS bucket belongs.
     */
    endpoint: string;
}

export interface GetSfsTurboPermRulesRule {
    /**
     * The ID of the permission rule.
     */
    id: string;
    /**
     * The IP address or IP address range of the authorized object.
     */
    ipCidr: string;
    /**
     * The read and write permission of the authorized object.
     */
    rwType: string;
    /**
     * The file system access permission granted to the user of the authorized object.
     */
    userType: string;
}

export interface GetVpnConnectionHealthChecksConnectionHealthCheck {
    /**
     * Specifies the ID of the VPN connection.
     */
    connectionId: string;
    /**
     * Specifies the destination IP of the VPN connection health check.
     */
    destinationIp: string;
    /**
     * The ID of the connection health check.
     */
    id: string;
    /**
     * The proto type of the connection health check.
     */
    protoType: string;
    /**
     * Specifies the source IP of the VPN connection health check.
     */
    sourceIp: string;
    /**
     * Specifies the status of the VPN connection health check.
     */
    status: string;
    /**
     * The type of the connection health check.
     */
    type: string;
}

export interface GetVpnConnectionsConnection {
    /**
     * Indicates the connection monitor ID of the connection.
     */
    connectionMonitorId: string;
    /**
     * The created time.
     */
    createdAt: string;
    /**
     * Indicates the customer gateway ID of the connection.
     */
    customerGatewayId: string;
    /**
     * Indicates the enable nqa of the connection.
     */
    enableNqa: boolean;
    /**
     * Indicates the enterprise project ID of the connection.
     */
    enterpriseProjectId: string;
    /**
     * Specifies the gateway ID of the VPN connection.
     */
    gatewayId: string;
    /**
     * Specifies the gateway IP of the VPN connection.
     */
    gatewayIp: string;
    /**
     * Indicates the ha role of the connection.
     */
    haRole: string;
    /**
     * Indicates the ID of the connection.
     */
    id: string;
    /**
     * Indicates the ikepolicy information of the connection.
     */
    ikepolicies: outputs.GetVpnConnectionsConnectionIkepolicy[];
    /**
     * Indicates the ipsecpolicy information of the connection.
     */
    ipsecpolicies: outputs.GetVpnConnectionsConnectionIpsecpolicy[];
    /**
     * Specifies the name of the VPN connection.
     */
    name: string;
    /**
     * Indicates the peer subnets of the connection.
     */
    peerSubnets: string[];
    /**
     * Indicates the policy rules information of the connection.
     */
    policyRules: outputs.GetVpnConnectionsConnectionPolicyRule[];
    /**
     * Specifies the status of the VPN connection.
     */
    status: string;
    /**
     * Indicates the tunnel local address of the connection.
     */
    tunnelLocalAddress: string;
    /**
     * Indicates the tunnel peer address of the connection.
     */
    tunnelPeerAddress: string;
    /**
     * The last updated time.
     */
    updatedAt: string;
    /**
     * Specifies the VPN type of the VPN connection.
     */
    vpnType: string;
}

export interface GetVpnConnectionsConnectionIkepolicy {
    /**
     * Indicates the authentication algorithm of the ikepolicy certificate.
     */
    authenticationAlgorithm: string;
    /**
     * Indicates the souauthentication methodrce of the ikepolicy certificate.
     */
    authenticationMethod: string;
    /**
     * Indicates the dh group of the ikepolicy certificate.
     */
    dhGroup: string;
    /**
     * Indicates the dpd information of the ikepolicy certificate.
     */
    dpds: outputs.GetVpnConnectionsConnectionIkepolicyDpd[];
    /**
     * Indicates the encryption algorithm of the ikepolicy certificate.
     */
    encryptionAlgorithm: string;
    /**
     * Indicates the ike version of the ikepolicy certificate.
     */
    ikeVersion: string;
    /**
     * Indicates the lifetime seconds of the ipsecpolicy certificate.
     */
    lifetimeSeconds: number;
    /**
     * Indicates the local ID of the ikepolicy certificate.
     */
    localId: string;
    /**
     * Indicates the local ID type of the ikepolicy certificate.
     */
    localIdType: string;
    /**
     * Indicates the peer ID of the ikepolicy certificate.
     */
    peerId: string;
    /**
     * Indicates the peer ID type of the ikepolicy certificate.
     */
    peerIdType: string;
    /**
     * Indicates the phase1 negotiation mode of the ikepolicy certificate.
     */
    phase1NegotiationMode: string;
}

export interface GetVpnConnectionsConnectionIkepolicyDpd {
    /**
     * Indicates the interval of the dpd certificate.
     */
    interval: number;
    /**
     * Indicates the msg of the dpd certificate.
     */
    msg: string;
    /**
     * Indicates the timeout of the dpd certificate.
     */
    timeout: number;
}

export interface GetVpnConnectionsConnectionIpsecpolicy {
    /**
     * Indicates the authentication algorithm of the ikepolicy certificate.
     */
    authenticationAlgorithm: string;
    /**
     * Indicates the encapsulation mode of the ipsecpolicy certificate.
     */
    encapsulationMode: string;
    /**
     * Indicates the encryption algorithm of the ikepolicy certificate.
     */
    encryptionAlgorithm: string;
    /**
     * Indicates the lifetime seconds of the ipsecpolicy certificate.
     */
    lifetimeSeconds: number;
    /**
     * Indicates the pfs of the ipsecpolicy certificate.
     */
    pfs: string;
    /**
     * Indicates the transform protocol of the ipsecpolicy certificate.
     */
    transformProtocol: string;
}

export interface GetVpnConnectionsConnectionPolicyRule {
    /**
     * Indicates the destination of the policy rules certificate.
     */
    destinations: string[];
    /**
     * Indicates the rule index of the policy rules.
     */
    ruleIndex: number;
    /**
     * Indicates the source of the policy rules certificate.
     */
    source: string;
}

export interface GetVpnCustomerGatewaysCustomerGateway {
    /**
     * Specifies the BGP ASN number of the customer gateway, only works when the routeMode is
     * **bgp**. The value ranges from **1** to **4294967295**.
     */
    asn: number;
    /**
     * Indicates the ca certificate information of the customer gateway.
     * The caCertificate structure is documented below.
     */
    caCertificates: outputs.GetVpnCustomerGatewaysCustomerGatewayCaCertificate[];
    /**
     * The created time.
     */
    createdAt: string;
    /**
     * Indicates the ID of the customer gateway.
     */
    id: string;
    /**
     * Indicates the idType of the customer gateway.
     */
    idType: string;
    /**
     * Indicates the idValue of the customer gateway.
     */
    idValue: string;
    /**
     * Specifies the IP address of the customer gateway.
     */
    ip: string;
    /**
     * Specifies the customer gateway name.
     */
    name: string;
    /**
     * Specifies the route mode of the customer gateway. The value can be **static** and **bgp**.
     */
    routeMode: string;
    /**
     * The last updated time.
     */
    updatedAt: string;
}

export interface GetVpnCustomerGatewaysCustomerGatewayCaCertificate {
    /**
     * Indicates the expire time of the customer gateway certificate.
     */
    expireTime: string;
    /**
     * Indicates whether the customer gateway certificate is updatable.
     */
    isUpdatable: boolean;
    /**
     * Indicates the issuer of the customer gateway certificate.
     */
    issuer: string;
    /**
     * Indicates the serial number of the customer gateway certificate.
     */
    serialNumber: string;
    /**
     * Indicates the signature algorithm of the customer gateway certificate.
     */
    signatureAlgorithm: string;
    /**
     * Indicates the subject of the customer gateway certificate.
     */
    subject: string;
}

export interface GetVpnGatewaysGateway {
    /**
     * The list of private access IPs.
     */
    accessPrivateIps: string[];
    /**
     * The ID of the access subnet.
     */
    accessSubnetId: string;
    /**
     * The ID of the access VPC.
     */
    accessVpcId: string;
    /**
     * Specifies the attachment type of the gateway.
     * The value can be: **vpc** and **er**.
     */
    attachmentType: string;
    /**
     * The availability zone IDs.
     */
    availabilityZones: string[];
    /**
     * The ASN number of BGP
     */
    bgpAsn: number;
    /**
     * The VPC network segment used by the VPN gateway.
     */
    connectSubnet: string;
    /**
     * The max number of connections.
     */
    connectionNumber: number;
    /**
     * The create time.
     */
    createdAt: string;
    /**
     * The EIPs used by the fateway.
     * The eips structure is documented below.
     */
    eips: outputs.GetVpnGatewaysGatewayEip[];
    /**
     * Specifies the enterprise project ID of the gateway.
     */
    enterpriseProjectId: string;
    /**
     * The ER attachment ID.
     */
    erAttachmentId: string;
    /**
     * The ID of the ER to which the VPN gateway is connected.
     */
    erId: string;
    /**
     * The flavor of the VPN gateway.
     */
    flavor: string;
    /**
     * The HA mode.
     * The value can be: **active-active** and **active-standby**.
     */
    haMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The local subnets.
     */
    localSubnets: string[];
    /**
     * Specifies the name of the gateway.
     */
    name: string;
    /**
     * Specifies the network type of the gateway.
     * The value can be: **public** and **private**.
     */
    networkType: string;
    /**
     * The status of the gateway.
     */
    status: string;
    /**
     * The update time.
     */
    updatedAt: string;
    /**
     * The number of used connection groups.
     */
    usedConnectionGroup: number;
    /**
     * The number of used connections.
     */
    usedConnectionNumber: number;
    /**
     * The ID of the VPC to which the VPN gateway is connected.
     */
    vpcId: string;
}

export interface GetVpnGatewaysGatewayEip {
    /**
     * The bandwidth billing info.
     */
    bandwidthBillingInfo: string;
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s.
     */
    bandwidthSize: number;
    /**
     * The billing info.
     */
    billingInfo: string;
    /**
     * The charge mode of the bandwidth.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type.
     */
    type: string;
}

export interface ObsBucketAclAccountPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
    /**
     * Specifies the account id to authorize. The account id cannot be the bucket owner,
     * and must be unique.
     */
    accountId: string;
}

export interface ObsBucketAclLogDeliveryUserPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface ObsBucketAclOwnerPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface ObsBucketAclPublicPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface SfsTurboDuTaskDirUsage {
    fileCounts: outputs.SfsTurboDuTaskDirUsageFileCount[];
    message: string;
    path: string;
    usedCapacity: number;
}

export interface SfsTurboDuTaskDirUsageFileCount {
    block: number;
    char: number;
    dir: number;
    pipe: number;
    regular: number;
    socket: number;
    symlink: number;
}

export interface SfsTurboObsTargetObs {
    attributes?: outputs.SfsTurboObsTargetObsAttributes;
    bucket: string;
    endpoint: string;
    policy?: outputs.SfsTurboObsTargetObsPolicy;
}

export interface SfsTurboObsTargetObsAttributes {
    dirMode: string;
    fileMode: string;
    gid: number;
    uid: number;
}

export interface SfsTurboObsTargetObsPolicy {
    autoExportPolicy?: outputs.SfsTurboObsTargetObsPolicyAutoExportPolicy;
}

export interface SfsTurboObsTargetObsPolicyAutoExportPolicy {
    events: string[];
    prefix: string;
    suffix: string;
}

export interface SmnSubscriptionExtension {
    clientId?: string;
    clientSecret?: string;
    header?: {[key: string]: string};
    keyword?: string;
    signSecret?: string;
}

export interface SmnSubscriptionFilterPolicy {
    /**
     * The filter policy name. The policy name must be unique.
     */
    name: string;
    /**
     * The string array for exact match.
     */
    stringEquals: string[];
}

export interface SwrOrganizationPermissionsSelfPermission {
    /**
     * The permission of current user.
     */
    permission: string;
    /**
     * The ID of current user.
     */
    userId: string;
    /**
     * The name of current user.
     */
    userName: string;
}

export interface SwrOrganizationPermissionsUser {
    /**
     * Specifies the permission of the existing SberCloud user.
     * The values can be **Manage**, **Write** and **Read**.
     */
    permission: string;
    /**
     * Specifies the ID of the existing SberCloud user.
     */
    userId: string;
    /**
     * Specifies the name of the existing SberCloud user.
     */
    userName: string;
}

export interface VpnConnectionIkepolicy {
    /**
     * The authentication algorithm. The value can be **sha1**, **md5**,
     * **sha2-256**, **sha2-384**, **sha2-512**. Defaults to **sha2-256**. **sha1** and **md5** are less secure,
     * please use them with caution.
     */
    authenticationAlgorithm: string;
    /**
     * The authentication method during IKE negotiation.
     * The value can be **pre-share** and **digital-envelope-v2**. Defaults to **pre-share**.
     */
    authenticationMethod: string;
    /**
     * Specifies the DH group used for key exchange in phase 1.
     * The value can be **group1**, **group2**, **group5**, **group14**, **group15**, **group16**, **group19**, **group20**,
     * or **group21**. Exercise caution when using **group1**, **group2**, **group5**,
     * or **group14** as they have low security. Defaults to **group15**.
     */
    dhGroup: string;
    /**
     * Specifies the dead peer detection (DPD) object.
     * The dpd structure is documented below.
     *
     * <a name="Connection_DPD"></a>
     * The `dpd` block supports:
     */
    dpd: outputs.VpnConnectionIkepolicyDpd;
    /**
     * The encryption algorithm. The value can be **3des**, **aes-128**, **aes-192**,
     * **aes-256**, **aes-128-gcm-16**, **aes-256-gcm-16**, **aes-128-gcm-128**, **aes-256-gcm-128**. Defaults to **aes-128**.
     * **3des** is less secure, please use it with caution.
     */
    encryptionAlgorithm: string;
    /**
     * The IKE negotiation version. The value can be **v1** and **v2**. Defaults to **v2**.
     */
    ikeVersion: string;
    /**
     * The lifecycle time of Ipsec tunnel in seconds.
     * The value ranges from **60** to **604800**. Defaults to **3600**.
     */
    lifetimeSeconds: number;
    /**
     * The local ID.
     */
    localId: string;
    /**
     * The local ID type. The value can be **ip** or **fqdn**. Defaults to **ip**.
     */
    localIdType: string;
    /**
     * The peer ID.
     */
    peerId: string;
    /**
     * The peer ID type. The value can be **ip**, **fqdn** or **any**. Defaults to **ip**.
     */
    peerIdType: string;
    /**
     * The DH key group used by PFS. The value can be **group1**, **group2**, **group5**, **group14**
     * **group16**, **group19**, **group20**, **group21**. Defaults to **group14**.
     */
    pfs: string;
    /**
     * The negotiation mode, only works when the ikeVersion is v1.
     * The value can be **main** or **aggressive**. Defaults to **main**.
     */
    phase1NegotiationMode: string;
}

export interface VpnConnectionIkepolicyDpd {
    /**
     * Specifies the DPD idle timeout period.
     * The value ranges from **10** to **3600**, in seconds. Defaults to **30**.
     */
    interval: number;
    /**
     * Specifies the format of DPD packets. The value can be:
     * + **seq-hash-notify**: indicates that the payload of DPD packets is in the sequence of hash-notify;
     * + **seq-notify-hash**: indicates that the payload of DPD packets is in the sequence of notify-hash;
     *
     * Defaults to **seq-hash-notify**.
     *
     * <a name="Connection_CreateRequestIpsecPolicy"></a>
     * The `ipsecpolicy` block supports:
     */
    msg: string;
    /**
     * Specifies the interval for retransmitting DPD packets.
     * The value ranges from **2** to **60**, in seconds. Defaults to **15**.
     */
    timeout: number;
}

export interface VpnConnectionIpsecpolicy {
    /**
     * The authentication algorithm. The value can be **sha1**, **md5**,
     * **sha2-256**, **sha2-384**, **sha2-512**. Defaults to **sha2-256**. **sha1** and **md5** are less secure,
     * please use them with caution.
     */
    authenticationAlgorithm: string;
    /**
     * The encapsulation mode, only **tunnel** supported for now.
     * Defaults to **tunnel**.
     *
     * <a name="Connection_PolicyRule"></a>
     * The `policyRules` block supports:
     */
    encapsulationMode: string;
    /**
     * The encryption algorithm. The value can be **3des**, **aes-128**, **aes-192**,
     * **aes-256**, **aes-128-gcm-16**, **aes-256-gcm-16**, **aes-128-gcm-128**, **aes-256-gcm-128**. Defaults to **aes-128**.
     * **3des** is less secure, please use it with caution.
     */
    encryptionAlgorithm: string;
    /**
     * The lifecycle time of Ipsec tunnel in seconds.
     * The value ranges from **60** to **604800**. Defaults to **3600**.
     */
    lifetimeSeconds: number;
    /**
     * The DH key group used by PFS. The value can be **group1**, **group2**, **group5**, **group14**
     * **group16**, **group19**, **group20**, **group21**. Defaults to **group14**.
     */
    pfs: string;
    /**
     * The transform protocol. Only **esp** supported for now.
     * Defaults to **esp**.
     */
    transformProtocol: string;
}

export interface VpnConnectionPolicyRule {
    /**
     * The list of destination CIDRs.
     */
    destinations: string[];
    /**
     * The rule index.
     */
    ruleIndex: number;
    /**
     * The source CIDR.
     */
    source: string;
}

export interface VpnGatewayCertificate {
    /**
     * The certificate chain of the gateway certificate.
     */
    certificateChain: string;
    /**
     * The expire time of the certificate.
     */
    certificateChainExpireTime: string;
    /**
     * The serial number of the certificate chain.
     */
    certificateChainSerialNumber: string;
    /**
     * The subject of the certificate chain.
     */
    certificateChainSubject: string;
    /**
     * The expire time of the certificate.
     */
    certificateExpireTime: string;
    /**
     * The certificate ID.
     */
    certificateId: string;
    /**
     * The serial number of the certificate.
     */
    certificateSerialNumber: string;
    /**
     * The subject of the certificate.
     */
    certificateSubject: string;
    /**
     * The content of the gateway certificate.
     */
    content: string;
    /**
     * The create time of the gateway certificate.
     */
    createdAt: string;
    /**
     * The enc certificate of the gateway certificate.
     */
    encCertificate: string;
    /**
     * The expire time of the enc certificate.
     */
    encCertificateExpireTime: string;
    /**
     * The serial number of the enc certificate.
     */
    encCertificateSerialNumber: string;
    /**
     * The subject of the enc certificate.
     */
    encCertificateSubject: string;
    /**
     * The enc private key of the gateway certificate.
     */
    encPrivateKey: string;
    /**
     * The issuer of the certificate.
     */
    issuer: string;
    /**
     * The name of the gateway certificate.
     */
    name: string;
    /**
     * The private of the gateway certificate.
     */
    privateKey: string;
    /**
     * The signature algorithm of the certificate.
     */
    signatureAlgorithm: string;
    /**
     * The status of the certificate.
     */
    status: string;
    /**
     * The update time of the gateway certificate.
     */
    updatedAt: string;
}

export interface VpnGatewayEip1 {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     *
     * Changing this parameter will create a new resource.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
     * cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
     * When the `flavor` is **Professional2**, the value cannot be greater than **1000**.
     *
     * Changing this parameter will create a new resource.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     *
     * Changing this parameter will create a new resource.
     *
     * > You can use `id` to specify an existing EIP or use `type`, `bandwidthName`, `bandwidthSize` and `chargeMode` to
     * create a new EIP.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     *
     * Changing this parameter will create a new resource.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     *
     * Changing this parameter will create a new resource.
     */
    type: string;
}

export interface VpnGatewayEip2 {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     *
     * Changing this parameter will create a new resource.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
     * cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
     * When the `flavor` is **Professional2**, the value cannot be greater than **1000**.
     *
     * Changing this parameter will create a new resource.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     *
     * Changing this parameter will create a new resource.
     *
     * > You can use `id` to specify an existing EIP or use `type`, `bandwidthName`, `bandwidthSize` and `chargeMode` to
     * create a new EIP.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     *
     * Changing this parameter will create a new resource.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     *
     * Changing this parameter will create a new resource.
     */
    type: string;
}

export interface VpnGatewayMasterEip {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     *
     * Changing this parameter will create a new resource.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
     * cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
     * When the `flavor` is **Professional2**, the value cannot be greater than **1000**.
     *
     * Changing this parameter will create a new resource.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     *
     * Changing this parameter will create a new resource.
     *
     * > You can use `id` to specify an existing EIP or use `type`, `bandwidthName`, `bandwidthSize` and `chargeMode` to
     * create a new EIP.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     *
     * Changing this parameter will create a new resource.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     *
     * Changing this parameter will create a new resource.
     */
    type: string;
}

export interface VpnGatewaySlaveEip {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     *
     * Changing this parameter will create a new resource.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the `flavor` is **Basic**, the value
     * cannot be greater than **100**. When the `flavor` is **Professional1**, the value cannot be greater than **300**.
     * When the `flavor` is **Professional2**, the value cannot be greater than **1000**.
     *
     * Changing this parameter will create a new resource.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     *
     * Changing this parameter will create a new resource.
     *
     * > You can use `id` to specify an existing EIP or use `type`, `bandwidthName`, `bandwidthSize` and `chargeMode` to
     * create a new EIP.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     *
     * Changing this parameter will create a new resource.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     *
     * Changing this parameter will create a new resource.
     */
    type: string;
}

export namespace Aom {
    export interface ServiceDiscoveryRuleDiscoveryRule {
        /**
         * Specifies the matched value. This is a list of strings.
         */
        checkContents: string[];
        /**
         * Specifies the match condition. The values can be **contain** and **equals**.
         */
        checkMode: string;
        /**
         * Specifies the match type. The values can be **cmdLine**, **env** and **scope**.
         */
        checkType: string;
    }

    export interface ServiceDiscoveryRuleLogPathRule {
        /**
         * Specifies the command. This is a list of strings.
         */
        args: string[];
        /**
         * Specifies the value type, which can be **cmdLineHash**.
         */
        nameType: string;
        /**
         * Specifies the log path. This is a list of strings.
         *
         * <a name="nameRulesObject"></a>
         * The `nameRules` block supports:
         */
        values: string[];
    }

    export interface ServiceDiscoveryRuleNameRules {
        /**
         * Specifies the application name rule. If the value of `nameType` is
         * **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end in
         * the command are extracted. If the value of `nameType` is **env**, `args` is in the format of ["aa"], indicating that
         * the environment variable named aa is extracted. If the value of `nameType` is **str**, `args` is in the format of
         * ["fix"], indicating that the application name is suffixed with fix. If the value of `nameType` is **cmdLineHash**,
         * `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the application name is
         * ser when the startup command is 0001. The object structure is documented below.
         *
         * <a name="basicNameRuleObject"></a>
         * The `serviceNameRule` block and `applicationNameRule` block support:
         */
        applicationNameRules: outputs.Aom.ServiceDiscoveryRuleNameRulesApplicationNameRule[];
        /**
         * Specifies the service name rule. If there are multiple objects in the array,
         * the character strings extracted from these objects constitute the service name. If the value of `nameType` is
         * **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end
         * in the command are extracted. If the value of `nameType` is **env**, `args` is in the format of ["aa"],
         * indicating that the environment variable named aa is extracted. If the value of `nameType` is **str**, `args` is in the
         * format of ["fix"], indicating that the service name is suffixed with fix. If the value of `nameType` is
         * **cmdLineHash**, `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the
         * service name is ser when the startup command is 0001. The object structure is
         * documented below.
         */
        serviceNameRules: outputs.Aom.ServiceDiscoveryRuleNameRulesServiceNameRule[];
    }

    export interface ServiceDiscoveryRuleNameRulesApplicationNameRule {
        /**
         * Specifies the input value.
         */
        args: string[];
        /**
         * Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
         * and **str**.
         */
        nameType: string;
        /**
         * Specifies the application name, which is mandatory only when the value of
         * `nameType` is **cmdLineHash**.
         */
        values?: string[];
    }

    export interface ServiceDiscoveryRuleNameRulesServiceNameRule {
        /**
         * Specifies the input value.
         */
        args: string[];
        /**
         * Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
         * and **str**.
         */
        nameType: string;
        /**
         * Specifies the application name, which is mandatory only when the value of
         * `nameType` is **cmdLineHash**.
         */
        values?: string[];
    }

}

export namespace As {
    export interface BandwidthPolicyIntervalAlarmAction {
        /**
         * Specifies the operation restrictions.
         * - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
         * - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
         * - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.
         *
         * <a name="ASBandWidthPolicy_ScheduledPolicy"></a>
         * The `scheduledPolicy` block supports:
         */
        limits: number;
        /**
         * Specifies the lower limit of the value range.
         */
        lowerBound: string;
        /**
         * Specifies the operation to be performed. The default operation is ADD.
         * The options are as follows:
         * - **ADD**: indicates adding the bandwidth size.
         * - **REDUCE**: indicates reducing the bandwidth size.
         * - **SET**: indicates setting the bandwidth size to a specified value.
         */
        operation: string;
        /**
         * Specifies the bandwidth (Mbit/s).
         * The value is an integer from 1 to 2000. The default value is 1.
         */
        size: number;
        /**
         * Specifies the upper limit of the value range.
         */
        upperBound: string;
    }

    export interface BandwidthPolicyMetaData {
        /**
         * The bandwidth sharing type in the bandwidth policy.
         */
        metadataBandwidthShareType: string;
        /**
         * The EIP IP address for the bandwidth in the bandwidth policy.
         */
        metadataEipAddress: string;
        /**
         * The EIP ID for the bandwidth in the bandwidth policy.
         */
        metadataEipId: string;
    }

    export interface BandwidthPolicyScalingPolicyAction {
        /**
         * Specifies the operation restrictions.
         * - If operation is not SET, this parameter takes effect and the unit is Mbit/s.
         * - If operation is set to ADD, this parameter indicates the maximum bandwidth allowed.
         * - If operation is set to REDUCE, this parameter indicates the minimum bandwidth allowed.
         *
         * <a name="ASBandWidthPolicy_ScheduledPolicy"></a>
         * The `scheduledPolicy` block supports:
         */
        limits: number;
        /**
         * Specifies the operation to be performed. The default operation is ADD.
         * The options are as follows:
         * - **ADD**: indicates adding the bandwidth size.
         * - **REDUCE**: indicates reducing the bandwidth size.
         * - **SET**: indicates setting the bandwidth size to a specified value.
         */
        operation: string;
        /**
         * Specifies the bandwidth (Mbit/s).
         * The value is an integer from 1 to 2000. The default value is 1.
         */
        size: number;
    }

    export interface BandwidthPolicyScheduledPolicy {
        /**
         * Specifies the end time of the scaling action triggered periodically.
         * The time format complies with UTC. This parameter is mandatory when scalingPolicyType is set to RECURRENCE.
         * When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
         * The time format is YYYY-MM-DDThh:mmZ.
         */
        endTime: string;
        /**
         * Specifies the time when the scaling action is triggered.
         * The time format complies with UTC.
         * - If scalingPolicyType is set to SCHEDULED, the time format is YYYY-MM-DDThh:mmZ.
         * - If scalingPolicyType is set to RECURRENCE, the time format is hh:mm.
         */
        launchTime: string;
        /**
         * Specifies the periodic triggering type.
         * This parameter is mandatory when scalingPolicyType is set to RECURRENCE. The options are as follows:
         * - **Daily**: indicates that the scaling action is triggered once a day.
         * - **Weekly**: indicates that the scaling action is triggered once a week.
         * - **Monthly**: indicates that the scaling action is triggered once a month.
         */
        recurrenceType: string;
        /**
         * Specifies the day when a periodic scaling action is triggered.
         * This parameter is mandatory when scalingPolicyType is set to RECURRENCE.
         * - If recurrenceType is set to Daily, the value is null, indicating that the scaling action is triggered once a day.
         * - If recurrenceType is set to Weekly, the value ranges from 1 (Sunday) to 7 (Saturday).
         * The digits refer to dates in each week and separated by a comma, such as 1,3,5.
         * - If recurrenceType is set to Monthly, the value ranges from 1 to 31.
         * The digits refer to the dates in each month and separated by a comma, such as 1,10,13,28.
         */
        recurrenceValue: string;
        /**
         * Specifies the start time of the scaling action triggered periodically.
         * The time format complies with UTC. The default value is the local time.
         * The time format is YYYY-MM-DDThh:mmZ.
         */
        startTime: string;
    }

    export interface ConfigurationInstanceConfig {
        adminPass?: string;
        /**
         * Specifies a billing mode for an ECS.
         * The value can be `postPaid` and `spot`. The default value is `postPaid`.
         * Changing this will create a new resource.
         */
        chargingMode?: string;
        dedicatedHostId: string;
        /**
         * Specifies the disk group information. System disks are mandatory and
         * data disks are optional. The object structure is documented below.
         * Changing this will create a new resource.
         */
        disks: outputs.As.ConfigurationInstanceConfigDisk[];
        /**
         * Specifies the ECS group ID. Changing this will create a new resource.
         */
        ecsGroupId: string;
        /**
         * Specifies the ECS flavor name. A maximum of 10 flavors can be selected.
         * Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
         */
        flavor: string;
        /**
         * Specifies the priority policy used when there are multiple flavors
         * and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.
         *
         * + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
         * in the flavor list.
         * + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.
         *
         * Changing this will create a new resource.
         */
        flavorPriorityPolicy: string;
        /**
         * Specifies the ECS image ID. Changing this will create a new resource.
         */
        image: string;
        /**
         * Specifies the ECS instance ID when using its specification
         * as the template to create AS configurations. In this case, `flavor`, `image`, and `disk` arguments do not take effect.
         * If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
         * Changing this will create a new resource.
         */
        instanceId: string;
        keyFingerprint: string;
        /**
         * Specifies the name of the SSH key pair used to log in to the instance.
         * Changing this will create a new resource.
         */
        keyName: string;
        /**
         * Specifies the key/value pairs to make available from within the instance.
         * Changing this will create a new resource.
         */
        metadata?: {[key: string]: string};
        /**
         * Specifies the customize personality of an instance by defining one or
         * more files and their contents. The object structure is documented below.
         * Changing this will create a new resource.
         *
         * <a name="instanceConfigDiskObject"></a>
         * The `disk` block supports:
         */
        personalities: outputs.As.ConfigurationInstanceConfigPersonality[];
        /**
         * Specifies the EIP of the ECS instance.
         * The object structure is documented below.
         * Changing this will create a new resource.
         */
        publicIp: outputs.As.ConfigurationInstanceConfigPublicIp;
        /**
         * Specifies an array of one or more security group IDs.
         * Changing this will create a new resource.
         */
        securityGroupIds: string[];
        tenancy: string;
        /**
         * Specifies the user data to provide when launching the instance.
         * The file content must be encoded with Base64. Changing this will create a new resource.
         */
        userData?: string;
    }

    export interface ConfigurationInstanceConfigDisk {
        dataDiskImageId: string;
        dedicatedStorageId: string;
        /**
         * Specifies whether the disk is a system disk or a data disk.
         * Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
         * Changing this will create a new resource.
         */
        diskType: string;
        iops: number;
        /**
         * Specifies the encryption KMS ID of the **DATA** disk.
         * Changing this will create a new resource.
         *
         * <a name="instanceConfigPublicIpObject"></a>
         * The `publicIp` block supports:
         */
        kmsId: string;
        size: number;
        snapshotId: string;
        throughput: number;
        /**
         * Specifies the disk type. Changing this will create a new resource.
         * Available options are:
         * + `SAS`: high I/O disk type.
         * + `SSD`: ultra-high I/O disk type.
         * + `GPSSD`: general purpose SSD disk type.
         */
        volumeType: string;
    }

    export interface ConfigurationInstanceConfigPersonality {
        /**
         * Specifies the content of the injected file, which must be encoded with base64.
         * Changing this creates a new resource.
         */
        content: string;
        /**
         * Specifies the path of the injected file. Changing this creates a new resource.
         */
        path: string;
    }

    export interface ConfigurationInstanceConfigPublicIp {
        /**
         * Specifies the EIP configuration that will be automatically assigned to the instance.
         * The object structure is documented below. Changing this will create a new resource.
         */
        eip: outputs.As.ConfigurationInstanceConfigPublicIpEip;
    }

    export interface ConfigurationInstanceConfigPublicIpEip {
        /**
         * Specifies the bandwidth information. The object structure is documented below.
         * Changing this will create a new resource.
         */
        bandwidth: outputs.As.ConfigurationInstanceConfigPublicIpEipBandwidth;
        /**
         * Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
         * and **5_sbgp** (static BGP). Changing this will create a new resource.
         */
        ipType: string;
    }

    export interface ConfigurationInstanceConfigPublicIpEipBandwidth {
        /**
         * Specifies whether the bandwidth is billed by traffic or by bandwidth
         * size. The value can be **traffic** or **bandwidth**. Changing this creates a new resource.
         */
        chargingMode: string;
        /**
         * The resource ID in UUID format.
         */
        id: string;
        /**
         * Specifies the bandwidth sharing type. The system only supports
         * **PER** (indicates exclusive bandwidth). Changing this will create a new resource.
         */
        shareType: string;
        /**
         * Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
         * is 1 to 2000 and that for bandwidth billed by traffic is 1 to 300.
         * Changing this creates a new resource.
         *
         * <a name="instanceConfigPersonalityObject"></a>
         * The `personality` block supports:
         */
        size: number;
    }

    export interface GroupLbaasListener {
        listenerId: string;
        /**
         * Specifies the backend ECS group ID.
         */
        poolId: string;
        /**
         * Specifies the backend protocol, which is the port on which a backend ECS listens for
         * traffic. The number of the port ranges from 1 to 65535.
         */
        protocolPort: number;
        protocolVersion: string;
        /**
         * Specifies the weight, which determines the portion of requests a backend ECS processes
         * compared to other backend ECSs added to the same listener. The value of this parameter ranges from 0 to 100. The
         * default value is 1.
         */
        weight?: number;
    }

    export interface GroupNetwork {
        /**
         * Specifies the ID of the security group.
         *
         * <a name="groupLbaasListenerObject"></a>
         * The `lbaasListeners` block supports:
         */
        id: string;
        /**
         * Specifies the ID of the shared bandwidth of an IPv6 address.
         */
        ipv6BandwidthId?: string;
        /**
         * Specifies whether to support IPv6 addresses. The default value is `false`.
         */
        ipv6Enable?: boolean;
        /**
         * Specifies whether processesing only traffic that is destined specifically
         * for it. Defaults to true.
         *
         * <a name="groupSecurityGroupObject"></a>
         * The `securityGroups` block supports:
         */
        sourceDestCheck?: boolean;
    }

    export interface GroupSecurityGroup {
        /**
         * Specifies the ID of the security group.
         *
         * <a name="groupLbaasListenerObject"></a>
         * The `lbaasListeners` block supports:
         */
        id: string;
    }

    export interface PolicyScalingPolicyAction {
        /**
         * Specifies the number of instances to be operated. The default number is 1.
         */
        instanceNumber: number;
        instancePercentage?: number;
        /**
         * Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
         * and `SET`.
         */
        operation: string;
    }

    export interface PolicyScheduledPolicy {
        /**
         * Specifies the end time of the scaling action triggered periodically. The time format complies
         * with UTC. This argument is mandatory when `scalingPolicyType`
         * is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.
         *
         * <a name="scalingPolicyActionObject"></a>
         * The `scalingPolicyAction` block supports:
         */
        endTime: string;
        /**
         * Specifies the time when the scaling action is triggered.
         * + If `scalingPolicyType` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
         * + If `scalingPolicyType` is set to `RECURRENCE`, the time format is **hh:mm**.
         *
         * > the `launchTime` of the `SCHEDULED` policy cannot be earlier than the current time.
         */
        launchTime: string;
        /**
         * Specifies the periodic triggering type. This argument is mandatory when
         * `scalingPolicyType` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
         */
        recurrenceType: string;
        /**
         * Specifies the frequency at which scaling actions are triggered.
         */
        recurrenceValue: string;
        /**
         * Specifies the start time of the scaling action triggered periodically. The time format
         * complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
         */
        startTime: string;
    }

}

export namespace Cbr {
    export interface GetVaultsVault {
        /**
         * The allocated capacity of the vault, in GB.
         */
        allocated: number;
        /**
         * Whether automatic association is supported.
         */
        autoBind: boolean;
        /**
         * Specifies whether to enable automatic expansion of the backup protection
         * type vault. Default to **false**.
         */
        autoExpandEnabled: boolean;
        /**
         * The rules for automatic association.
         */
        bindRules: {[key: string]: string};
        /**
         * Specifies the backup specifications.
         * The value is crashConsistent by default (crash consistent backup).
         *
         * Only server type vaults support application consistent.
         */
        consistentLevel: string;
        /**
         * Specifies a unique ID in UUID format of enterprise project.
         */
        enterpriseProjectId: string;
        /**
         * The vault ID in UUID format.
         */
        id: string;
        /**
         * Specifies a unique name of the CBR vault. This parameter can contain a maximum of 64
         * characters, which may consist of letters, digits, underscores(_) and hyphens (-).
         */
        name: string;
        /**
         * Specifies a policy to associate with the CBR vault.
         */
        policyId: string;
        /**
         * Specifies the protection type of the CBR vault.
         * The valid value is **backup**.
         */
        protectionType: string;
        /**
         * An array of one or more resources to attach to the CBR vault.
         * The object structure is documented below.
         */
        resources: outputs.Cbr.GetVaultsVaultResource[];
        /**
         * Specifies the vault sapacity, in GB. The valid value range is `1` to `10,485,760`.
         */
        size: number;
        /**
         * The specification code.
         */
        specCode: string;
        /**
         * Specifies the CBR vault status, including **available**, **lock**, **frozen** and **error**.
         */
        status: string;
        /**
         * The name of the bucket for the vault.
         */
        storage: string;
        /**
         * The key/value pairs to associate with the vault.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the object type of the CBR vault. The vaild values are as follows:
         * + **server** (Cloud Servers)
         * + **disk** (EVS Disks)
         * + **turbo** (SFS Turbo file systems)
         */
        type: string;
        /**
         * The used capacity, in GB.
         */
        used: number;
    }

    export interface GetVaultsVaultResource {
        /**
         * The array of disk IDs which will be excluded in the backup.
         */
        excludes: string[];
        /**
         * An array of disk or SFS file system IDs which will be included in the backup.
         */
        includes: string[];
        /**
         * The ID of the ECS instance to be backed up.
         */
        serverId: string;
    }

    export interface PolicyBackupCycle {
        /**
         * Specifies the weekly backup day of backup schedule. It supports seven days a week (MO, TU,
         * WE, TH, FR, SA, SU) and this parameter is separated by a comma (,) without spaces, between date and date during the
         * configuration.
         */
        days?: string;
        /**
         * Specifies the backup time. Automated backups will be triggered at the backup
         * time. The current time is in the UTC format (HH:MM). The minutes in the list must be set to **00** and the hours
         * cannot be repeated. In the replication policy, you are advised to set one time point for one day.
         *
         * <a name="cbrPolicyLongTermRetention"></a>
         * The `longTermRetention` block supports:
         */
        executionTimes: string[];
        /**
         * Specifies the interval (in days) of backup schedule. The value range is `1` to `30`. This
         * parameter and `days` are alternative.
         */
        interval?: number;
    }

    export interface PolicyLongTermRetention {
        /**
         * Specifies the latest backup of each day is saved in the long term.
         */
        daily?: number;
        /**
         * How often (after how many incremental backups) a full backup is performed.
         */
        fullBackupInterval?: number;
        /**
         * Specifies the latest backup of each month is saved in the long term.
         */
        monthly?: number;
        /**
         * Specifies the latest backup of each week is saved in the long term.
         */
        weekly?: number;
        /**
         * Specifies the latest backup of each year is saved in the long term.
         *
         * > A maximum of 10 backups are retained for failed periodic backup tasks. They are retained for one month and can be
         * manually deleted on the web console.
         */
        yearly?: number;
    }

    export interface VaultPolicy {
        /**
         * The ID of destination vault to which the replication policy will associated.
         */
        destinationVaultId?: string;
        /**
         * A resource ID in UUID format.
         */
        id: string;
    }

    export interface VaultResource {
        /**
         * Specifies the array of disk IDs which will be excluded in the backup.
         * Only **server** vault support this parameter.
         */
        excludes: string[];
        /**
         * Specifies the array of disk or SFS file system IDs which will be included in the backup.
         * Only **disk** and **turbo** vault support this parameter.
         */
        includes: string[];
        /**
         * Specifies the ID of the ECS instance to be backed up.
         */
        serverId?: string;
    }

}

export namespace Cce {
    export interface AddonValues {
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `basicJson`, but it is not recommended.
         * Changing this parameter will create a new resource.
         */
        basic?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         * Changing this parameter will create a new resource.
         */
        basicJson?: string;
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `customJson`, but it is not recommended.
         * Changing this parameter will create a new resource.
         */
        custom?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         * Changing this parameter will create a new resource.
         */
        customJson?: string;
        /**
         * Specifies the key/value pairs vary depending on the add-on.
         * Only supports non-nested structure and only supports string type elements.
         * This is an alternative to `flavorJson`, but it is not recommended.
         * Changing this parameter will create a new resource.
         *
         * Arguments which can be passed to the `basicJson`, `customJson` and `flavorJson` add-on parameters depends on
         * the add-on type and version. For more detailed description of add-ons
         * see add-ons description
         */
        flavor?: {[key: string]: string};
        /**
         * Specifies the json string vary depending on the add-on.
         * Changing this parameter will create a new resource.
         */
        flavorJson?: string;
    }

    export interface ClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the component name.
         * Changing this parameter will create a new cluster resource.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface ClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the component name.
         * Changing this parameter will create a new cluster resource.
         */
        name: string;
    }

    export interface ClusterComponentConfiguration {
        /**
         * Specifies JSON string of the component configurations.
         * Changing this parameter will create a new cluster resource.
         */
        configurations?: string;
        /**
         * Specifies the component name.
         * Changing this parameter will create a new cluster resource.
         */
        name: string;
    }

    export interface ClusterEncryptionConfig {
        kmsKeyId: string;
        mode: string;
    }

    export interface ClusterExtendParam {
        /**
         * Specifies the AZ of master nodes in the cluster. The value can be:
         * + **multi_az**: The cluster will span across AZs. This field is configurable only for high-availability clusters.
         * + **AZ of the dedicated cloud computing pool**: The cluster will be deployed in the AZ of Dedicated Cloud (DeC).
         * This parameter is mandatory for dedicated CCE clusters.
         *
         * Changing this parameter will create a new cluster resource.
         */
        clusterAz?: string;
        /**
         * Specifies the cluster CPU management policy.
         * The value can be:
         * + **none**: CPU cores will not be exclusively allocated to workload pods.
         * Select this value if you want a large pool of shareable CPU cores.
         * + **static**: CPU cores can be exclusively allocated to workload pods.
         * Select this value if your workload is sensitive to latency in CPU cache and scheduling.In a CCE Turbo cluster,
         * this setting is valid only for nodes where common containers, not Kata containers, run.
         *
         * Defaults to none.
         * Changing this parameter will create a new cluster resource.
         *
         * <a name="cceClusterComponentConfigurations"></a>
         * The `componentConfigurations` block supports:
         */
        cpuManagerPolicy?: string;
        /**
         * Specifies the specifications of the master node
         * in the dedicated hybrid cluster.
         * Changing this parameter will create a new cluster resource.
         */
        decMasterFlavor?: string;
        /**
         * Specifies the default UmaskMode configuration of Docker in a
         * cluster. The value can be **secure** or **normal**, defaults to normal.
         * Changing this parameter will create a new cluster resource.
         */
        dockerUmaskMode?: string;
        /**
         * Specifies whether the system and data disks of a master node
         * use dedicated distributed storage. If left unspecified, EVS disks are used by default.
         * This parameter is mandatory for dedicated CCE clusters.
         * It is in the following format:
         *
         * ```bash
         * <rootVol.dssPoolID>.<rootVol.volType>;<dataVol.dssPoolID>.<dataVol.volType>
         * ```
         *
         * Changing this parameter will create a new cluster resource.
         */
        dssMasterVolumes?: string;
        /**
         * Specifies the number of mask bits of the fixed IP address pool
         * of the container network model. This field can only be used when `containerNetworkType` is set to **vpc-router**.
         * Changing this parameter will create a new cluster resource.
         */
        fixPoolMask?: string;
    }

    export interface ClusterMaster {
        /**
         * Specifies the availability zone of the master node.
         * Changing this parameter will create a new cluster resource.
         *
         * <a name="cceClusterExtendParams"></a>
         * The `extendParams` block supports:
         */
        availabilityZone: string;
    }

    export interface GetAddonTemplateSupportVersion {
        bareMetals: string[];
        virtualMachines: string[];
    }

    export interface GetClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface GetClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
    }

    export interface GetClusterCertificatesCluster {
        /**
         * The certificate authority data of the cluster certificate.
         */
        certificateAuthorityData: string;
        /**
         * Whether insecure skip tls verify of the cluster certificate.
         */
        insecureSkipTlsVerify: boolean;
        /**
         * The context name of the cluster certificate.
         */
        name: string;
        /**
         * The server address of the cluster certificate.
         */
        server: string;
    }

    export interface GetClusterCertificatesContext {
        /**
         * The context cluster of the cluster certificate.
         */
        cluster: string;
        /**
         * The context name of the cluster certificate.
         */
        name: string;
        /**
         * The context user of the cluster certificate.
         */
        user: string;
    }

    export interface GetClusterCertificatesUser {
        /**
         * The client certificate data of the cluster certificate.
         */
        clientCertificateData: string;
        /**
         * The client key data of the cluster certificate.
         */
        clientKeyData: string;
        /**
         * The context name of the cluster certificate.
         */
        name: string;
    }

    export interface GetClusterEndpoint {
        /**
         * The type of the cluster access address.
         * + **Internal**: The user's subnet access address.
         * + **External**: The public network access address.
         */
        type: string;
        /**
         * The URL of the cluster access address.
         */
        url: string;
    }

    export interface GetClusterMaster {
        /**
         * The availability zone (AZ) of the master node.
         */
        availabilityZone: string;
    }

    export interface GetClustersCluster {
        /**
         * The authentication mode of the cluster, possible values are x509 and rbac. Defaults to **rbac**.
         */
        authenticationMode: string;
        /**
         * The charging mode of the cluster.
         */
        billingMode: number;
        /**
         * The certificate clusters. Structure is documented below.
         */
        certificateClusters: outputs.Cce.GetClustersClusterCertificateCluster[];
        /**
         * The certificate users. Structure is documented below.
         */
        certificateUsers: outputs.Cce.GetClustersClusterCertificateUser[];
        /**
         * Specifies the type of the cluster. Possible values: **VirtualMachine**, **BareMetal**.
         */
        clusterType: string;
        /**
         * The version of the cluster.
         */
        clusterVersion: string;
        /**
         * The container network segment.
         */
        containerNetworkCidr: string;
        /**
         * The container network type: **overlay_l2** , **underlay_ipvlan**, **vpc-router** or **eni**.
         */
        containerNetworkType: string;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * The access addresses of kube-apiserver in the cluster. Structure is documented below.
         */
        endpoints: outputs.Cce.GetClustersClusterEndpoint[];
        /**
         * The ENI network segment.
         */
        eniSubnetCidr: string;
        /**
         * The ENI**IPv4 subnet ID** of the subnet where the ENI resides.
         */
        eniSubnetId: string;
        /**
         * Specifies the enterprise project ID of the cluster.
         */
        enterpriseProjectId: string;
        /**
         * The specification of the cluster.
         */
        flavorId: string;
        /**
         * The ID of the cluster.
         */
        id: string;
        /**
         * The raw Kubernetes config to be used by kubectl and other compatible tools.
         */
        kubeConfigRaw: string;
        /**
         * The advanced configuration of master nodes.
         */
        masters: outputs.Cce.GetClustersClusterMaster[];
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The security group ID of the cluster.
         */
        securityGroupId: string;
        /**
         * The service network segment.
         */
        serviceNetworkCidr: string;
        /**
         * Specifies the status of the cluster.
         */
        status: string;
        /**
         * The ID of the subnet used to create the node.
         */
        subnetId: string;
        /**
         * Specifies the VPC ID to which the cluster belongs.
         */
        vpcId: string;
    }

    export interface GetClustersClusterCertificateCluster {
        /**
         * The certificate data.
         */
        certificateAuthorityData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
        /**
         * The server IP address.
         */
        server: string;
    }

    export interface GetClustersClusterCertificateUser {
        /**
         * The client certificate data.
         */
        clientCertificateData: string;
        /**
         * The client key data.
         */
        clientKeyData: string;
        /**
         * Specifies the name of the cluster.
         */
        name: string;
    }

    export interface GetClustersClusterEndpoint {
        /**
         * The type of the cluster access address.
         * + **Internal**: The user's subnet access address.
         * + **External**: The public network access address.
         */
        type: string;
        /**
         * The URL of the cluster access address.
         */
        url: string;
    }

    export interface GetClustersClusterMaster {
        /**
         * The availability zone (AZ) of the master node.
         */
        availabilityZone: string;
    }

    export interface GetNodeDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodeHostnameConfig {
        type: string;
    }

    export interface GetNodePoolDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodePoolHostnameConfig {
        /**
         * Node Pool type.
         */
        type: string;
    }

    export interface GetNodePoolRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodeRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodesNode {
        /**
         * The available partitions where the node is located.
         */
        availabilityZone: string;
        /**
         * The node's billing mode: The value is 0 (on demand).
         */
        billingMode: number;
        /**
         * The data related configuration. Structure is documented below.
         */
        dataVolumes: outputs.Cce.GetNodesNodeDataVolume[];
        /**
         * The ID of ECS group to which the node belongs.
         */
        ecsGroupId: string;
        enterpriseProjectId: string;
        /**
         * The flavor ID to be used.
         */
        flavorId: string;
        hostnameConfigs: outputs.Cce.GetNodesNodeHostnameConfig[];
        /**
         * The ID of the node.
         */
        id: string;
        /**
         * The key pair name when logging in to select the key pair mode.
         */
        keyPair: string;
        /**
         * Specifies the of the node.
         */
        name: string;
        /**
         * The operating System of the node.
         */
        os: string;
        /**
         * The private IP of the node.
         */
        privateIp: string;
        /**
         * The elastic IP parameters of the node.
         */
        publicIp: string;
        /**
         * The system disk related configuration. Structure is documented below.
         */
        rootVolumes: outputs.Cce.GetNodesNodeRootVolume[];
        /**
         * The node's virtual machine ID in ECS.
         */
        serverId: string;
        /**
         * Specifies the status of the node.
         */
        status: string;
        /**
         * The ID of the subnet to which the NIC belongs.
         */
        subnetId: string;
        /**
         * The tags of a VM node, key/value pair format.
         */
        tags: {[key: string]: string};
    }

    export interface GetNodesNodeDataVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetNodesNodeHostnameConfig {
        type: string;
    }

    export interface GetNodesNodeRootVolume {
        /**
         * Disk expansion parameters.
         */
        extendParams: {[key: string]: string};
        /**
         * Disk size in GB.
         */
        size: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface NodeAttachDataVolume {
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam: string;
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        kmsKeyId: string;
        size: number;
        throughput: number;
        volumetype: string;
    }

    export interface NodeAttachExtensionNic {
        /**
         * The ID of the subnet to which the NIC belongs.
         */
        subnetId: string;
    }

    export interface NodeAttachHostnameConfig {
        type: string;
    }

    export interface NodeAttachRootVolume {
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam: string;
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        kmsKeyId: string;
        size: number;
        throughput: number;
        volumetype: string;
    }

    export interface NodeAttachStorage {
        groups: outputs.Cce.NodeAttachStorageGroup[];
        selectors: outputs.Cce.NodeAttachStorageSelector[];
    }

    export interface NodeAttachStorageGroup {
        cceManaged?: boolean;
        /**
         * Specifies the Node Name.
         */
        name: string;
        selectorNames: string[];
        virtualSpaces: outputs.Cce.NodeAttachStorageGroupVirtualSpace[];
    }

    export interface NodeAttachStorageGroupVirtualSpace {
        lvmLvType?: string;
        lvmPath?: string;
        /**
         * Specifies the Node Name.
         */
        name: string;
        runtimeLvType?: string;
        size: string;
    }

    export interface NodeAttachStorageSelector {
        matchLabelCount?: string;
        matchLabelMetadataCmkid?: string;
        matchLabelMetadataEncrypted?: string;
        matchLabelSize?: string;
        matchLabelVolumeType?: string;
        /**
         * Specifies the Node Name.
         */
        name: string;
        type?: string;
    }

    export interface NodeAttachTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         * Changing this parameter will create a new resource.
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit.
         * Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
         * as the prefix of a key. Changing this parameter will create a new resource.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63
         * characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
         * create a new resource.
         */
        value: string;
    }

    export interface NodeDataVolume {
        dssPoolId: string;
        /**
         * Specifies the extended parameter.
         * Changing this parameter will create a new resource.
         * The available keys are as follows:
         * + **agency_name**: The agency name to provide temporary credentials for CCE node to access other cloud services.
         * + **alpha.cce/NodeImageID**: The custom image ID used to create the BMS nodes.
         * + **dockerBaseSize**: The available disk space of a single docker container on the node in device mapper mode.
         * + **DockerLVMConfigOverride**: Specifies the data disk configurations of Docker.
         *
         * The following is an example default configuration:
         *
         * @deprecated use extendParams instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the disk size in GB.
         * Changing this parameter will create a new resource.
         */
        size: number;
        throughput: number;
        /**
         * Specifies the disk type.
         * Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodeExtendParams {
        agencyName?: string;
        dockerBaseSize?: number;
        kubeReservedMem?: number;
        marketType?: string;
        /**
         * Specifies the maximum number of instances a node is allowed to create.
         * Changing this parameter will create a new resource.
         */
        maxPods?: number;
        nicThreshold?: string;
        nodeImageId?: string;
        nodeMultiQueue?: string;
        /**
         * Specifies the script to be executed after installation.
         * The input value can be a Base64 encoded string or not. Changing this parameter will create a new resource.
         */
        postinstall?: string;
        /**
         * Specifies the script to be executed before installation.
         * The input value can be a Base64 encoded string or not. Changing this parameter will create a new resource.
         */
        preinstall?: string;
        securityReinforcementType?: string;
        spotPrice?: string;
        systemReservedMem?: number;
    }

    export interface NodeExtensionNic {
        /**
         * Specifies the ID of the subnet to which the NIC belongs.
         * Changing this parameter will create a new resource.
         */
        subnetId: string;
    }

    export interface NodeHostnameConfig {
        /**
         * Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
         * The default value is **evs**. Changing this parameter will create a new resource.
         */
        type: string;
    }

    export interface NodePoolDataVolume {
        /**
         * Specifies the DSS pool ID. This field is used only for dedicated storage.
         * Changing this parameter will create a new resource.
         */
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        /**
         * Specifies the iops of the disk,
         * required when `volumetype` is **GPSSD2** or **ESSD2**.
         */
        iops: number;
        /**
         * Specifies the KMS key ID. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the disk size in GB. Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the throughput of the disk in MiB/s,
         * required when `volumetype` is **GPSSD2**.
         *
         * > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first time ever.
         */
        throughput: number;
        /**
         * Specifies the disk type. Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodePoolExtendParams {
        /**
         * Specifies the agency name.
         * Changing this parameter will create a new resource.
         */
        agencyName: string;
        /**
         * Specifies the available disk space of a single container on a node,
         * in GB. Changing this parameter will create a new resource.
         */
        dockerBaseSize: number;
        /**
         * Specifies the reserved node memory, which is reserved for
         * Kubernetes-related components. Changing this parameter will create a new resource.
         */
        kubeReservedMem: number;
        marketType: string;
        /**
         * Specifies the maximum number of instances a node is allowed to create.
         * Changing this parameter will create a new resource.
         */
        maxPods: number;
        /**
         * Specifies the ENI pre-binding thresholds.
         * Example setting: **"0.3:0.6"**. Changing this parameter will create a new resource.
         */
        nicThreshold: string;
        /**
         * Specifies the image ID to create the node.
         * Changing this parameter will create a new resource.
         */
        nodeImageId: string;
        /**
         * Specifies the number of ENI queues.
         * Example setting: **"[{\"queue\":4}]"**. Changing this parameter will create a new resource.
         */
        nodeMultiQueue: string;
        /**
         * Specifies the script to be executed after installation.
         * The input value can be a Base64 encoded string or not. Changing this parameter will create a new resource.
         */
        postinstall: string;
        /**
         * Specifies the script to be executed before installation.
         * The input value can be a Base64 encoded string or not. Changing this parameter will create a new resource.
         */
        preinstall: string;
        securityReinforcementType: string;
        spotPrice: string;
        /**
         * Specifies the reserved node memory, which is reserved
         * value for system components. Changing this parameter will create a new resource.
         */
        systemReservedMem: number;
    }

    export interface NodePoolExtensionScaleGroup {
        /**
         * Specifies the basic information about the extended scaling group.
         * The object structure is documented below.
         */
        metadata?: outputs.Cce.NodePoolExtensionScaleGroupMetadata;
        /**
         * Specifies the configurations of the extended scaling group,
         * which carry different configurations from those of the default scaling group.
         * The object structure is documented below.
         *
         * <a name="metadata"></a>
         * The `metadata` block supports:
         */
        spec?: outputs.Cce.NodePoolExtensionScaleGroupSpec;
    }

    export interface NodePoolExtensionScaleGroupMetadata {
        /**
         * Specifies the node pool name.
         */
        name?: string;
    }

    export interface NodePoolExtensionScaleGroupSpec {
        /**
         * Specifies the auto scaling configurations of the extended scaling group.
         * The object structure is documented below.
         *
         * <a name="capacityReservationSpecification"></a>
         * The `capacityReservationSpecification` block supports:
         */
        autoscaling?: outputs.Cce.NodePoolExtensionScaleGroupSpecAutoscaling;
        /**
         * Specifies the availability zone of a node.
         * If this parameter is not specified or left blank, the default scaling group configurations take effect.
         */
        az?: string;
        /**
         * Specifies the capacity reservation
         * configurations of the extended scaling group.
         * The object structure is documented below.
         */
        capacityReservationSpecification?: outputs.Cce.NodePoolExtensionScaleGroupSpecCapacityReservationSpecification;
        /**
         * Specifies the node flavor.
         */
        flavor?: string;
    }

    export interface NodePoolExtensionScaleGroupSpecAutoscaling {
        /**
         * Specifies whether to enable auto scaling for the scaling group, defaults to **false**.
         */
        enable?: boolean;
        /**
         * Specifies the priority of the scaling group, defaults to **0**.
         * A higher value indicates a greater priority.
         */
        extensionPriority?: number;
        /**
         * Specifies the maximum number of nodes allowed if auto scaling is enabled.
         */
        maxNodeCount?: number;
        /**
         * Specifies the minimum number of nodes allowed if auto scaling is enabled.
         */
        minNodeCount?: number;
    }

    export interface NodePoolExtensionScaleGroupSpecCapacityReservationSpecification {
        /**
         * The resource ID in UUID format.
         */
        id?: string;
        /**
         * Specifies the capacity of a private storage pool. If the value is none,
         * the capacity reservation is not specified. If the value is targeted, the capacity reservation is specified.
         * In this case, the `id` cannot be left blank.
         *
         * <a name="autoscaling"></a>
         * The `autoscaling` block supports:
         */
        preference?: string;
    }

    export interface NodePoolHostnameConfig {
        /**
         * Specifies the node pool type. Possible values are: **vm** and **ElasticBMS**.
         */
        type: string;
    }

    export interface NodePoolRootVolume {
        /**
         * Specifies the DSS pool ID. This field is used only for dedicated storage.
         * Changing this parameter will create a new resource.
         */
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        /**
         * Specifies the iops of the disk,
         * required when `volumetype` is **GPSSD2** or **ESSD2**.
         */
        iops: number;
        /**
         * Specifies the KMS key ID. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the disk size in GB. Changing this parameter will create a new resource.
         */
        size: number;
        /**
         * Specifies the throughput of the disk in MiB/s,
         * required when `volumetype` is **GPSSD2**.
         */
        throughput: number;
        /**
         * Specifies the disk type. Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodePoolStorage {
        /**
         * Specifies the storage group consists of multiple storage devices.
         * This is used to divide storage space. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        groups: outputs.Cce.NodePoolStorageGroup[];
        /**
         * Specifies the disk selection.
         * Matched disks are managed according to match labels and storage type. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        selectors: outputs.Cce.NodePoolStorageSelector[];
    }

    export interface NodePoolStorageGroup {
        /**
         * Specifies the whether the storage space is for **kubernetes** and
         * **runtime** components. Only one group can be set to true. The default value is **false**.
         * Changing this parameter will create a new resource.
         */
        cceManaged?: boolean;
        /**
         * Specifies the name of an extended scaling group.
         * The value cannot be default and can contain a maximum of 55 characters.
         * Only digits, lowercase letters, and hyphens (-) are allowed.
         *
         * <a name="spec"></a>
         * The `spec` block supports:
         */
        name: string;
        /**
         * Specifies the list of names of selectors to match.
         * This parameter corresponds to name in `selectors`. A group can match multiple selectors,
         * but a selector can match only one group. Changing this parameter will create a new resource.
         */
        selectorNames: string[];
        /**
         * Specifies the detailed management of space configuration in a group.
         * Changing this parameter will create a new resource.
         */
        virtualSpaces: outputs.Cce.NodePoolStorageGroupVirtualSpace[];
    }

    export interface NodePoolStorageGroupVirtualSpace {
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
         * a new resource.
         */
        lvmLvType?: string;
        /**
         * Specifies the absolute path to which the disk is attached.
         * This parameter takes effect only in **user** configuration. Changing this parameter will create a new resource.
         */
        lvmPath?: string;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **runtime** configuration. Changing this parameter will create a new resource.
         *
         * <a name="hostnameConfig"></a>
         * The `hostnameConfig` block supports:
         */
        runtimeLvType?: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: string;
    }

    export interface NodePoolStorageSelector {
        /**
         * Specifies the number of disks to be selected. If omitted,
         * all disks of this type are selected. Changing this parameter will create a new resource.
         */
        matchLabelCount?: string;
        /**
         * Specifies the customer master key ID of an encrypted
         * disk. Changing this parameter will create a new resource.
         */
        matchLabelMetadataCmkid?: string;
        /**
         * Specifies the disk encryption identifier.
         * Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
         * If omitted, whether the disk is encrypted is not limited. Changing this parameter will create a new resource.
         */
        matchLabelMetadataEncrypted?: string;
        /**
         * Specifies the matched disk size. If omitted,
         * the disk size is not limited. Example: 100. Changing this parameter will create a new resource.
         */
        matchLabelSize?: string;
        /**
         * Specifies the EVS disk type. Currently,
         * **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
         * Changing this parameter will create a new resource.
         */
        matchLabelVolumeType?: string;
        /**
         * Specifies the selector name, used as the index of `selectorNames` in storage group.
         * The name of each selector must be unique. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
         * The default value is **evs**. Changing this parameter will create a new resource.
         */
        type?: string;
    }

    export interface NodePoolTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         *
         * <a name="extendParams"></a>
         * The `extendParams` block supports:
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit. Only letters,
         * digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used as the
         * prefix of a key.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63 characters,
         * including letters, digits, hyphens (-), underscores (_), and periods (.).
         */
        value: string;
    }

    export interface NodeRootVolume {
        dssPoolId: string;
        /**
         * Specifies the extended parameter.
         * Changing this parameter will create a new resource.
         * The available keys are as follows:
         * + **agency_name**: The agency name to provide temporary credentials for CCE node to access other cloud services.
         * + **alpha.cce/NodeImageID**: The custom image ID used to create the BMS nodes.
         * + **dockerBaseSize**: The available disk space of a single docker container on the node in device mapper mode.
         * + **DockerLVMConfigOverride**: Specifies the data disk configurations of Docker.
         *
         * The following is an example default configuration:
         *
         * @deprecated use extendParams instead
         */
        extendParam?: string;
        /**
         * Specifies the disk expansion parameters.
         * Changing this parameter will create a new resource.
         */
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the volume.
         * Changing this parameter will create a new resource.
         */
        kmsKeyId: string;
        /**
         * Specifies the disk size in GB.
         * Changing this parameter will create a new resource.
         */
        size: number;
        throughput: number;
        /**
         * Specifies the disk type.
         * Changing this parameter will create a new resource.
         */
        volumetype: string;
    }

    export interface NodeStorage {
        /**
         * Specifies the storage group consists of multiple storage devices.
         * This is used to divide storage space. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        groups: outputs.Cce.NodeStorageGroup[];
        /**
         * Specifies the disk selection.
         * Matched disks are managed according to match labels and storage type. Structure is documented below.
         * Changing this parameter will create a new resource.
         */
        selectors: outputs.Cce.NodeStorageSelector[];
    }

    export interface NodeStorageGroup {
        /**
         * Specifies the whether the storage space is for **kubernetes** and
         * **runtime** components. Only one group can be set to true. The default value is **false**.
         * Changing this parameter will create a new resource.
         */
        cceManaged?: boolean;
        /**
         * Specifies the name of a virtual storage group. Each group name must be unique.
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the list of names of seletors to match.
         * This parameter corresponds to name in `selectors`. A group can match multiple selectors,
         * but a selector can match only one group. Changing this parameter will create a new resource.
         */
        selectorNames: string[];
        /**
         * Specifies the detailed management of space configuration in a group.
         * Changing this parameter will create a new resource.
         */
        virtualSpaces: outputs.Cce.NodeStorageGroupVirtualSpace[];
    }

    export interface NodeStorageGroupVirtualSpace {
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
         * a new resource.
         */
        lvmLvType?: string;
        /**
         * Specifies the absolute path to which the disk is attached.
         * This parameter takes effect only in **user** configuration. Changing this parameter will create a new resource.
         */
        lvmPath?: string;
        /**
         * Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
         * and **user** are supported. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the LVM write mode, values can be **linear** and **striped**.
         * This parameter takes effect only in **runtime** configuration. Changing this parameter will create a new resource.
         */
        runtimeLvType?: string;
        /**
         * Specifies the size of a virtual space. Only an integer percentage is supported.
         * Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
         * Changing this parameter will create a new resource.
         */
        size: string;
    }

    export interface NodeStorageSelector {
        /**
         * Specifies the number of disks to be selected. If omitted,
         * all disks of this type are selected. Changing this parameter will create a new resource.
         */
        matchLabelCount?: string;
        /**
         * Specifies the cstomer master key ID of an encrypted
         * disk. Changing this parameter will create a new resource.
         */
        matchLabelMetadataCmkid?: string;
        /**
         * Specifies the disk encryption identifier.
         * Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
         * If omitted, whether the disk is encrypted is not limited. Changing this parameter will create a new resource.
         */
        matchLabelMetadataEncrypted?: string;
        /**
         * Specifies the matched disk size. If omitted,
         * the disk size is not limited. Example: 100. Changing this parameter will create a new resource.
         */
        matchLabelSize?: string;
        /**
         * Specifies the EVS disk type. Currently,
         * **SSD** and **SAS** are supported. If omitted, the disk type is not limited.
         * Changing this parameter will create a new resource.
         */
        matchLabelVolumeType?: string;
        /**
         * Specifies the selector name, used as the index of `selectorNames` in storage group.
         * The name of each selector must be unique. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
         * The default value is **evs**. Changing this parameter will create a new resource.
         */
        type?: string;
    }

    export interface NodeTaint {
        /**
         * Available options are NoSchedule, PreferNoSchedule, and NoExecute.
         * Changing this parameter will create a new resource.
         */
        effect: string;
        /**
         * A key must contain 1 to 63 characters starting with a letter or digit.
         * Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
         * as the prefix of a key. Changing this parameter will create a new resource.
         */
        key: string;
        /**
         * A value must start with a letter or digit and can contain a maximum of 63
         * characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
         * create a new resource.
         */
        value?: string;
    }

}

export namespace Cdm {
    export interface ClusterInstance {
        /**
         * Instance ID.
         */
        id: string;
        /**
         * Management IP address.
         */
        manageIp: string;
        /**
         * Specifies cluster name. Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * Private IP.
         */
        privateIp: string;
        /**
         * Public IP.
         */
        publicIp: string;
        /**
         * Instance role.
         */
        role: string;
        /**
         * Traffic IP.
         */
        trafficIp: string;
        /**
         * Instance type.
         */
        type: string;
    }

}

export namespace Ces {
    export interface AlarmruleAlarmAction {
        /**
         * specifies the list of objects to be notified if the alarm status changes, the
         * maximum length is 5. If `type` is set to *notification*, the value of notificationList cannot be empty. If `type` is
         * set to *autoscaling*, the value of notificationList must be **[]**
         * and the value of namespace must be *SYS.AS*.
         *
         * Note: to enable the *autoscaling* alarm rules take effect, you must bind scaling policies.
         */
        notificationLists: string[];
        /**
         * Specifies the type of action triggered by an alarm. the
         * value can be *notification* or *autoscaling*.
         * + notification: indicates that a notification will be sent to the user.
         * + autoscaling: indicates that a scaling action will be triggered.
         */
        type: string;
    }

    export interface AlarmruleCondition {
        /**
         * Specifies the comparison condition of alarm thresholds. The value can be >,
         * =, <, >=, or <=.
         */
        comparisonOperator: string;
        /**
         * Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
         */
        count: number;
        /**
         * Specifies the data rollup methods. The value can be max, min, average, sum, and vaiance.
         */
        filter: string;
        /**
         * Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
         * and 86400.
         *
         * Note: If period is set to 1, the raw metric data is used to determine whether to generate an alarm. When the value of
         * `alarmType` is **EVENT.SYS** or **EVENT.CUSTOM**, period can be set to 0.
         */
        period: number;
        /**
         * Specifies the interval for triggering an alarm if the alarm persists.
         * Possible values are as follows:
         * + **0**: Cloud Eye triggers the alarm only once;
         * + **300**: Cloud Eye triggers the alarm every 5 minutes;
         * + **600**: Cloud Eye triggers the alarm every 10 minutes;
         * + **900**: Cloud Eye triggers the alarm every 15 minutes;
         * + **1800**: Cloud Eye triggers the alarm every 30 minutes;
         * + **3600**: Cloud Eye triggers the alarm every hour;
         * + **10800**: Cloud Eye triggers the alarm every 3 hours;
         * + **21600**: Cloud Eye triggers the alarm every 6 hours;
         * + **43200**: Cloud Eye triggers the alarm every 12 hour;
         * + **86400**: Cloud Eye triggers the alarm every day.
         *
         * The default value is **0**.
         */
        suppressDuration?: number;
        /**
         * Specifies the data unit.
         */
        unit?: string;
        /**
         * Specifies the alarm threshold. The value ranges from 0 to Number of
         * 1.7976931348623157e+108.
         */
        value: number;
    }

    export interface AlarmruleInsufficientdataAction {
        notificationLists: string[];
        type: string;
    }

    export interface AlarmruleMetric {
        /**
         * Specifies the list of metric dimensions. The structure is described below.
         */
        dimensions?: outputs.Ces.AlarmruleMetricDimension[];
        /**
         * Specifies the metric name of the condition. The value can be a string of
         * 1 to 64 characters that must start with a letter and contain only letters, digits, and underscores (_).
         */
        metricName: string;
        /**
         * Specifies the namespace in **service.item** format. **service** and **item**
         * each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
         * Changing this creates a new resource.
         */
        namespace: string;
    }

    export interface AlarmruleMetricDimension {
        /**
         * Specifies the dimension name. The value can be a string of 1 to 32 characters
         * that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
         */
        name: string;
        /**
         * Specifies the dimension value. The value can be a string of 1 to 64 characters
         * that must start with a letter or a number and contain only letters, digits, underscores (_), and hyphens (-).
         */
        value: string;
    }

    export interface AlarmruleOkAction {
        /**
         * specifies the list of objects to be notified if the alarm status changes, the
         * maximum length is 5.
         */
        notificationLists: string[];
        /**
         * Specifies the type of action triggered by an alarm. the value is notification.
         * notification: indicates that a notification will be sent to the user.
         */
        type: string;
    }

}

export namespace Cfw {
    export interface AclRuleCustomService {
        /**
         * The destination port.
         */
        destPort: string;
        /**
         * The protocol type.
         */
        protocol: number;
        /**
         * The source port.
         *
         * <a name="CustomServiceGroups"></a>
         * The `customServiceGroups` block supports:
         */
        sourcePort: string;
    }

    export interface AclRuleCustomServiceGroups {
        /**
         * The IDs of the predefined service groups.
         */
        groupIds: string[];
        /**
         * The protocols used in the predefined service groups.
         *
         * <a name="SourceRegionList"></a>
         * The `sourceRegionList` block supports:
         */
        protocols: number[];
    }

    export interface AclRuleDestinationRegionList {
        /**
         * The Chinese description of the region.
         */
        descriptionCn?: string;
        /**
         * The English description of the region.
         */
        descriptionEn?: string;
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The region type.
         */
        regionType: number;
    }

    export interface AclRulePredefinedServiceGroups {
        /**
         * The IDs of the predefined service groups.
         */
        groupIds: string[];
        /**
         * The protocols used in the predefined service groups.
         *
         * <a name="SourceRegionList"></a>
         * The `sourceRegionList` block supports:
         */
        protocols: number[];
    }

    export interface AclRuleSequence {
        /**
         * Whether to pin on bottom.
         * The options are as follows:
         * + **0**: no;
         * + **1**: yes;
         */
        bottom?: number;
        /**
         * The ID of the rule that the added rule will follow.
         */
        destRuleId: string;
        /**
         * Whether to pin on top.
         * The options are as follows:
         * + **0**: no;
         * + **1**: yes;
         *
         * <a name="CustomServices"></a>
         * The `customServices` block supports:
         */
        top?: number;
    }

    export interface AclRuleSourceRegionList {
        /**
         * The Chinese description of the region.
         */
        descriptionCn?: string;
        /**
         * The English description of the region.
         */
        descriptionEn?: string;
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The region type.
         */
        regionType: number;
    }

    export interface AntiVirusScanProtocolConfig {
        /**
         * The anti virus action. The valid value can be **0** (observe) or **1** (block).
         */
        action: number;
        /**
         * The protocol type.
         * The valid values are as follows:
         * + **0**: HTTP;
         * + **1**: SMTP;
         * + **2**: POP3;
         * + **3**: IMAP4;
         * + **4**: FTP;
         * + **5**: SMB;
         * + **6**: Malicious Access Control;
         */
        protocolType: number;
    }

    export interface CaptureTaskDestination {
        /**
         * Specifies the address.
         */
        address: string;
        /**
         * Specifies the address type.
         * The valid values are:
         * + **0**: indicates IPv4;
         * + **1**: indicates IPv6.
         *
         * <a name="Service"></a>
         * The `service` block supports:
         */
        addressType: number;
    }

    export interface CaptureTaskService {
        /**
         * Specifies the destination port.
         */
        destPort?: string;
        /**
         * Specifies the protocol type.
         * The valid values are:
         * + **6**: indicates TCP;
         * + **17**: indicates UDP;
         * + **1**: indicates ICMP;
         * + **58**: indicates ICMPv6;
         * + **-1**: indicates any protocol.
         */
        protocol: number;
        /**
         * Specifies the source port.
         */
        sourcePort?: string;
    }

    export interface CaptureTaskSource {
        /**
         * Specifies the address.
         */
        address: string;
        /**
         * Specifies the address type.
         * The valid values are:
         * + **0**: indicates IPv4;
         * + **1**: indicates IPv6.
         *
         * <a name="Service"></a>
         * The `service` block supports:
         */
        addressType: number;
    }

    export interface DomainNameGroupDomainName {
        /**
         * Specifies the description.
         */
        description: string;
        /**
         * The DNS IP list.
         */
        dnsIps: string;
        /**
         * The domain address ID.
         */
        domainAddressId: string;
        /**
         * Specifies the domain name.
         */
        domainName: string;
    }

    export interface EipProtectionProtectedEip {
        /**
         * The ID of the protected EIP.
         */
        id: string;
        /**
         * The IPv4 address of the protected EIP.
         */
        publicIpv4: string;
        /**
         * The IPv6 address of the protected EIP.
         *
         * > At least one of `publicIpv4` and `publicIpv6` must be set.
         */
        publicIpv6: string;
    }

    export interface FirewallFlavor {
        /**
         * The bandwidth of the firewall.
         */
        bandwidth: number;
        /**
         * The default bandwidth of the firewall.
         */
        defaultBandwidth: number;
        /**
         * The default EIP number of the firewall.
         */
        defaultEipCount: number;
        /**
         * The default log storage of the firewall.
         */
        defaultLogStorage: number;
        /**
         * The default VPC number of the firewall.
         */
        defaultVpcCount: number;
        /**
         * The EIP number of the firewall.
         */
        eipCount: number;
        /**
         * Specifies the extend bandwidth of the firewall.
         * Only works when the chargingMode is **prePaid**.
         * Changing this parameter will create a new resource.
         */
        extendBandwidth?: number;
        /**
         * Specifies the extend EIP number of the firewall.
         * Only works when the chargingMode is **prePaid**.
         * Changing this parameter will create a new resource.
         */
        extendEipCount?: number;
        /**
         * Specifies the extend VPC number of the firewall.
         * Only works when the chargingMode is **prePaid**.
         * Changing this parameter will create a new resource.
         */
        extendVpcCount?: number;
        /**
         * The log storage of the firewall.
         */
        logStorage: number;
        /**
         * The total rule count of the firewall.
         */
        totalRuleCount: number;
        /**
         * The used rule count of the firewall.
         */
        usedRuleCount: number;
        /**
         * Specifies the version of the firewall.
         * When the chargingMode is **prePaid**: the value can be **Standard** and **Prefessional**.
         * When the chargingMode is **postPaid**: the value can be **Prefessional**.
         * Changing this parameter will create a new resource.
         */
        version: string;
        /**
         * The VPC bandwidth of the firewall.
         */
        vpcBandwidth: number;
        /**
         * The VPC number of the firewall.
         */
        vpcCount: number;
    }

    export interface FirewallProtectObject {
        /**
         * The protected object ID.
         */
        objectId: string;
        /**
         * The protected object name.
         */
        objectName: string;
        /**
         * The object type.
         * The options are as follows: 0: north-south; 1: east-west.
         */
        type: number;
    }

    export interface GetAccessControlLogsRecord {
        /**
         * Specifies the action. The values can be **allow** and **deny**.
         */
        action: string;
        /**
         * Specifies the application protocol.
         */
        app: string;
        /**
         * The destination city ID.
         */
        dstCityId: string;
        /**
         * Specifies the destination city name.
         */
        dstCityName: string;
        /**
         * The destination host.
         */
        dstHost: string;
        /**
         * Specifies the destination IP address.
         */
        dstIp: string;
        /**
         * Specifies the destination port.
         */
        dstPort: number;
        /**
         * The destination province ID.
         */
        dstProvinceId: string;
        /**
         * Specifies the destination province name.
         */
        dstProvinceName: string;
        /**
         * The destination region ID.
         */
        dstRegionId: string;
        /**
         * Specifies the destination region name.
         */
        dstRegionName: string;
        /**
         * The hit time.
         */
        hitTime: string;
        /**
         * The document ID.
         */
        logId: string;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The rule ID.
         */
        ruleId: string;
        /**
         * Specifies the rule name.
         */
        ruleName: string;
        /**
         * The source city ID.
         */
        srcCityId: string;
        /**
         * Specifies the source city name.
         */
        srcCityName: string;
        /**
         * Specifies the source IP address.
         */
        srcIp: string;
        /**
         * Specifies the source port.
         */
        srcPort: number;
        /**
         * The source province ID.
         */
        srcProvinceId: string;
        /**
         * Specifies the source province name.
         */
        srcProvinceName: string;
        /**
         * The source region ID.
         */
        srcRegionId: string;
        /**
         * Specifies the source region name.
         */
        srcRegionName: string;
    }

    export interface GetAddressGroupMembersRecord {
        /**
         * Specifies the IP address
         */
        address: string;
        /**
         * The address type.
         */
        addressType: number;
        /**
         * The address group member description.
         */
        description: string;
        /**
         * Specifies the address group member ID.
         */
        itemId: string;
    }

    export interface GetAddressGroupsAddressGroup {
        /**
         * Specifies the IP address type.
         * The value can be **0** (IPv4) or **1** (IPv6).
         */
        addressType: number;
        /**
         * The address groups description.
         */
        description: string;
        /**
         * The ID of the IP address group.
         */
        id: string;
        /**
         * Specifies the name of the address group.
         */
        name: string;
        /**
         * Specifies the protected object ID.
         */
        objectId: string;
        /**
         * The number of times this address group has been referenced.
         */
        refCount: number;
        /**
         * The address group type.
         */
        type: number;
    }

    export interface GetAttackLogsRecord {
        /**
         * The action.
         */
        action: string;
        /**
         * Specifies the application protocol.
         */
        app: string;
        /**
         * Specifies the intrusion event rule.
         */
        attackRule: string;
        /**
         * Specifies the attack rule ID.
         */
        attackRuleId: string;
        /**
         * Specifies the intrusion event type.
         */
        attackType: string;
        /**
         * The direction.
         */
        direction: string;
        /**
         * The destination city ID.
         */
        dstCityId: string;
        /**
         * Specifies the destination city name.
         */
        dstCityName: string;
        /**
         * Specifies the destination IP address.
         */
        dstIp: string;
        /**
         * Specifies the destination port.
         */
        dstPort: number;
        /**
         * The destination province ID.
         */
        dstProvinceId: string;
        /**
         * Specifies the destination province name.
         */
        dstProvinceName: string;
        /**
         * The destination region ID.
         */
        dstRegionId: string;
        /**
         * Specifies the destination region name.
         */
        dstRegionName: string;
        /**
         * The event time.
         */
        eventTime: string;
        /**
         * Specifies the threat level.
         */
        level: string;
        /**
         * The log ID.
         */
        logId: string;
        /**
         * The attack log packet.
         */
        packet: string;
        /**
         * The packet length.
         */
        packetLength: number;
        /**
         * The packet messages.
         */
        packetMessages: outputs.Cfw.GetAttackLogsRecordPacketMessage[];
        /**
         * The protocol.
         */
        protocol: string;
        /**
         * The source.
         */
        source: string;
        /**
         * The source city ID.
         */
        srcCityId: string;
        /**
         * Specifies the source city name.
         */
        srcCityName: string;
        /**
         * Specifies the source IP address.
         */
        srcIp: string;
        /**
         * Specifies the source port.
         */
        srcPort: number;
        /**
         * The source province ID.
         */
        srcProvinceId: string;
        /**
         * Specifies the source province name.
         */
        srcProvinceName: string;
        /**
         * The source region ID.
         */
        srcRegionId: string;
        /**
         * Specifies the source region name.
         */
        srcRegionName: string;
    }

    export interface GetAttackLogsRecordPacketMessage {
        /**
         * The hexadecimal index.
         */
        hexIndex: string;
        /**
         * The hexadecimal series.
         */
        hexs: string[];
        /**
         * The utf-8 string.
         */
        utf8String: string;
    }

    export interface GetBlackWhiteListsRecord {
        /**
         * Specifies the IP address.
         */
        address: string;
        /**
         * Specifies the IP address type.
         * The valid value can be **0** (IPv4).
         */
        addressType: string;
        /**
         * Specifies the description.
         */
        description: string;
        /**
         * Specifies the direction of a black or white address.
         * The options are as follows:
         * + **0**: source address;
         * + **1**: destination address;
         */
        direction: string;
        /**
         * Specifies the blacklist/whitelist ID.
         */
        listId: string;
        /**
         * Specifies the port.
         */
        port: string;
        /**
         * Specifies The protocol type.
         * The options are as follows:
         * + **6**: TCP;
         * + **17**: UDP;
         * + **1**: ICMP;
         * + **-1**: any protocol;
         */
        protocol: number;
    }

    export interface GetCaptureTaskResultsFileList {
        /**
         * The file name.
         */
        fileName: string;
        /**
         * The file path.
         */
        filePath: string;
        /**
         * The download link.
         */
        url: string;
    }

    export interface GetCaptureTaskResultsRequestHeader {
        /**
         * The host header information.
         */
        host: string;
    }

    export interface GetCaptureTasksRecord {
        /**
         * The capture task size.
         */
        captureSize: string;
        /**
         * The creation time of the capture task.
         */
        createdAt: string;
        /**
         * The destination address.
         */
        destAddress: string;
        /**
         * The destination address type.
         */
        destAddressType: number;
        /**
         * The destination port.
         */
        destPort: string;
        /**
         * The capture task duration.
         */
        duration: number;
        /**
         * Whether is deleted.
         */
        isDeleted: number;
        /**
         * The max packets.
         */
        maxPackets: number;
        /**
         * The capture task name.
         */
        name: string;
        /**
         * The protocol type.
         */
        protocol: number;
        /**
         * The remaining days.
         */
        remainingDays: number;
        /**
         * The source address.
         */
        sourceAddress: string;
        /**
         * The source address type.
         */
        sourceAddressType: number;
        /**
         * The source port.
         */
        sourcePort: string;
        /**
         * The capture task status.
         */
        status: number;
        /**
         * The capture task ID.
         */
        taskId: string;
        /**
         * The update time of the capture task.
         */
        updatedAt: string;
    }

    export interface GetDomainNameGroupsRecord {
        /**
         * Specifies the configuration status.
         * The valid values are as follows:
         * + **-1**: not configured.
         * + **0**: configuration failed.
         * + **1**: configuration succeeded.
         * + **2**: configuration in progress.
         * + **3**: normal.
         * + **4**: configuration exception - domain group usage.
         */
        configStatus: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The list of domain names.
         */
        domainNames: outputs.Cfw.GetDomainNameGroupsRecordDomainName[];
        /**
         * Specifies the domain name group ID.
         */
        groupId: string;
        /**
         * The configuration message.
         */
        message: string;
        /**
         * Specifies the name of a domain name group.
         */
        name: string;
        /**
         * Specifies the domain name group reference count.
         */
        refCount: string;
        /**
         * The used rule list.
         */
        rules: outputs.Cfw.GetDomainNameGroupsRecordRule[];
        /**
         * Specifies the domain name group type.
         * The value can be:
         * + **0**: means application type;
         * + **1**: means network type.
         */
        type: string;
    }

    export interface GetDomainNameGroupsRecordDomainName {
        /**
         * The description.
         */
        description: string;
        /**
         * The domain address ID.
         */
        domainAddressId: string;
        /**
         * The domain name.
         */
        domainName: string;
    }

    export interface GetDomainNameGroupsRecordRule {
        /**
         * The rule ID.
         */
        id: string;
        /**
         * Specifies the name of a domain name group.
         */
        name: string;
    }

    export interface GetFirewallsRecord {
        /**
         * The billing mode. The value can be 0 (yearly/monthly) or 1 (pay-per-use).
         */
        chargeMode: number;
        /**
         * The engine type.
         */
        engineType: number;
        /**
         * The map of feature toggle.
         */
        featureToggle: {[key: string]: boolean};
        /**
         * The flavor of the firewall.
         * The Flavor structure is documented below.
         */
        flavors: outputs.Cfw.GetFirewallsRecordFlavor[];
        /**
         * Specifies the firewall instance ID.
         * If not specified, the first instance will be returned.
         */
        fwInstanceId: string;
        /**
         * The cluster type.
         */
        haType: number;
        /**
         * Whether the engine is an old engine.
         */
        isOldFirewallInstance: boolean;
        /**
         * The firewall name.
         */
        name: string;
        /**
         * The project list.
         * The Protect Object structure is documented below.
         */
        protectObjects: outputs.Cfw.GetFirewallsRecordProtectObject[];
        /**
         * The firewall instance resources.
         * The Firewall Instance Resource structure is
         * documented below.
         */
        resources: outputs.Cfw.GetFirewallsRecordResource[];
        /**
         * Specifies the service type. The value can be:
         * + **0**: North-south firewall;
         * + **1**: East-west firewall;
         */
        serviceType: number;
        /**
         * The firewall status. The options are as follows:
         * + **-1**: waiting for payment;
         * + **0**: creating;
         * + **1**: deleting;
         * + **2**: running;
         * + **3**: upgrading;
         * + **4**: deletion completed;
         * + **5**: freezing;
         * + **6**: creation failed;
         * + **7**: deletion failed;
         * + **8**: freezing failed;
         * + **9**: storage in progress;
         * + **10**: storage failed;
         * + **11**: upgrade failed;
         */
        status: number;
        /**
         * Whether IPv6 is supported.
         */
        supportIpv6: boolean;
    }

    export interface GetFirewallsRecordFlavor {
        /**
         * The bandwidth.
         */
        bandwidth: number;
        /**
         * The number of EIPs.
         */
        eipCount: number;
        /**
         * The log storage.
         */
        logStorage: number;
        /**
         * The firewall version. The value can be 0 (standard edition), 1 (professional edition),
         * 2 (platinum edition), or 3 (basic edition).
         */
        version: number;
        /**
         * The number of VPCs.
         */
        vpcCount: number;
    }

    export interface GetFirewallsRecordProtectObject {
        /**
         * The protected object ID.
         */
        objectId: string;
        /**
         * The protected object name.
         */
        objectName: string;
        /**
         * The project type. The options are as follows:
         * + **0**: north-south;
         * + **1**: east-west;
         */
        type: number;
    }

    export interface GetFirewallsRecordResource {
        /**
         * Service type, which is used by CBC. The value is **hws.service.type.cfw**.
         */
        cloudServiceType: string;
        /**
         * Resource ID.
         */
        resourceId: string;
        /**
         * Resource quantity.
         */
        resourceSize: number;
        /**
         * Resource unit name.
         */
        resourceSizeMeasureId: number;
        /**
         * Inventory unit code.
         */
        resourceSpecCode: string;
        /**
         * Resource type. The options are as follows:
         * + **CFW**: hws.resource.type.cfw;
         * + **EIP**: hws.resource.type.cfw.exp.eip;
         * + **Bandwidth**: hws.resource.type.cfw.exp.bandwidth;
         * + **VPC**: hws.resource.type.cfw.exp.vpc;
         * + **Log storage**: hws.resource.type.cfw.exp.logaudit;
         */
        resourceType: string;
    }

    export interface GetFlowLogsRecord {
        /**
         * Specifies the application protocol.
         */
        app: string;
        /**
         * The flow log bytes.
         */
        bytes: number;
        /**
         * Specifies the direction. The values can be **out2in** and **in2out**.
         */
        direction: string;
        /**
         * The destination city ID.
         */
        dstCityId: string;
        /**
         * Specifies the destination city name.
         */
        dstCityName: string;
        /**
         * The destination host.
         */
        dstHost: string;
        /**
         * Specifies the destination IP address.
         */
        dstIp: string;
        /**
         * Specifies the destination port.
         */
        dstPort: number;
        /**
         * The destination province ID.
         */
        dstProvinceId: string;
        /**
         * Specifies the destination province name.
         */
        dstProvinceName: string;
        /**
         * The destination region ID.
         */
        dstRegionId: string;
        /**
         * Specifies the destination region name.
         */
        dstRegionName: string;
        /**
         * Specifies the end time. The time is in UTC.
         * The format is **yyyy-MM-dd HH:mm:ss**.
         */
        endTime: string;
        /**
         * The document ID.
         */
        logId: string;
        /**
         * The number of packets.
         */
        packets: number;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The source city ID.
         */
        srcCityId: string;
        /**
         * Specifies the source city name.
         */
        srcCityName: string;
        /**
         * Specifies the source IP address.
         */
        srcIp: string;
        /**
         * Specifies the source port.
         */
        srcPort: number;
        /**
         * The source province ID.
         */
        srcProvinceId: string;
        /**
         * Specifies the source province name.
         */
        srcProvinceName: string;
        /**
         * The source region ID.
         */
        srcRegionId: string;
        /**
         * Specifies the source region name.
         */
        srcRegionName: string;
        /**
         * Specifies the start time. The time is in UTC.
         * The format is **yyyy-MM-dd HH:mm:ss**.
         */
        startTime: string;
    }

    export interface GetIpsCustomRulesRecord {
        /**
         * The action.
         */
        action: number;
        /**
         * Specifies the affected OS.
         * The valid values are as follows:
         * + **1**: Windows;
         * + **2**: Linux;
         * + **3**: FreeBSD;
         * + **4**: Solaris;
         * + **5**: Other Unix;
         * + **6**: Network device;
         * + **7**: MAC OS;
         * + **8**: IOS;
         * + **9**: Android;
         * + **10**: Other;
         */
        affectedOs: number;
        /**
         * Specifies the attack type.
         * The valid values are as follows:
         * + **1**: access control;
         * + **2**: vulnerability scan;
         * + **3**: email phishing;
         * + **4**: vulnerability exploits;
         * + **5**: web attack;
         * + **6**: password cracking;
         * + **7**: hijacking attack;
         * + **8**: protocol exception;
         * + **9**: trojan;
         * + **10**: worm;
         * + **11**: buffer overflow;
         * + **12**: hacker tool;
         * + **13**: spyware;
         * + **14**: DDoS flood;
         * + **15**: application-layer DDoS attack;
         * + **16**: other suspicious behavior;
         * + **17**: suspicious DNS activity;
         * + **18**: phishing;
         * + **19**: spam;
         */
        attackType: number;
        /**
         * The rule status.
         */
        configStatus: number;
        /**
         * The content storage in JSON format.
         */
        content: string;
        /**
         * The destination port type.
         */
        dstPortType: number;
        /**
         * The destination port.
         */
        dstPorts: string;
        /**
         * The firewall cluster ID.
         */
        groupId: string;
        /**
         * The ID of a custom IPS rule in CFW.
         */
        ipsCfwId: string;
        /**
         * The ID of a rule in Hillstone.
         */
        ipsId: string;
        /**
         * Specifies the IPS custom rule name.
         */
        ipsName: string;
        /**
         * Specifies the protocol.
         * The valid values are as follows:
         * + **1**: FTP;
         * + **2**: TELNET;
         * + **3**: SMTP;
         * + **4**: DNS-TCP;
         * + **5**: DNS-UDP;
         * + **6**: DHCP;
         * + **7**: TFTP;
         * + **8**: FINGER;
         * + **9**: HTTP;
         * + **10**: POP3;
         * + **11**: SUNRPC-TCP;
         * + **12**: SUNRPC-UDP;
         * + **13**: NNTP;
         * + **14**: MSRPC-TCP;
         * + **15**: MSRPC-UDP;
         * + **16**: NETBIOS-NAME_TCP;
         * + **17**: NETBIOS-NAME_UDP;
         * + **18**: NETBIOS-SMB;
         * + **19**: NETBIOS-DATAGRAM;
         * + **20**: IMAP4;
         * + **21**: SNMP;
         * + **22**: LDAP;
         * + **23**: MSSQL;
         * + **24**: ORACLE;
         * + **25**: MYSQL;
         * + **26**: VOIP-SIP-TCP;
         * + **27**: VOIP-SIP-UDP;
         * + **28**: VOIP-H245;
         * + **29**: VOIP-Q931;
         * + **30**: OTHER-TCP;
         * + **31**: OTHER-UDP;
         */
        protocol: number;
        /**
         * Specifies the severity.
         * The valid values are as follows:
         * + **0**: critical;
         * + **1**: high;
         * + **2**: medium;
         * + **3**: low;
         */
        severity: number;
        /**
         * Specifies the affected software.
         * The valid values are as follows:
         * + **1**: ADOBE;
         * + **2**: APACHE;
         * + **3**: APPLE;
         * + **4**: CA;
         * + **5**: CISCO;
         * + **6**: GOOGLE CHROME;
         * + **7**: HP;
         * + **8**: IBM;
         * + **9**: IE;
         * + **10**: IIS;
         * + **11**: MCAFEE;
         * + **12**: MEDIAPLAYER;
         * + **13**: MICROSOFT.NET;
         * + **14**: MICROSOFT EDGE;
         * + **15**: MICROSOFT EXCHANGE;
         * + **16**: MICROSOFT OFFICE;
         * + **17**: MICROSOFT OUTLOOK;
         * + **18**: MICROSOFT SHAREPOINT;
         * + **19**: MICROSOFT WINDOWS;
         * + **20**: MOZILLA;
         * + **21**: MSSQL;
         * + **22**: MYSQL;
         * + **23**: NOVELL;
         * + **24**: ORACLE;
         * + **25**: SAMBA;
         * + **26**: SAMSUNG;
         * + **27**: SAP;
         * + **28**: SCADA;
         * + **29**: SQUID;
         * + **30**: SUN;
         * + **31**: SYMANTEC;
         * + **32**: TREND MICRO;
         * + **33**: VMWARE;
         * + **34**: WORDPRESS;
         * + **35**: OTHER;
         */
        software: number;
        /**
         * The source port type.
         */
        srcPortType: number;
        /**
         * The source port.
         */
        srcPorts: string;
    }

    export interface GetIpsRuleDetailsData {
        /**
         * The IPS type.
         */
        ipsType: number;
        /**
         * The IPS version.
         */
        ipsVersion: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface GetIpsRulesRecord {
        /**
         * The application affected by the rule.
         */
        affectedApplication: string;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The default status of the IPS rule.
         */
        defaultStatus: string;
        /**
         * The CVE.
         */
        ipsCve: string;
        /**
         * The IPS rule group.
         */
        ipsGroup: string;
        /**
         * Specifies the IPS rule ID.
         */
        ipsId: string;
        /**
         * The risk level.
         */
        ipsLevel: string;
        /**
         * The IPS rule name.
         */
        ipsName: string;
        /**
         * The IPS rule type.
         */
        ipsRulesType: string;
        /**
         * Specifies the IPS rule status.
         * The valid value can be **OBSERVE**, **ENABLE**, or **CLOSE**.
         */
        ipsStatus: string;
    }

    export interface GetProtectionRulesRecord {
        /**
         * Specifies the rule action type.
         * The options are as follows:
         * + **0**: allow;
         * + **1**: deny.
         */
        actionType: string;
        /**
         * The address type.
         */
        addressType: number;
        /**
         * The created time of a rule.
         */
        createdDate: string;
        /**
         * The custom service description.
         */
        description: string;
        /**
         * Specifies the destination address.
         */
        destinations: outputs.Cfw.GetProtectionRulesRecordDestination[];
        /**
         * Specifies the rule direction.
         * The options are as follows:
         * + **0**: inbound;
         * + **1**: outbound.
         */
        direction: string;
        /**
         * The last open time.
         */
        lastOpenTime: string;
        /**
         * Whether to support persistent connections.
         */
        longConnectEnable: number;
        /**
         * The persistent connection duration.
         */
        longConnectTime: number;
        /**
         * The persistent connection duration (hour).
         */
        longConnectTimeHour: number;
        /**
         * The persistent connection duration (minute).
         */
        longConnectTimeMinute: number;
        /**
         * The persistent connection duration (second).
         */
        longConnectTimeSecond: number;
        /**
         * Specifies the rule name.
         */
        name: string;
        /**
         * Specifies the rule ID.
         */
        ruleId: string;
        /**
         * The service.
         */
        services: outputs.Cfw.GetProtectionRulesRecordService[];
        /**
         * Specifies the source address.
         */
        sources: outputs.Cfw.GetProtectionRulesRecordSource[];
        /**
         * Specifies the rule status.
         * The options are as follows:
         * + **0**: disabled;
         * + **1**: enabled.
         */
        status: string;
        /**
         * Specifies the key/value pairs to associate with the protection rule.
         * Tags should have only one key/value pair.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the rule type.
         * The value can be **0** (Internet rule), **1** (VPC rule), or **2** (NAT rule).
         */
        type: string;
    }

    export interface GetProtectionRulesRecordDestination {
        /**
         * The source IP address.
         */
        address: string;
        /**
         * The address group.
         */
        addressGroups: string[];
        /**
         * The ID of the associated IP address group.
         */
        addressSetId: string;
        /**
         * The IP address group name.
         */
        addressSetName: string;
        /**
         * The address set type.
         */
        addressSetType: number;
        /**
         * The address type.
         */
        addressType: number;
        /**
         * The name of the domain address.
         */
        domainAddressName: string;
        /**
         * The ID of the domain group.
         */
        domainSetId: string;
        /**
         * The name of domain group.
         */
        domainSetName: string;
        /**
         * The IP address list.
         */
        ipAddresses: string[];
        /**
         * The region list of a rule.
         */
        regionLists: outputs.Cfw.GetProtectionRulesRecordDestinationRegionList[];
        /**
         * Specifies the rule type.
         * The value can be **0** (Internet rule), **1** (VPC rule), or **2** (NAT rule).
         */
        type: number;
    }

    export interface GetProtectionRulesRecordDestinationRegionList {
        /**
         * The Chinese description of a region.
         */
        descriptionCn: string;
        /**
         * The English description of a region.
         */
        descriptionEn: string;
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The region type.
         */
        regionType: number;
    }

    export interface GetProtectionRulesRecordService {
        /**
         * The custom service.
         */
        customServices: outputs.Cfw.GetProtectionRulesRecordServiceCustomService[];
        /**
         * The destination port.
         */
        destPort: string;
        /**
         * The protocol type of the custom service.
         */
        protocol: number;
        /**
         * The protocols.
         */
        protocols: number[];
        /**
         * The service group list.
         */
        serviceGroups: string[];
        /**
         * The service group ID.
         */
        serviceSetId: string;
        /**
         * The service group name.
         */
        serviceSetName: string;
        /**
         * The service set type.
         */
        serviceSetType: number;
        /**
         * The source port of the custom service.
         */
        sourcePort: string;
        /**
         * Specifies the rule type.
         * The value can be **0** (Internet rule), **1** (VPC rule), or **2** (NAT rule).
         */
        type: number;
    }

    export interface GetProtectionRulesRecordServiceCustomService {
        /**
         * The custom service description.
         */
        description: string;
        /**
         * The destination port.
         */
        destPort: string;
        /**
         * Specifies the rule name.
         */
        name: string;
        /**
         * The protocol type of the custom service.
         */
        protocol: number;
        /**
         * The source port of the custom service.
         */
        sourcePort: string;
    }

    export interface GetProtectionRulesRecordSource {
        /**
         * The source IP address.
         */
        address: string;
        /**
         * The address group.
         */
        addressGroups: string[];
        /**
         * The ID of the associated IP address group.
         */
        addressSetId: string;
        /**
         * The IP address group name.
         */
        addressSetName: string;
        /**
         * The address set type.
         */
        addressSetType: number;
        /**
         * The address type.
         */
        addressType: number;
        /**
         * The name of the domain address.
         */
        domainAddressName: string;
        /**
         * The IP address list.
         */
        ipAddresses: string[];
        /**
         * The region list of a rule.
         */
        regionLists: outputs.Cfw.GetProtectionRulesRecordSourceRegionList[];
        /**
         * Specifies the rule type.
         * The value can be **0** (Internet rule), **1** (VPC rule), or **2** (NAT rule).
         */
        type: number;
    }

    export interface GetProtectionRulesRecordSourceRegionList {
        /**
         * The Chinese description of a region.
         */
        descriptionCn: string;
        /**
         * The English description of a region.
         */
        descriptionEn: string;
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The region type.
         */
        regionType: number;
    }

    export interface GetResourceTagsTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface GetServiceGroupMembersRecord {
        /**
         * The service group member description.
         */
        description: string;
        /**
         * Specifies the destination port.
         */
        destPort: string;
        /**
         * Specifies the service group member ID.
         */
        itemId: string;
        /**
         * Specifies the protocol type.
         * The options are as follows:
         * + **6**: TCP;
         * + **17**: UDP;
         * + **1**: ICMP.
         */
        protocol: number;
        /**
         * Specifies the source port.
         */
        sourcePort: string;
    }

    export interface GetServiceGroupsServiceGroup {
        /**
         * The description of the service group.
         */
        description: string;
        /**
         * The service group ID.
         */
        id: string;
        /**
         * Specifies the name of the service group.
         */
        name: string;
        /**
         * The protocols of the service group.
         */
        protocols: number[];
        /**
         * The number of times this service group has been referenced.
         */
        refCount: number;
        /**
         * The type of the Service group.
         */
        type: number;
    }

    export interface GetTagsTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag values.
         */
        values: string[];
    }

}

export namespace Css {
    export interface ClusterBackupStrategy {
        /**
         * Specifies the IAM agency used to access OBS.
         *
         * > **NOTE:**  If the `bucket`, `backupPath`, and `agency` parameters are empty at the same time, the system will
         * automatically create an OBS bucket and IAM agent, otherwise the configured parameter values will be used.
         */
        agency: string;
        /**
         * Specifies the storage path of the snapshot in the OBS bucket.
         */
        backupPath: string;
        /**
         * Specifies the OBS bucket used for index data backup. If there is snapshot data in an OBS
         * bucket, only the OBS bucket is used and cannot be changed.
         */
        bucket: string;
        /**
         * Specifies the number of days to retain the generated snapshots. Snapshots are reserved
         * for seven days by default.
         */
        keepDays?: number;
        /**
         * Specifies the prefix of the snapshot that is automatically created. Defaults to **snapshot**.
         */
        prefix?: string;
        /**
         * Specifies the time when a snapshot is automatically created everyday. Snapshots can
         * only be created on the hour. The time format is the time followed by the time zone, specifically, **HH:mm z**. In the
         * format, **HH:mm** refers to the hour time and z refers to the time zone. For example, "00:00 GMT+08:00"
         * and "01:00 GMT+08:00".
         */
        startTime: string;
    }

    export interface ClusterClientNodeConfig {
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `masterNodeConfig`, The value range is `3` to `10`.
         * + When it is `clientNodeConfig`, The value range is `1` to `32`.
         */
        instanceNumber: number;
        /**
         * Specifies the node IDs that needs to be scaled down.
         *
         * <a name="Css_master_or_client_volume"></a>
         * The `volume` block supports:
         */
        shrinkNodeIds?: string[];
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterClientNodeConfigVolume;
    }

    export interface ClusterClientNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         *
         * <a name="Css_public_access"></a>
         * The `publicAccess` block supports:
         */
        volumeType: string;
    }

    export interface ClusterColdNodeConfig {
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `masterNodeConfig`, The value range is `3` to `10`.
         * + When it is `clientNodeConfig`, The value range is `1` to `32`.
         */
        instanceNumber: number;
        /**
         * Specifies the node IDs that needs to be scaled down.
         *
         * <a name="Css_master_or_client_volume"></a>
         * The `volume` block supports:
         */
        shrinkNodeIds?: string[];
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterColdNodeConfigVolume;
    }

    export interface ClusterColdNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         *
         * <a name="Css_public_access"></a>
         * The `publicAccess` block supports:
         */
        volumeType: string;
    }

    export interface ClusterEssNodeConfig {
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `masterNodeConfig`, The value range is `3` to `10`.
         * + When it is `clientNodeConfig`, The value range is `1` to `32`.
         */
        instanceNumber: number;
        /**
         * Specifies the node IDs that needs to be scaled down.
         *
         * <a name="Css_master_or_client_volume"></a>
         * The `volume` block supports:
         */
        shrinkNodeIds?: string[];
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterEssNodeConfigVolume;
    }

    export interface ClusterEssNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         *
         * <a name="Css_public_access"></a>
         * The `publicAccess` block supports:
         */
        volumeType: string;
    }

    export interface ClusterKibanaPublicAccess {
        /**
         * Specifies the public network bandwidth.
         */
        bandwidth: number;
        publicIp: string;
        /**
         * Specifies the whitelist of access control. The whitelisted account id must be unique.
         */
        whitelist?: string;
        /**
         * Specifies whether to enable the public network access control.
         */
        whitelistEnabled: boolean;
    }

    export interface ClusterMasterNodeConfig {
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        /**
         * Specifies the number of cluster instances.
         * + When it is `masterNodeConfig`, The value range is `3` to `10`.
         * + When it is `clientNodeConfig`, The value range is `1` to `32`.
         */
        instanceNumber: number;
        /**
         * Specifies the node IDs that needs to be scaled down.
         *
         * <a name="Css_master_or_client_volume"></a>
         * The `volume` block supports:
         */
        shrinkNodeIds?: string[];
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterMasterNodeConfigVolume;
    }

    export interface ClusterMasterNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         *
         * <a name="Css_public_access"></a>
         * The `publicAccess` block supports:
         */
        volumeType: string;
    }

    export interface ClusterNode {
        /**
         * Specifies the availability zone name.
         * Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
         * than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
         * distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
         * between node quantity in any two AZs is **1** at most.
         */
        availabilityZone: string;
        /**
         * Instance ID.
         */
        id: string;
        /**
         * Instance IP address.
         */
        ip: string;
        /**
         * Specifies the cluster name. It contains `4` to `32` characters.
         * Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
         * Changing this parameter will create a new resource.
         */
        name: string;
        /**
         * The resource ID of this instance.
         */
        resourceId: string;
        /**
         * Instance specification code.
         */
        specCode: string;
        /**
         * Instance status.
         */
        status: string;
        /**
         * Node type. The options are as follows:
         * + **ess-master:** Indicates a master node.
         * + **ess-client:** Indicates a client node.
         * + **ess-cold:** Indicates a cold data node.
         * + **ess indicates:** Indicates a data node.
         */
        type: string;
    }

    export interface ClusterNodeConfig {
        /**
         * Specifies the availability zone name.
         * Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
         * than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
         * distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
         * between node quantity in any two AZs is **1** at most.
         */
        availabilityZone: string;
        /**
         * Specifies the flavor name.
         */
        flavor: string;
        networkInfo: outputs.Css.ClusterNodeConfigNetworkInfo;
        /**
         * Specifies the information about the volume.
         * The volume structure is documented below.
         */
        volume: outputs.Css.ClusterNodeConfigVolume;
    }

    export interface ClusterNodeConfigNetworkInfo {
        /**
         * Specifies the security group ID.
         */
        securityGroupId: string;
        /**
         * Specifies the Subnet ID.
         * Changing this parameter will create a new resource.
         */
        subnetId: string;
        /**
         * Specifies the VPC ID.
         * Changing this parameter will create a new resource.
         */
        vpcId: string;
    }

    export interface ClusterNodeConfigVolume {
        /**
         * Specifies the volume size in **GB**, which must be a multiple of `10`.
         */
        size: number;
        /**
         * Specifies the volume type. Value options are as follows:
         * + **COMMON**: Common I/O. The SATA disk is used.
         * + **HIGH**: High I/O. The SAS disk is used.
         * + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
         *
         * <a name="Css_public_access"></a>
         * The `publicAccess` block supports:
         */
        volumeType: string;
    }

    export interface ClusterPublicAccess {
        /**
         * Specifies the public network bandwidth.
         */
        bandwidth: number;
        publicIp: string;
        /**
         * Specifies the whitelist of access control. The whitelisted account id must be unique.
         */
        whitelist?: string;
        /**
         * Specifies whether to enable the public network access control.
         */
        whitelistEnabled: boolean;
    }

    export interface ClusterVpcepEndpoint {
        /**
         * Specifies whether to enable the private domain name.
         */
        endpointWithDnsName: boolean;
        /**
         * Specifies the whitelist of access control. The whitelisted account id must be unique.
         */
        whitelists?: string[];
    }

    export interface GetFlavorsFlavor {
        availabilityZones: string;
        /**
         * The disk capacity range of an instance, in GB.
         */
        diskRange: string;
        /**
         * The ID of CSS flavor.
         */
        id: string;
        /**
         * Specifies the memory size(GB) in the CSS flavor.
         */
        memory: number;
        /**
         * Specifies the name of the CSS flavor.
         */
        name: string;
        /**
         * Specifies the region in which to obtain the CSS flavors. If omitted, the
         * provider-level region will be used.
         */
        region: string;
        /**
         * Specifies the node instance type. The options are `ess`, `ess-cold`, `ess-master`
         * and `ess-client`.
         */
        type: string;
        /**
         * Specifies the number of vCPUs in the CSS flavor.
         */
        vcpus: number;
        /**
         * Specifies the engine version. The options are `5.5.1`, `6.2.3`, `6.5.4`, `7.1.1`,
         * `7.6.2` and `7.9.3`.
         */
        version: string;
    }

}

export namespace Cts {
    export interface NotificationFilter {
        condition: string;
        rules: string[];
    }

    export interface NotificationOperation {
        /**
         * Specifies the resource type.
         */
        resource: string;
        /**
         * Specifies the cloud service.
         */
        service: string;
        /**
         * Specifies an array of trace names.
         *
         * <a name="notificationOperationUsersObject"></a>
         * The `operationUsers` block supports:
         */
        traceNames: string[];
    }

    export interface NotificationOperationUser {
        /**
         * Specifies the IAM user group name.
         */
        group: string;
        /**
         * Specifies an array of IAM users in the group.
         */
        users: string[];
    }

}

export namespace Dcs {
    export interface GetFlavorsFlavor {
        /**
         * An array of available zones where the cache specification can be used.
         */
        availableZones: string[];
        /**
         * The mode of a cache engine. The valid values are as follows:
         */
        cacheMode: string;
        /**
         * The total memory of the cache, in GB.
         * + **Redis4.0 and Redis5.0**: Stand-alone and active/standby type instance values:
         * `1`, `2`, `4`, `8`, `16`, `32` and `64`.
         * Cluster instance specifications support `24`, `32`, `48`, `64`, `96`, `128`, `192`, `256`, `384`, `512`, `768` and
         * `1024`.
         * + **Redis3.0**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
         * Proxy cluster instance specifications support `64`, `128`, `256`, `512`, and `1024`.
         * + **Memcached**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
         */
        capacity: number;
        /**
         * The charging modes for the specification cache instance.
         * + `Hourly` - Pay-per-use.
         * + `Monthly` - Pay monthly.
         * + `Yearly` - Annual payment.
         */
        chargingModes: string[];
        /**
         * The CPU architecture of cache instance.
         * Valid values *x86_64* and *aarch64*.
         */
        cpuArchitecture: string;
        /**
         * The engine of the cache instance. Valid values are *Redis* and *Memcached*.
         * Default value is *Redis*.
         */
        engine: string;
        /**
         * Supported versions of the specification.
         */
        engineVersions: string;
        /**
         * Number of IP addresses corresponding to the specifications.
         */
        ipCount: number;
        /**
         * The flavor name of the cache instance.
         */
        name: string;
    }

    export interface InstanceBackupPolicy {
        /**
         * Day in a week on which backup starts, the value ranges from `1` to `7`.
         * Where: 1 indicates Monday; 7 indicates Sunday.
         */
        backupAts: number[];
        /**
         * Backup type. Default value is `auto`. The valid values are as follows:
         */
        backupType?: string;
        /**
         * Time at which backup starts.
         * Format: `hh24:00-hh24:00`, "00:00-01:00" indicates that backup starts at 00:00:00.
         *
         * <a name="DcsInstance_Parameters"></a>
         * The `parameters` block supports:
         */
        beginAt: string;
        /**
         * Interval at which backup is performed. Default value is `weekly`.
         * Currently, only weekly backup is supported.
         */
        periodType?: string;
        /**
         * Retention time. Unit: day, the value ranges from `1` to `7`.
         * This parameter is required if the backupType is **auto**.
         */
        saveDays?: number;
    }

    export interface InstanceBandwidthInfo {
        /**
         * Indicates the bandwidth size, the unit is **GB**.
         */
        bandwidth: number;
        /**
         * Indicates the begin time of temporary increase.
         */
        beginTime: string;
        /**
         * Indicates the current time.
         */
        currentTime: string;
        /**
         * Indicates the end time of temporary increase.
         */
        endTime: string;
        /**
         * Indicates the number of increases.
         */
        expandCount: number;
        /**
         * Indicates the interval between temporary increases, the unit is **ms**.
         */
        expandEffectTime: number;
        /**
         * Indicates the time interval to the next increase, the unit is **ms**.
         */
        expandIntervalTime: number;
        /**
         * Indicates the maximum number of increases.
         */
        maxExpandCount: number;
        /**
         * Indicates the next increase time.
         */
        nextExpandTime: string;
        /**
         * Indicates whether the increase task is running.
         */
        taskRunning: boolean;
    }

    export interface InstanceParameter {
        /**
         * A resource ID in UUID format.
         */
        id: string;
        /**
         * Specifies the name of an instance.
         * The name must be 4 to 64 characters and start with a letter.
         * Only english, letters (case-insensitive), digits, underscores (_) ,and hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the value of the configuration item.
         */
        value: string;
    }

    export interface InstanceWhitelist {
        /**
         * Specifies the name of IP address group.
         */
        groupName: string;
        /**
         * Specifies the list of IP address or CIDR which can be whitelisted for an instance.
         * The maximum is 20.
         */
        ipAddresses: string[];
    }

}

export namespace Dds {
    export interface GetFlavorsFlavor {
        /**
         * Specifies the ram of the dds flavor in GB.
         */
        memory: string;
        specCode: string;
        /**
         * Specifies the type of the dds falvor. "mongos", "shard", "config", "replica" and "single" are supported.
         */
        type: string;
        /**
         * Specifies the vcpus of the dds flavor.
         */
        vcpus: string;
    }

    export interface InstanceBackupStrategy {
        /**
         * Specifies the number of days to retain the generated backup files. The value range is
         * from 0 to 732.
         * + If this parameter is set to 0, the automated backup policy is not set.
         * + If this parameter is not transferred, the automated backup policy is enabled by default. Backup files are stored
         * for seven days by default.
         */
        keepDays: number;
        /**
         * Specifies the charging period of the instance.
         * If `periodUnit` is set to *month*, the value ranges from 1 to 9.
         * If `periodUnit` is set to *year*, the value ranges from 1 to 3.
         * This parameter is mandatory if `chargingMode` is set to *prePaid*.
         * Changing this creates a new instance.
         */
        period: string;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. The value cannot be empty. It must be a valid value in the
         * "hh:mm-HH:MM" format. The current time is in the UTC format.
         * + The HH value must be 1 greater than the hh value.
         * + The values from mm and MM must be the same and must be set to any of the following 00, 15, 30, or 45.
         */
        startTime: string;
    }

    export interface InstanceConfiguration {
        /**
         * Specifies the ID of the template.
         * Changing this creates a new instance.
         */
        id: string;
        /**
         * Specifies the node type. Valid value:
         * + For a Community Edition cluster instance, the value can be **mongos**, **shard** or **config**.
         * + For a Community Edition replica set instance, the value is **replica**.
         * + For a Community Edition single node instance, the value is **single**.
         * Changing this creates a new instance.
         */
        type: string;
    }

    export interface InstanceDatastore {
        /**
         * Specifies the storage engine of the DB instance.
         * If `version` is set to `3.2`, `3.4`, or `4.0`, the value is **wiredTiger**.
         * If `periodUnit` is set to `4.2`, or `4.4`, the value is **rocksDB**.
         */
        storageEngine?: string;
        /**
         * Specifies the DB engine. **DDS-Community** is supported.
         */
        type: string;
        /**
         * Specifies the DB instance version. For the Community Edition, the valid
         * values are `3.2`, `3.4`, `4.0`, `4.2`, or `4.4`.
         */
        version: string;
    }

    export interface InstanceFlavor {
        /**
         * Specifies the node quantity. Valid value:
         * + In a Community Edition cluster instance,the number of mongos ranges from 2 to 16.
         * + In a Community Edition cluster instance,the number of shards ranges from 2 to 16.
         * + In an Enhanced Edition cluster instance, the number of shards ranges from 2 to 12.
         * + config: the value is 1.
         * + replica: the value is 1.
         * + single: The value is 1. This parameter can be updated when the value of `type` is mongos or shard.
         */
        num: number;
        /**
         * Specifies the disk size. The value must be a multiple of 10. The unit is GB. This parameter
         * is mandatory for nodes except mongos and invalid for mongos. This parameter can be updated when the value of `type` is
         * shard, replica or single.
         */
        size?: number;
        /**
         * Specifies the resource specification code. In a cluster instance, multiple
         * specifications need to be specified. All specifications must be of the same series, that is, general-purpose (s6),
         * enhanced (c3), or enhanced II (c6). For example:
         * + dds.mongodb.s6.large.4.mongos and dds.mongodb.s6.large.4.config have the same specifications.
         * + dds.mongodb.s6.large.4.mongos and dds.mongodb.c3.large.4.config are not of the same specifications. This parameter
         * can be updated when the value of `type` is mongos, shard, replica or single.
         */
        specCode: string;
        /**
         * Specifies the disk type.
         * Valid value: **ULTRAHIGH** which indicates the type SSD.
         */
        storage?: string;
        /**
         * Specifies the node type. Valid value:
         * + For a Community Edition cluster instance, the value can be **mongos**, **shard**, or **config**.
         * + For an Enhanced Edition cluster instance, the value is **shard**.
         * + For a Community Edition replica set instance, the value is **replica**.
         * + For a Community Edition single node instance, the value is **single**.
         */
        type: string;
    }

    export interface InstanceGroup {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type is unique in the
         * same tenant.
         */
        name: string;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.Dds.InstanceGroupNode[];
        /**
         * Specifies the disk size. The value must be a multiple of 10. The unit is GB. This parameter
         * is mandatory for nodes except mongos and invalid for mongos. This parameter can be updated when the value of `type` is
         * shard, replica or single.
         */
        size: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type.
         */
        type: string;
        used: string;
    }

    export interface InstanceGroupNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type is unique in the
         * same tenant.
         */
        name: string;
        /**
         * Indicates the private IP address of a node. This parameter is valid only for mongos nodes, replica set
         * instances, and single node instances.
         */
        privateIp: string;
        /**
         * Indicates the EIP that has been bound on a node. This parameter is valid only for mongos nodes of
         * cluster instances, primary nodes and secondary nodes of replica set instances, and single node instances.
         */
        publicIp: string;
        /**
         * Indicates the node role.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type.
         */
        type: string;
    }

    export interface InstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type is unique in the
         * same tenant.
         */
        name: string;
        /**
         * Indicates the private IP address of a node. This parameter is valid only for mongos nodes, replica set
         * instances, and single node instances.
         */
        privateIp: string;
        /**
         * Indicates the EIP that has been bound on a node. This parameter is valid only for mongos nodes of
         * cluster instances, primary nodes and secondary nodes of replica set instances, and single node instances.
         */
        publicIp: string;
        /**
         * Indicates the node role.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type.
         */
        type: string;
    }

}

export namespace DedicatedApig {
    export interface ApiBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiFuncGraph {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The alias URN of the FunctionGraph function.
         */
        functionAliasUrn?: string;
        /**
         * The URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * The invocation type.
         */
        invocationType?: string;
        /**
         * The network architecture (framework) type of the FunctionGraph function.
         */
        networkType?: string;
        /**
         * The request protocol of the FunctionGraph function.
         */
        requestProtocol?: string;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The version of the FunctionGraph function.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The configaiton list of the backend parameters.
         */
        backendParams?: outputs.DedicatedApig.ApiFuncGraphPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.DedicatedApig.ApiFuncGraphPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The alias URN of the FunctionGraph function.
         */
        functionAliasUrn?: string;
        /**
         * The URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * The invocation mode of the FunctionGraph function.
         */
        invocationMode?: string;
        /**
         * The invocation mode of the FunctionGraph function.
         */
        invocationType?: string;
        /**
         * The name of the backend policy.
         */
        name: string;
        /**
         * The network (framework) type of the FunctionGraph function.
         */
        networkType?: string;
        /**
         * The request protocol of the FunctionGraph function.
         */
        requestProtocol?: string;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The version of the FunctionGraph function.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiFuncGraphPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface ApiMock {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The response content of the mock.
         */
        response?: string;
        /**
         * The custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The configuration list of backend parameters.
         */
        backendParams?: outputs.DedicatedApig.ApiMockPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.DedicatedApig.ApiMockPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The backend policy name.
         */
        name: string;
        /**
         * The response content of the mock.
         */
        response?: string;
        /**
         * The custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiMockPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface ApiPublishmentHistory {
        /**
         * The version description of the API publishment.
         */
        description: string;
        /**
         * The version ID of the API publishment.
         */
        versionId: string;
    }

    export interface ApiRequestParam {
        /**
         * The default value of the parameter.
         */
        default: string;
        /**
         * The parameter description.
         */
        description: string;
        /**
         * The enumerated value.
         */
        enumeration: string;
        /**
         * The parameter example.
         */
        example: string;
        /**
         * Where this parameter is located.
         */
        location?: string;
        /**
         * The maximum value or length (string parameter) for parameter.
         */
        maximum: number;
        /**
         * The minimum value or length (string parameter) for parameter.
         */
        minimum: number;
        /**
         * The name of the request parameter.
         */
        name: string;
        /**
         * The list of orchestration rules that parameter used.
         */
        orchestrations?: string[];
        /**
         * Whether to transparently transfer the parameter.
         */
        passthrough: boolean;
        /**
         * Whether this parameter is required.
         */
        required: boolean;
        /**
         * The parameter type.
         */
        type?: string;
        /**
         * Whether to enable the parameter validation.
         */
        validEnable: number;
    }

    export interface ApiWeb {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The backend service address, which consists of a domain name or IP address, and a port number.
         */
        backendAddress?: string;
        /**
         * The proxy host header.
         */
        hostHeader?: string;
        /**
         * The backend request path.
         */
        path: string;
        /**
         * The backend request method of the API.
         */
        requestMethod?: string;
        /**
         * The web protocol type of the API request.
         */
        requestProtocol?: string;
        /**
         * The number of retry attempts to request the backend service.
         */
        retryCount?: number;
        /**
         * Whether to enable two-way authentication.
         */
        sslEnable?: boolean;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The VPC channel ID.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The backend service address
         */
        backendAddress?: string;
        /**
         * The configuration list of the backend parameters.
         */
        backendParams?: outputs.DedicatedApig.ApiWebPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.DedicatedApig.ApiWebPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The proxy host header.
         */
        hostHeader?: string;
        /**
         * The name of the web policy.
         */
        name: string;
        /**
         * The backend request address.
         */
        path: string;
        /**
         * The backend request method of the API.
         */
        requestMethod: string;
        /**
         * The backend request protocol.
         */
        requestProtocol?: string;
        /**
         * The number of retry attempts to request the backend service.
         */
        retryCount?: number;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The VPC channel ID.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiWebPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface CustomAuthorizerIdentity {
        /**
         * The parameter location.
         */
        location: string;
        /**
         * The name of the parameter to be verified.
         */
        name: string;
        /**
         * The parameter verification expression.
         */
        validation?: string;
    }

    export interface GetEnvironmentsEnvironment {
        createTime: string;
        description: string;
        id: string;
        name: string;
    }

    export interface GroupEnvironment {
        /**
         * The ID of the environment to which the variables belongs.
         */
        environmentId: string;
        /**
         * The array of one or more environment variables.
         */
        variables: outputs.DedicatedApig.GroupEnvironmentVariable[];
    }

    export interface GroupEnvironmentVariable {
        /**
         * The ID of the variable that the group has.
         */
        id: string;
        /**
         * The variable name.
         */
        name: string;
        /**
         * The variable value.
         */
        value: string;
        /**
         * schema: Deprecated; The ID of the variable that the group has.
         *
         * @deprecated Use 'id' instead
         */
        variableId: string;
    }

    export interface GroupUrlDomain {
        /**
         * Whether to enable redirection from HTTP to HTTPS.
         */
        isHttpRedirectToHttps: boolean;
        /**
         * The minimum SSL protocol version.
         */
        minSslVersion: string;
        /**
         * The associated domain name.
         */
        name: string;
    }

    export interface InstanceCustomIngressPort {
        /**
         * The ID of the custom ingress port.
         */
        id: string;
        /**
         * Specified port of the custom ingress port.
         */
        port: number;
        /**
         * Specified protocol of the custom ingress port.
         */
        protocol: string;
        /**
         * The current status of the custom ingress port.
         */
        status: string;
    }

    export interface ResponseRule {
        /**
         * The body template of the API custom response rule.
         */
        body: string;
        /**
         * The error type of the API custom response rule.
         */
        errorType: string;
        /**
         * The configuration of the custom response headers.
         */
        headers?: outputs.DedicatedApig.ResponseRuleHeader[];
        /**
         * The HTTP status code of the API custom response rule.
         */
        statusCode: number;
    }

    export interface ResponseRuleHeader {
        /**
         * The key name of the response header.
         */
        key: string;
        /**
         * The value for the specified response header key.
         */
        value: string;
    }

    export interface ThrottlingPolicyAppThrottle {
        /**
         * The ID of the special user/application throttling policy.
         */
        id: string;
        /**
         * The maximum number of times an API can be accessed within a specified period.
         */
        maxApiRequests: number;
        /**
         * The object ID which the special throttling policy belongs.
         */
        throttlingObjectId: string;
        /**
         * The object name which the special user/application throttling policy belongs.
         */
        throttlingObjectName: string;
    }

    export interface ThrottlingPolicyUserThrottle {
        /**
         * The ID of the special user/application throttling policy.
         */
        id: string;
        /**
         * The maximum number of times an API can be accessed within a specified period.
         */
        maxApiRequests: number;
        /**
         * The object ID which the special throttling policy belongs.
         */
        throttlingObjectId: string;
        /**
         * The object name which the special user/application throttling policy belongs.
         */
        throttlingObjectName: string;
    }

}

export namespace Dew {
    export interface GetKeypairsKeypair {
        /**
         * Specifies the fingerprint of the keypair.
         */
        fingerprint: string;
        /**
         * Indicates whether the private key is managed by sberCloud.
         */
        isManaged: boolean;
        /**
         * Specifies the name of the keypair.
         */
        name: string;
        /**
         * Specifies the imported OpenSSH-formatted public key.
         */
        publicKey: string;
        /**
         * Indicates the scope of keypair. The value can be **account**or **user**.
         */
        scope: string;
    }

}

export namespace Dis {
    export interface StreamPartition {
        /**
         * Possible value range of the hash key used by each partition.
         */
        hashRange: string;
        /**
         * The ID of the partition.
         */
        id: string;
        /**
         * Sequence number range of each partition.
         */
        sequenceNumberRange: string;
        /**
         * The status of the partition.
         */
        status: string;
    }

}

export namespace Dli {
    export interface QueueScalingPolicy {
        impactStartTime: string;
        impactStopTime: string;
        maxCu: number;
        minCu: number;
        priority: number;
    }

    export interface QueueSparkDriver {
        maxConcurrent?: number;
        maxInstance?: number;
        maxPrefetchInstance?: string;
    }

    export interface SparkJobDependentPackage {
        /**
         * Specifies the user group name.
         * Changing this parameter will submit a new spark job.
         */
        groupName: string;
        /**
         * Specifies the user group resource for details.
         * Changing this parameter will submit a new spark job.
         * The object structure is documented below.
         *
         * <a name="dependentPackagesPackages"></a>
         * The `packages` block supports:
         */
        packages: outputs.Dli.SparkJobDependentPackagePackage[];
    }

    export interface SparkJobDependentPackagePackage {
        /**
         * Specifies the resource name of the package.
         * Changing this parameter will submit a new spark job.
         */
        packageName: string;
        /**
         * Specifies the resource type of the package.
         * Changing this parameter will submit a new spark job.
         */
        type: string;
    }

}

export namespace Dms {
    export interface GetFlavorsFlavor {
        /**
         * The list of supported CPU architectures.
         */
        archTypes: string[];
        /**
         * The list of supported billing modes.
         */
        chargingModes: string[];
        /**
         * The flavor ID.
         */
        id: string;
        /**
         * The list of supported disk IO types.
         * The object structure is documented below.
         */
        ios: outputs.Dms.GetFlavorsFlavorIo[];
        /**
         * The function property details.
         * The object structure is documented below.
         */
        properties: outputs.Dms.GetFlavorsFlavorProperty[];
        /**
         * The list of features supported by the current specification.
         * The object structure is documented below.
         */
        supportFeatures: outputs.Dms.GetFlavorsFlavorSupportFeature[];
        /**
         * Specifies flavor type. The valid values are **single**, **cluster** and **cluster.small**.
         */
        type: string;
        /**
         * The underlying VM specification.
         */
        vmSpecification: string;
    }

    export interface GetFlavorsFlavorIo {
        /**
         * Specifies the list of availability zones with available resources.
         */
        availabilityZones: string[];
        /**
         * Specifies the disk IO encoding.
         * + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
         * + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
         */
        storageSpecCode: string;
        /**
         * Specifies flavor type. The valid values are **single**, **cluster** and **cluster.small**.
         */
        type: string;
        /**
         * The list of unavailability zones with available resources.
         */
        unavailabilityZones: string[];
    }

    export interface GetFlavorsFlavorProperty {
        /**
         * The flavor ID alias.
         */
        flavorAlias: string;
        /**
         * The maximum bandwidth per broker.
         */
        maxBandwidthPerBroker: number;
        /**
         * The maximum number of brokers.
         */
        maxBroker: number;
        /**
         * The maximum number of consumers per broker.
         */
        maxConsumerPerBroker: number;
        /**
         * The maximum number of partitions per broker.
         */
        maxPartitionPerBroker: number;
        /**
         * The maximum storage per node. The unit is GB.
         */
        maxStoragePerNode: number;
        /**
         * The maximum TPS per broker.
         */
        maxTpsPerBroker: number;
        /**
         * The minimum number of brokers.
         */
        minBroker: number;
        /**
         * The minimum storage per node. The unit is GB.
         */
        minStoragePerNode: number;
    }

    export interface GetFlavorsFlavorSupportFeature {
        /**
         * The function name, e.g. **connector_obs**.
         */
        name: string;
        /**
         * The function property details.
         * The object structure is documented below.
         */
        properties: outputs.Dms.GetFlavorsFlavorSupportFeatureProperty[];
    }

    export interface GetFlavorsFlavorSupportFeatureProperty {
        /**
         * The maximum number of nodes for the dump function.
         */
        maxNode: number;
        /**
         * The maximum number of tasks for the dump function.
         */
        maxTask: number;
        /**
         * The minimum number of nodes for the dump function.
         */
        minNode: number;
        /**
         * The minimum number of tasks for the dump function.
         */
        minTask: number;
    }

    export interface GetInstancesInstance {
        /**
         * The access username.
         */
        accessUser: string;
        /**
         * The list of AZ names.
         */
        availabilityZones: string[];
        /**
         * The IP address for instance connection.
         */
        connectAddress: string;
        /**
         * Indicates the Access information of cross-VPC. The structure is documented below.
         */
        crossVpcAccesses: outputs.Dms.GetInstancesInstanceCrossVpcAccess[];
        /**
         * The instance description.
         */
        description: string;
        /**
         * Whether to dumping is enabled.
         */
        dumping: boolean;
        /**
         * Whether to enable automatic topic creation.
         */
        enableAutoTopic: boolean;
        /**
         * Whether public access to the instance is enabled.
         */
        enablePublicIp: boolean;
        enabledMechanisms: string[];
        /**
         * The kafka engine version.
         */
        engineVersion: string;
        /**
         * Specifies the enterprise project ID to which all instances of the list
         * belong.
         */
        enterpriseProjectId: string;
        /**
         * The instance ID.
         */
        id: string;
        /**
         * The time at which a maintenance time window starts, the format is `HH:mm`.
         */
        maintainBegin: string;
        /**
         * The time at which a maintenance time window ends, the format is `HH:mm`.
         */
        maintainEnd: string;
        /**
         * The connection address of the Kafka manager of an instance.
         */
        managementConnectAddress: string;
        /**
         * The username for logging in to the Kafka Manager.
         */
        managerUser: string;
        /**
         * @deprecated typo in manegement_connect_address, please use "managementConnectAddress" instead.
         */
        manegementConnectAddress: string;
        /**
         * Specifies the kafka instance name for data-source queries.
         */
        name: string;
        /**
         * The subnet ID to which the instance belongs.
         */
        networkId: string;
        /**
         * The maximum number of topics in the DMS kafka instance.
         */
        partitionNum: number;
        /**
         * The port number.
         */
        port: number;
        /**
         * The product ID used by the instance.
         */
        productId: string;
        /**
         * The instance public access address.
         * The format of each connection address is `{IP address}:{port}`.
         */
        publicConnAddresses: string;
        /**
         * The IDs of the elastic IP address (EIP).
         */
        publicIpIds: string[];
        /**
         * The resource specifications identifier.
         */
        resourceSpecCode: string;
        /**
         * The action to be taken when the memory usage reaches the disk capacity threshold.
         */
        retentionPolicy: string;
        /**
         * The security group ID associated with the instance.
         */
        securityGroupId: string;
        securityProtocol: string;
        /**
         * Whether the Kafka SASL_SSL is enabled.
         */
        sslEnable: boolean;
        /**
         * Specifies the kafka instance status for data-source queries.
         */
        status: string;
        /**
         * The message storage capacity, in GB unit.
         */
        storageSpace: number;
        /**
         * The storage I/O specification.
         */
        storageSpecCode: string;
        /**
         * The key/value pairs to associate with the instance.
         */
        tags: {[key: string]: string};
        /**
         * The instance type.
         */
        type: string;
        /**
         * The used message storage space, in GB unit.
         */
        usedStorageSpace: number;
        /**
         * The user ID who created the instance.
         */
        userId: string;
        /**
         * The username who created the instance.
         */
        userName: string;
        /**
         * The VPC ID to which the instance belongs.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceCrossVpcAccess {
        /**
         * The advertised IP Address.
         */
        advertisedIp: string;
        /**
         * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
         */
        lisenterIp: string;
        /**
         * The listener IP address.
         */
        listenerIp: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The port ID associated with the address
         */
        portId: string;
    }

    export interface KafkaInstanceCrossVpcAccess {
        /**
         * The advertised IP Address or domain name.
         */
        advertisedIp: string;
        /**
         * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
         */
        lisenterIp: string;
        /**
         * The listener IP address.
         */
        listenerIp: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The port ID associated with the address.
         */
        portId: string;
    }

    export interface KafkaInstanceParameter {
        /**
         * Specifies the name of the DMS Kafka instance. An instance name starts with a letter,
         * consists of 4 to 64 characters, and supports only letters, digits, hyphens (-) and underscores (_).
         */
        name: string;
        value: string;
    }

    export interface KafkaInstancePortProtocol {
        privatePlainAddress: string;
        privatePlainDomainName: string;
        privatePlainEnable: boolean;
        privateSaslPlaintextAddress: string;
        privateSaslPlaintextDomainName: string;
        privateSaslPlaintextEnable: boolean;
        privateSaslSslAddress: string;
        privateSaslSslDomainName: string;
        privateSaslSslEnable: boolean;
        publicPlainAddress: string;
        publicPlainDomainName: string;
        publicPlainEnable: boolean;
        publicSaslPlaintextAddress: string;
        publicSaslPlaintextDomainName: string;
        publicSaslPlaintextEnable: boolean;
        publicSaslSslAddress: string;
        publicSaslSslDomainName: string;
        publicSaslSslEnable: boolean;
    }

    export interface KafkaPermissionsPolicy {
        /**
         * Specifies the permissions type. The value can be:
         * + **all**: publish and subscribe permissions.
         * + **pub**: publish permissions.
         * + **sub**: subscribe permissions.
         */
        accessPolicy: string;
        /**
         * Specifies the username.
         */
        userName: string;
    }

    export interface KafkaTopicConfig {
        /**
         * Specifies the name of the topic. The name starts with a letter, consists of 4 to
         * 64 characters, and supports only letters, digits, hyphens (-) and underscores (_). Changing this creates a new
         * resource.
         */
        name: string;
        value: string;
    }

}

export namespace Dns {
    export interface ZoneRouter {
        /**
         * ID of the associated VPC.
         */
        routerId: string;
        /**
         * The region of the VPC.
         */
        routerRegion: string;
    }

}

export namespace Drs {
    export interface JobDestinationDb {
        /**
         * Specifies the migration engine type.
         * Changing this parameter will create a new resource. The options are as follows:
         * + **mysql**:  MySQL migration, MySQL synchronization use.
         * + **mongodb**: Mongodb migration use.
         * + **cloudDataGuard-mysql**: Disaster recovery use.
         * + **gaussdbv5**: GaussDB (for openGauss) synchronization use.
         * + **mysql-to-kafka**: Synchronization from MySQL to Kafka use.
         * + **taurus-to-kafka**: Synchronization from GaussDB(for MySQL) to Kafka use.
         * + **gaussdbv5ha-to-kafka**: Synchronization from GaussDB primary/standby to Kafka use.
         * + **postgresql**: Synchronization from PostgreSQL to PostgreSQL use.
         */
        engineType: string;
        /**
         * Specifies the instance id of database when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        instanceId?: string;
        /**
         * Specifies the IP of database. Changing this parameter will create a new resource.
         */
        ip: string;
        /**
         * Specifies the job name. The name consists of 4 to 50 characters, starting with
         * a letter. Only letters, digits, underscores (\_) and hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the password of database.
         * Changing this parameter will create a new resource.
         */
        password: string;
        /**
         * Specifies the port of database. Changing this parameter will create a new resource.
         */
        port: number;
        /**
         * The region in which to create the resource. If omitted, the
         * provider-level region will be used. Changing this parameter will create a new resource.
         */
        region: string;
        /**
         * Specifies the checksum of SSL certificate content.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertCheckSum?: string;
        /**
         * Specifies the SSL certificate content, encrypted with base64.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertKey?: string;
        /**
         * Specifies SSL certificate name.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertName?: string;
        /**
         * Specifies SSL certificate password. It is mandatory when
         * `sslEnabled` is `true` and the certificate file suffix is `.p12`. Changing this parameter will create a new resource.
         */
        sslCertPassword?: string;
        /**
         * Specifies whether to enable SSL connection.
         * Changing this parameter will create a new resource.
         */
        sslEnabled?: boolean;
        /**
         * Specifies subnet ID of database when it is a RDS database.
         * It is mandatory when `direction` is `down`. Changing this parameter will create a new resource.
         */
        subnetId?: string;
        /**
         * Specifies the user name of database.
         * Changing this parameter will create a new resource.
         */
        user: string;
    }

    export interface JobLimitSpeed {
        /**
         * Specifies the time to end speed limit, this time is UTC time. The input must
         * end at 59 minutes, the format is `hh:mm`, for example: 15:59. Changing this parameter will create a new resource.
         */
        endTime: string;
        /**
         * Specifies the transmission speed, the value range is 1 to 9999, unit: `MB/s`.
         * Changing this parameter will create a new resource.
         */
        speed: string;
        /**
         * Specifies the time to start speed limit, this time is UTC time. The start
         * time is the whole hour, if there is a minute, it will be ignored, the format is `hh:mm`, and the hour number
         * is two digits, for example: 01:00. Changing this parameter will create a new resource.
         */
        startTime: string;
    }

    export interface JobSourceDb {
        /**
         * Specifies the migration engine type.
         * Changing this parameter will create a new resource. The options are as follows:
         * + **mysql**:  MySQL migration, MySQL synchronization use.
         * + **mongodb**: Mongodb migration use.
         * + **cloudDataGuard-mysql**: Disaster recovery use.
         * + **gaussdbv5**: GaussDB (for openGauss) synchronization use.
         * + **mysql-to-kafka**: Synchronization from MySQL to Kafka use.
         * + **taurus-to-kafka**: Synchronization from GaussDB(for MySQL) to Kafka use.
         * + **gaussdbv5ha-to-kafka**: Synchronization from GaussDB primary/standby to Kafka use.
         * + **postgresql**: Synchronization from PostgreSQL to PostgreSQL use.
         */
        engineType: string;
        /**
         * Specifies the instance id of database when it is a RDS database.
         * Changing this parameter will create a new resource.
         */
        instanceId?: string;
        /**
         * Specifies the IP of database. Changing this parameter will create a new resource.
         */
        ip: string;
        /**
         * Specifies the job name. The name consists of 4 to 50 characters, starting with
         * a letter. Only letters, digits, underscores (\_) and hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the password of database.
         * Changing this parameter will create a new resource.
         */
        password: string;
        /**
         * Specifies the port of database. Changing this parameter will create a new resource.
         */
        port: number;
        /**
         * The region in which to create the resource. If omitted, the
         * provider-level region will be used. Changing this parameter will create a new resource.
         */
        region: string;
        /**
         * Specifies the checksum of SSL certificate content.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertCheckSum?: string;
        /**
         * Specifies the SSL certificate content, encrypted with base64.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertKey?: string;
        /**
         * Specifies SSL certificate name.
         * It is mandatory when `sslEnabled` is `true`. Changing this parameter will create a new resource.
         */
        sslCertName?: string;
        /**
         * Specifies SSL certificate password. It is mandatory when
         * `sslEnabled` is `true` and the certificate file suffix is `.p12`. Changing this parameter will create a new resource.
         */
        sslCertPassword?: string;
        /**
         * Specifies whether to enable SSL connection.
         * Changing this parameter will create a new resource.
         */
        sslEnabled?: boolean;
        /**
         * Specifies subnet ID of database when it is a RDS database.
         * It is mandatory when `direction` is `down`. Changing this parameter will create a new resource.
         */
        subnetId?: string;
        /**
         * Specifies the user name of database.
         * Changing this parameter will create a new resource.
         */
        user: string;
    }

}

export namespace Dws {
    export interface ClusterElb {
        /**
         * The cluster ID
         */
        id: string;
        /**
         * Cluster name, which must be unique and contains 4 to 64 characters, which
         * consist of letters, digits, hyphens(-), or underscores(_) only and must start with a letter.
         * Changing this creates a new cluster resource.
         */
        name: string;
        /**
         * The private endpoint of the ELB load balancer.
         */
        privateEndpoint: string;
        /**
         * List of private network IP address.
         */
        privateIp: string;
        /**
         * The IPv6 address of the ELB load balancer.
         */
        privateIpV6: string;
        /**
         * A nested object resource Structure is documented below.
         * Changing this creates a new cluster resource.
         */
        publicIp: string;
        /**
         * VPC ID, which is used for configuring cluster network.
         * Changing this creates a new cluster resource.
         */
        vpcId: string;
    }

    export interface ClusterEndpoint {
        /**
         * (Optional, String) Private network connection information.
         */
        connectInfo: string;
        /**
         * (Optional, String)
         * JDBC URL. The following is the default format:
         * jdbc:postgresql://< public_connect_info>/<YOUR_DATABASE_NAME>
         */
        jdbcUrl: string;
    }

    export interface ClusterMaintainWindow {
        /**
         * Maintenance time in each week in the unit of day.
         */
        day: string;
        /**
         * Maintenance end time in HH:mm format. The time zone is GMT+0.
         */
        endTime: string;
        /**
         * Maintenance start time in HH:mm format. The time zone is GMT+0.
         */
        startTime: string;
    }

    export interface ClusterPublicEndpoint {
        /**
         * (Optional, String)
         * JDBC URL. The following is the default format:
         * jdbc:postgresql://< public_connect_info>/<YOUR_DATABASE_NAME>
         */
        jdbcUrl: string;
        /**
         * (Optional, String)
         * Public network connection information.
         */
        publicConnectInfo: string;
    }

    export interface ClusterPublicIp {
        /**
         * EIP ID.
         * Changing this creates a new cluster resource.
         */
        eipId?: string;
        /**
         * Binding type of an EIP. The value can be either of the following:
         * **auto_assign**, **not_use**, **bind_existing**. The default value is **not_use**.
         * Changing this creates a new cluster resource.
         */
        publicBindType: string;
    }

    export interface ClusterVolume {
        /**
         * The capacity size, in GB.
         */
        capacity: string;
        /**
         * The volume type.
         */
        type: string;
    }

    export interface GetFlaovrsFlavor {
        /**
         * The list of availability zones.
         */
        availabilityZones: string[];
        /**
         * The type of datastore.  
         * The options are as follows:
         * - **dws**: OLAP, elastic scaling, unlimited scaling of compute and storage capacity.
         * - **hybrid**: a single data warehouse used for transaction and analytics workloads,
         * in single-node or cluster mode.
         * - **stream**: built-in time series operators; up to 40:1 compression ratio; applicable to IoT services.
         */
        datastoreType: string;
        /**
         * The version of datastore.
         */
        datastoreVersion: string;
        /**
         * The ElasticVolumeSpec structure is documented below.
         */
        elasticVolumeSpecs: outputs.Dws.GetFlaovrsFlavorElasticVolumeSpec[];
        /**
         * The name of the dws node flavor.  
         * It is referenced by `nodeType` in `sbercloud.Dws.getFlaovrs`.
         */
        flavorId: string;
        /**
         * The ram of the dws node flavor in GB.
         */
        memory: number;
        /**
         * The default disk size in GB.
         */
        size: number;
        /**
         * The vcpus of the dws node flavor.
         */
        vcpus: number;
        /**
         * Disk type.  
         * The options are as follows:
         * - **LOCAL_DISK**:common I/O disk.
         * - **SSD**: ultra-high I/O disk.
         */
        volumetype: string;
    }

    export interface GetFlaovrsFlavorElasticVolumeSpec {
        /**
         * Maximum disk size.
         */
        maxSize: number;
        /**
         * Minimum disk size.
         */
        minSize: number;
        /**
         * Disk size increment step.
         */
        step: number;
    }

}

export namespace Ecs {
    export interface GetFlavorsFlavor {
        /**
         * Specifies the number of vCPUs in the ECS flavor.
         */
        cpuCoreCount: number;
        /**
         * Specifies the generation of an ECS type.
         */
        generation: string;
        /**
         * Specifies a data source ID in UUID format.
         */
        id: string;
        /**
         * Specifies the memory size(GB) in the ECS flavor.
         */
        memorySize: number;
        /**
         * Specifies the ECS flavor type.
         */
        performanceType: string;
        storageType: string;
    }

    export interface GetInstanceNetwork {
        /**
         * Specifies the IPv4 addresses of the ECS.
         */
        fixedIpV4: string;
        /**
         * The Fixed IPv6 address of the instance on that network.
         */
        fixedIpV6: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
        /**
         * The network UUID to attach to the server.
         */
        uuid: string;
    }

    export interface GetInstanceSchedulerHint {
        /**
         * The UUID of a Server Group where the instance will be placed into.
         */
        group: string;
    }

    export interface GetInstanceVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: number;
        /**
         * Whether the volume is the system disk.
         */
        isSysVolume: boolean;
        /**
         * The volume pci address on that attachment.
         */
        pciAddress: string;
        /**
         * The volume size on that attachment.
         */
        size: number;
        /**
         * The volume type on that attachment.
         */
        type: string;
        /**
         * The volume id on that attachment.
         */
        volumeId: string;
    }

    export interface GetInstancesInstance {
        /**
         * Specifies the availability zone where the instance is located.
         * Please following [reference](https://support.hc.sbercloud.ru/endpoint/index.html) for this argument.
         */
        availabilityZone: string;
        chargingMode: string;
        /**
         * Specifies the enterprise project ID.
         */
        enterpriseProjectId: string;
        expiredTime: string;
        /**
         * Specifies the flavor ID.
         */
        flavorId: string;
        /**
         * Specifies the flavor name of the instance.
         */
        flavorName: string;
        /**
         * The instance ID in UUID format.
         */
        id: string;
        /**
         * Specifies the image ID of the instance.
         */
        imageId: string;
        /**
         * The image name of the instance.
         */
        imageName: string;
        /**
         * Specifies the key pair that is used to authenticate the instance.
         */
        keyPair: string;
        /**
         * Specifies the instance name, which can be queried with a regular expression.
         * The instance name supports fuzzy matching query too.
         */
        name: string;
        networks: outputs.Ecs.GetInstancesInstanceNetwork[];
        /**
         * The EIP address that is associted to the instance.
         */
        publicIp: string;
        /**
         * The scheduler with hints on how the instance should be launched.
         * The object structure is documented below.
         */
        schedulerHints: outputs.Ecs.GetInstancesInstanceSchedulerHint[];
        /**
         * An array of one or more security group IDs to associate with the instance.
         */
        securityGroupIds: string[];
        /**
         * Specifies the status of the instance. The valid values are as follows:
         * + **ACTIVE**: The instance is running properly.
         * + **SHUTOFF**: The instance has been properly stopped.
         * + **ERROR**: An error has occurred on the instance.
         */
        status: string;
        /**
         * The system disk voume ID.
         */
        systemDiskId: string;
        /**
         * The key/value pairs to associate with the instance.
         */
        tags: {[key: string]: string};
        /**
         * The user data (information after encoding) configured during instance creation.
         */
        userData: string;
        /**
         * An array of one or more disks to attach to the instance. The object structure is documented below.
         */
        volumeAttacheds: outputs.Ecs.GetInstancesInstanceVolumeAttached[];
    }

    export interface GetInstancesInstanceNetwork {
        /**
         * The fixed IPv4 address of the instance on this network.
         */
        fixedIpV4: string;
        /**
         * The Fixed IPv6 address of the instance on that network.
         */
        fixedIpV6: string;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
        /**
         * The network ID to attach to the server.
         */
        uuid: string;
    }

    export interface GetInstancesInstanceSchedulerHint {
        /**
         * The UUID of a server group where the instance will be placed into.
         */
        group: string;
    }

    export interface GetInstancesInstanceVolumeAttached {
        bootIndex: number;
        /**
         * Whether the volume is the system disk.
         */
        isSysVolume: boolean;
        /**
         * The volume pci address on that attachment.
         */
        pciAddress: string;
        /**
         * The volume size on that attachment.
         */
        size: number;
        /**
         * The volume type on that attachment.
         */
        type: string;
        /**
         * The volume id on that attachment.
         */
        volumeId: string;
    }

    export interface GetServergroupsServergroup {
        /**
         * The server group ID in UUID format.
         */
        id: string;
        /**
         * An array of one or more instance ID attached to the server group.
         */
        members: string[];
        /**
         * Specifies the server group name.
         */
        name: string;
        /**
         * The set of policies for the server group.
         */
        policies: string[];
    }

    export interface InstanceBandwidth {
        /**
         * Specifies the bandwidth billing mode. The value can be *traffic* or *bandwidth*.
         * Changing this creates a new instance.
         */
        chargeMode?: string;
        extendParam?: {[key: string]: string};
        /**
         * Specifies the **shared** bandwidth id. This parameter is mandatory when
         * `shareType` is set to **WHOLE**. Changing this creates a new instance.
         */
        id?: string;
        /**
         * Specifies the bandwidth sharing type. Changing this creates a new instance.
         * Possible values are as follows:
         * + **PER**: Dedicated bandwidth
         * + **WHOLE**: Shared bandwidth
         */
        shareType: string;
        /**
         * Specifies the bandwidth size. The value ranges from 1 to 300 Mbit/s.
         * This parameter is mandatory when `shareType` is set to **PER**. Changing this creates a new instance.
         */
        size?: number;
    }

    export interface InstanceDataDisk {
        dssPoolId?: string;
        iops?: number;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the disk.
         * Changing this creates a new instance.
         */
        kmsKeyId?: string;
        /**
         * Specifies the data disk size, in GB. The value ranges form 10 to 32768.
         * Changing this creates a new instance.
         */
        size: number;
        /**
         * Specifies the snapshot id. Changing this creates a new instance.
         */
        snapshotId?: string;
        throughput?: number;
        /**
         * Specifies the ECS data disk type, which must be one of available disk types,
         * contains of *SSD*, *GPSSD* and *SAS*. Changing this creates a new instance.
         */
        type: string;
    }

    export interface InstanceNetwork {
        /**
         * Specifies if this network should be used for provisioning access.
         * Accepts true or false. Defaults to false.
         */
        accessNetwork?: boolean;
        /**
         * Specifies a fixed IPv4 address to be used on this network.
         * Changing this creates a new instance.
         */
        fixedIpV4: string;
        /**
         * The Fixed IPv6 address of the instance on that network.
         */
        fixedIpV6: string;
        /**
         * Specifies whether the IPv6 function is enabled for the nic.
         * Defaults to false. Changing this creates a new instance.
         */
        ipv6Enable?: boolean;
        /**
         * The MAC address of the NIC on that network.
         */
        mac: string;
        /**
         * The port ID corresponding to the IP address on that network.
         */
        port: string;
        /**
         * Specifies whether the ECS processes only traffic that is destined specifically
         * for it. This function is enabled by default but should be disabled if the ECS functions as a SNAT server or has a
         * virtual IP address bound to it.
         */
        sourceDestCheck?: boolean;
        /**
         * Specifies the network UUID to attach to the instance.
         * Changing this creates a new instance.
         */
        uuid: string;
    }

    export interface InstanceSchedulerHint {
        /**
         * Specifies the ID of DeH.
         * This parameter takes effect only when the value of tenancy is dedicated. Changing this creates a new instance.
         */
        dehId?: string;
        /**
         * schema: Internal
         */
        faultDomain?: string;
        /**
         * Specifies a UUID of a Server Group.
         * The instance will be placed into that group. Changing this creates a new instance.
         */
        group: string;
        /**
         * Specifies the tenancy specifies whether the ECS is to be created on a
         * Dedicated Host
         * (DeH) or in a shared pool. Changing this creates a new instance.
         */
        tenancy?: string;
    }

    export interface InstanceVolumeAttached {
        /**
         * The volume boot index on that attachment.
         */
        bootIndex: number;
        /**
         * Specifies the ID of a KMS key. This is used to encrypt the disk.
         * Changing this creates a new instance.
         */
        kmsKeyId: string;
        /**
         * The volume pci address on that attachment.
         */
        pciAddress: string;
        /**
         * The volume size on that attachment.
         */
        size: number;
        /**
         * The volume type on that attachment.
         */
        type: string;
        /**
         * The volume ID on that attachment.
         */
        volumeId: string;
    }

}

export namespace Eip {
    export interface GetBandwidthPublicip {
        /**
         * The ID of the EIP or IPv6 port that uses the bandwidth.
         */
        id: string;
        /**
         * The IPv4 or IPv6 address.
         */
        ipAddress: string;
        /**
         * The IP version, either 4 or 6.
         */
        ipVersion: number;
        /**
         * The EIP type.
         */
        type: string;
    }

    export interface GetEipsEip {
        /**
         * The bandwidth id of the EIP.
         */
        bandwidthId: string;
        /**
         * The bandwidth name of the EIP.
         */
        bandwidthName: string;
        /**
         * The bandwidth share type of the EIP.
         */
        bandwidthShareType: string;
        /**
         * The bandwidth size of the EIP.
         */
        bandwidthSize: number;
        createdAt: string;
        /**
         * Specifies the enterprise project ID which the desired EIP belongs to.
         */
        enterpriseProjectId: string;
        /**
         * The ID of the EIP.
         */
        id: string;
        /**
         * Specifies ip version of the desired EIP. The options are:
         */
        ipVersion: number;
        /**
         * The name of the EIP.
         */
        name: string;
        /**
         * The port id bound to the EIP.
         */
        portId: string;
        /**
         * The private ip address of the EIP.
         */
        privateIp: string;
        /**
         * The public ip address of the EIP.
         */
        publicIp: string;
        /**
         * The public ipv6 address of the EIP.
         */
        publicIpv6: string;
        /**
         * The status of the EIP.
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired EIP.
         *
         * > A maximum of 10 tag keys are allowed for each query operation. Each tag key can have up to 10 tag values.
         * The tag key cannot be left blank or set to an empty string. Each tag key must be unique, and each tag value in a
         * tag must be unique, use commas(,) to separate the multiple values. An empty for values indicates any value.
         * The values are in the OR relationship.
         */
        tags: {[key: string]: string};
        /**
         * The type of the EIP.
         */
        type: string;
    }

}

export namespace Elb {
    export interface GetListenersListener {
        clientCaTlsContainerRef: string;
        /**
         * The maximum number of connections allowed for the listener.
         */
        connectionLimit: number;
        createdAt: string;
        /**
         * The ID of the default pool with which the ELB listener is associated.
         */
        defaultPoolId: string;
        /**
         * The ID of the server certificate used by the listener.
         */
        defaultTlsContainerRef: string;
        /**
         * The description of the ELB listener.
         */
        description: string;
        /**
         * Whether the ELB listener uses HTTP/2.
         */
        http2Enable: boolean;
        /**
         * The ELB loadbalancer ID.
         */
        id: string;
        insertHeaders: outputs.Elb.GetListenersListenerInsertHeader[];
        /**
         * Listener list.
         * The object structure is documented below.
         */
        loadbalancers: outputs.Elb.GetListenersListenerLoadbalancer[];
        /**
         * The listener name.
         */
        name: string;
        protectionReason: string;
        protectionStatus: string;
        /**
         * The listener protocol.  
         * The valid values are **TCP**, **UDP**, **HTTP** and **TERMINATED_HTTPS**.
         */
        protocol: string;
        /**
         * The front-end listening port of the listener.  
         * The valid value is range from `1` to `65535`.
         */
        protocolPort: number;
        /**
         * List of the SNI certificate (server certificates with a domain name) IDs used by the listener.
         */
        sniContainerRefs: string[];
        tags: {[key: string]: string};
        tlsCiphersPolicy: string;
        updatedAt: string;
    }

    export interface GetListenersListenerInsertHeader {
        xForwardedElbIp: string;
        xForwardedHost: string;
    }

    export interface GetListenersListenerLoadbalancer {
        /**
         * The ELB loadbalancer ID.
         */
        id: string;
    }

    export interface GetPoolsPool {
        /**
         * Specifies the description of the ELB pool.
         */
        description: string;
        /**
         * Specifies the health monitor ID of the ELB pool.
         */
        healthmonitorId: string;
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
        /**
         * Specifies the method of the ELB pool. Must be one of ROUND_ROBIN, LEAST_CONNECTIONS,
         * or SOURCE_IP.
         */
        lbMethod: string;
        /**
         * The listener list. The object structure is documented below.
         */
        listeners: outputs.Elb.GetPoolsPoolListener[];
        /**
         * The loadbalancer list. The object structure is documented below.
         */
        loadbalancers: outputs.Elb.GetPoolsPoolLoadbalancer[];
        /**
         * The member list. The object structure is documented below.
         */
        members: outputs.Elb.GetPoolsPoolMember[];
        /**
         * Specifies the name of the ELB pool.
         */
        name: string;
        /**
         * Indicates whether connections in the same session will be processed by the same pool member or not.
         * The object structure is documented below.
         */
        persistences: outputs.Elb.GetPoolsPoolPersistence[];
        protectionReason: string;
        protectionStatus: string;
        /**
         * Specifies the protocol of the ELB pool. This can either be TCP, UDP or HTTP.
         */
        protocol: string;
    }

    export interface GetPoolsPoolListener {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolLoadbalancer {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolMember {
        /**
         * The listener, loadbalancer or member ID.
         */
        id: string;
    }

    export interface GetPoolsPoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately.
         */
        cookieName: string;
        timeout: number;
        /**
         * The type of persistence mode.
         */
        type: string;
    }

    export interface ListenerInsertHeaders {
        xForwardedElbIp: string;
        xForwardedHost: string;
    }

    export interface PoolPersistence {
        /**
         * The name of the cookie if persistence mode is set appropriately. Required
         * if `type = APP_COOKIE`.
         */
        cookieName?: string;
        /**
         * Specifies the sticky session timeout duration in minutes. This parameter is
         * invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
         * + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
         * + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
         */
        timeout: number;
        /**
         * The type of persistence mode. The current specification supports SOURCE_IP,
         * HTTP_COOKIE, and APP_COOKIE.
         */
        type: string;
    }

}

export namespace Er {
    export interface GetAssociationsAssociation {
        /**
         * Specifies the attachment ID corresponding to the association.
         */
        attachmentId: string;
        /**
         * Specifies the attachment type corresponding to the association.
         */
        attachmentType: string;
        /**
         * The creation time.
         */
        createdAt: string;
        /**
         * The association ID.
         */
        id: string;
        /**
         * The resource ID of the attachment corresponding to the association.
         */
        resourceId: string;
        /**
         * The route policy ID of the egress IPv4 protocol.
         */
        routePolicyId: string;
        /**
         * Specifies the route table ID to which the association belongs.
         */
        routeTableId: string;
        /**
         * Specifies the status of the association. Default value is `available`.
         * The valid values are as follows:
         * + **available**
         * + **failed**
         */
        status: string;
        /**
         * The latest update time.
         */
        updatedAt: string;
    }

    export interface GetAttachmentsAttachment {
        /**
         * Whether this attachment has been associated.
         */
        associated: boolean;
        /**
         * The creation time of the attachment.
         */
        createdAt: string;
        /**
         * The description of the attachment.
         */
        description: string;
        /**
         * The attachment ID.
         */
        id: string;
        /**
         * Specifies the name used to filter the attachments.
         */
        name: string;
        /**
         * Specifies the associated resource ID used to filter the attachments.
         */
        resourceId: string;
        /**
         * The associated route table ID.
         */
        routeTableId: string;
        /**
         * Specifies the status used to filter the attachments.
         * The valid values are as follows:
         * + **available**
         * + **failed**
         * + **pending_acceptance**
         * + **rejected**
         */
        status: string;
        /**
         * The key/value pairs used to filter the attachments.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the resource type to be filtered.  
         * The valid values are as follows:
         * + **vpc**: Virtual private cloud.
         * + **vpn**: VPN gateway.
         * + **vgw**: Virtual gateway of cloud private line.
         * + **peering**: Peering connection, through the cloud connection (CC) to load ERs in different regions to create a
         * peering connection.
         */
        type: string;
        /**
         * The latest update time of the attachment.
         */
        updatedAt: string;
    }

    export interface GetAvailableRoutesRoute {
        /**
         * The destination address of the routes to be queried.
         */
        destination: string;
        /**
         * The route ID.
         */
        id: string;
        /**
         * Whether the route is a blackhole route.
         */
        isBlackhole: boolean;
        /**
         * The next hops of the route.
         */
        nextHops: outputs.Er.GetAvailableRoutesRouteNextHop[];
        /**
         * The route type.
         */
        type: string;
    }

    export interface GetAvailableRoutesRouteNextHop {
        /**
         * The attachment ID.
         */
        attachmentId: string;
        /**
         * The attached resource ID.
         */
        resourceId: string;
        /**
         * The attachment type.
         * The valid values are as follows:
         * + **vpc**: VPC attachment.
         * + **vpn**: VPN gateway attachment.
         * + **vgw**: virtual gateway attachment.
         * + **peering**: peering connection attachment.
         * + **ecn**: ECN attachment.
         * + **cfw**: CFW instance attachment.
         */
        resourceType: string;
    }

    export interface GetFlowLogsFlowLog {
        /**
         * The creation time of the flow log.
         */
        createdAt: string;
        /**
         * The description of the flow log.
         */
        description: string;
        /**
         * Specifies the switch status of the flow log.
         * The value can be **true** and **false**.
         */
        enabled: boolean;
        /**
         * The ID of the flow log.
         */
        id: string;
        /**
         * Specifies the ID of the log group to which the flow logs belong.
         */
        logGroupId: string;
        /**
         * The storage type of the flow log.
         */
        logStoreType: string;
        /**
         * Specifies the ID of the log stream to which the flow logs belong.
         */
        logStreamId: string;
        /**
         * Specifies the name of the flow log.
         */
        name: string;
        /**
         * Specifies the ID of the attachment to which the flow logs belong.
         */
        resourceId: string;
        /**
         * Specifies the type of the flow logs.
         * The valid values are as follows:
         * + **attachment**: The flow logs type are attachment.
         */
        resourceType: string;
        /**
         * Specifies the status of the flow logs.
         */
        status: string;
        /**
         * The latest update time of the flow log.
         */
        updatedAt: string;
    }

    export interface GetInstancesInstance {
        /**
         * The BGP AS number of the ER instance.
         */
        asn: number;
        /**
         * Whether to automatically accept the creation of shared attachment.
         */
        autoAcceptSharedAttachments: boolean;
        /**
         * The availability zone list where the ER instance is located.
         */
        availabilityZones: string[];
        /**
         * The creation time of the ER instance.
         */
        createdAt: string;
        /**
         * The ID of the default association route table.
         */
        defaultAssociationRouteTableId: string;
        /**
         * The ID of the default propagation route table.
         */
        defaultPropagationRouteTableId: string;
        /**
         * The description of the ER instance.
         */
        description: string;
        /**
         * Whether to enable the association of the default route table.
         */
        enableDefaultAssociation: boolean;
        /**
         * Whether to enable the propagation of the default route table.
         */
        enableDefaultPropagation: boolean;
        /**
         * Specifies the enterprise project ID of the ER instances to be queried.
         */
        enterpriseProjectId: string;
        /**
         * The ER instance ID.
         */
        id: string;
        /**
         * Specifies the name used to filter the ER instances.
         * The valid length is limited from `1` to `64`, only Chinese and English letters, digits, underscores (_) and
         * hyphens (-) are allowed.
         */
        name: string;
        /**
         * Specifies the status used to filter the ER instances.
         */
        status: string;
        /**
         * Specifies the key/value pairs used to filter the ER instances.
         */
        tags: {[key: string]: string};
        /**
         * The last update time of the ER instance.
         */
        updatedAt: string;
    }

    export interface GetPropagationsPropagation {
        /**
         * Specifies the attachment ID to which the propagation belongs.
         */
        attachmentId: string;
        /**
         * Specifies the attachment type of corresponding to the propagation.  
         * The valid values are as follows:
         * + **vpc**: Virtual private cloud.
         * + **vpn**: VPN gateway.
         * + **vgw**: Virtual gateway of cloud private line.
         * + **peering**: Peering connection, through the cloud connection (CC) to load ERs in different regions to create a
         * peering connection.
         * + **enc**: Enterprise connect network in EC.
         * + **cfw**: VPC border firewall.
         */
        attachmentType: string;
        /**
         * The creation time of the propagation.
         */
        createdAt: string;
        /**
         * The propagation ID.
         */
        id: string;
        /**
         * Specifies the ER instance ID to which the propagation belongs.
         */
        instanceId: string;
        /**
         * The resource ID of the attachment associated with the propagation.
         */
        resourceId: string;
        /**
         * The route policy ID of the ingress IPv4 protocol.
         */
        routePolicyId: string;
        /**
         * Specifies the route table ID to which the propagation belongs.
         */
        routeTableId: string;
        /**
         * Specifies the status of the propagation. Default value is `available`.
         * The valid values are as follows:
         * + **available**
         * + **failed**
         */
        status: string;
        /**
         * The latest update time of the propagation.
         */
        updatedAt: string;
    }

    export interface GetQuotasQuota {
        /**
         * The number of available quotas, `-1` means unlimited.
         */
        limit: number;
        /**
         * The quota type to be queried.
         * The valid values are as follows:
         * + **er_instance**: Quotas and usage for enterprise router instances.
         * + **dc_attachment**: Quotas and usage for DC attachment.
         * + **vpc_attachment**: Quotas and usage for VPC attachment.
         * + **vpn_attachment**: Quotas and usage for VPN attachment.
         * + **peering_attachment**: Quotas and usage for peering attachment.
         * + **can_attachment**: Quotas and usage for can attachment.
         * + **route_table**: Quotas and usage for route table.
         * + **static_route**: Quotas and usage for static route.
         * + **vpc_er**: The number of enterprise routers that each VPC can access and the current usage.
         * + **flow_log**: The number of flow logs that can be created per attachment.
         */
        type: string;
        /**
         * The unit of usage.
         */
        unit: string;
        /**
         * The number of quota used.
         */
        used: number;
    }

    export interface GetRouteTablesRouteTable {
        /**
         * The association configurations of the route table.  
         * The object structure is documented below.
         */
        associations: outputs.Er.GetRouteTablesRouteTableAssociation[];
        /**
         * The creation time.
         */
        createdAt: string;
        /**
         * The description of the route table.
         */
        description: string;
        /**
         * The route ID.
         */
        id: string;
        /**
         * Whether this route table is the default association route table.
         */
        isDefaultAssociation: boolean;
        /**
         * Whether this route table is the default propagation route table.
         */
        isDefaultPropagation: boolean;
        /**
         * Specifies the name used to filter the route tables.  
         * The name can contain `1` to `64` characters, only English letters, Chinese characters, digits, underscore (_),
         * hyphens (-) and dots (.) allowed.
         */
        name: string;
        /**
         * The propagation configurations of the route table.  
         * The object structure is documented below.
         */
        propagations: outputs.Er.GetRouteTablesRouteTablePropagation[];
        /**
         * The route details of the route table.  
         * The object structure is documented below.
         */
        routes: outputs.Er.GetRouteTablesRouteTableRoute[];
        /**
         * The current status of the route.
         */
        status: string;
        /**
         * Specifies the key/value pairs used to filter the route tables.
         */
        tags: {[key: string]: string};
        /**
         * The latest update time.
         */
        updatedAt: string;
    }

    export interface GetRouteTablesRouteTableAssociation {
        /**
         * The ID of the nexthop attachment.
         */
        attachmentId: string;
        /**
         * The type of the nexthop attachment.
         */
        attachmentType: string;
        /**
         * The route ID.
         */
        id: string;
    }

    export interface GetRouteTablesRouteTablePropagation {
        /**
         * The ID of the nexthop attachment.
         */
        attachmentId: string;
        /**
         * The type of the nexthop attachment.
         */
        attachmentType: string;
        /**
         * The route ID.
         */
        id: string;
    }

    export interface GetRouteTablesRouteTableRoute {
        /**
         * The details of the attachment corresponding to the route.  
         * The object structure is documented below.
         */
        attachments: outputs.Er.GetRouteTablesRouteTableRouteAttachment[];
        /**
         * The destination address (CIDR) of the route.
         */
        destination: string;
        /**
         * The route ID.
         */
        id: string;
        /**
         * Whether route is the black hole route.
         */
        isBlackhole: boolean;
        /**
         * The current status of the route.
         */
        status: string;
    }

    export interface GetRouteTablesRouteTableRouteAttachment {
        /**
         * The ID of the nexthop attachment.
         */
        attachmentId: string;
        /**
         * The type of the nexthop attachment.
         */
        attachmentType: string;
        /**
         * The ID of the resource associated with the attachment.
         */
        resourceId: string;
    }

    export interface GetTagsTag {
        /**
         * The key of the resource tag.
         */
        key: string;
        /**
         * All values corresponding to the key.
         */
        values: string[];
    }

}

export namespace Evs {
    export interface GetVolumesVolume {
        /**
         * The disk attachment information. Structure is documented below.
         */
        attachments: outputs.Evs.GetVolumesVolumeAttachment[];
        /**
         * Specifies the availability zone for the disks.
         */
        availabilityZone: string;
        /**
         * Whether the disk is bootable.
         */
        bootable: boolean;
        /**
         * The time when the disk was created.
         */
        createAt: string;
        dedicatedStorageId: string;
        dedicatedStorageName: string;
        /**
         * The disk description.
         */
        description: string;
        /**
         * Specifies the enterprise project ID for filtering.
         */
        enterpriseProjectId: string;
        /**
         * The ID of the attached resource in UUID format.
         */
        id: string;
        iops: number;
        iopsAttributes: outputs.Evs.GetVolumesVolumeIopsAttribute[];
        links: outputs.Evs.GetVolumesVolumeLink[];
        metadata: {[key: string]: string};
        /**
         * The disk name.
         */
        name: string;
        serialNumber: string;
        /**
         * The service type, such as EVS, DSS or DESS.
         */
        serviceType: string;
        /**
         * Specifies whether the disk is shareable.
         */
        shareable: boolean;
        /**
         * The disk size, in GB.
         */
        size: number;
        snapshotId: string;
        /**
         * Specifies the disk status. The valid values are as following:
         * + **FREEZED**
         * + **BIND_ERROR**
         * + **BINDING**
         * + **PENDING_DELETE**
         * + **PENDING_CREATE**
         * + **NOTIFYING**
         * + **NOTIFY_DELETE**
         * + **PENDING_UPDATE**
         * + **DOWN**
         * + **ACTIVE**
         * + **ELB**
         * + **ERROR**
         * + **VPN**
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired disk.
         */
        tags: {[key: string]: string};
        throughput: number;
        throughputAttributes: outputs.Evs.GetVolumesVolumeThroughputAttribute[];
        /**
         * The time when the disk was updated.
         * w
         */
        updateAt: string;
        volumeImageMetadata: {[key: string]: string};
        volumeType: string;
        /**
         * The unique identifier used when attaching the disk.
         */
        wwn: string;
    }

    export interface GetVolumesVolumeAttachment {
        /**
         * The time when the disk was attached.
         */
        attachedAt: string;
        /**
         * The ID of the attachment information.
         */
        attachedMode: string;
        attachedVolumeId: string;
        /**
         * The device name to which the disk is attached.
         */
        deviceName: string;
        hostName: string;
        /**
         * The ID of the attached resource in UUID format.
         */
        id: string;
        /**
         * Specifies the server ID to which the disks are attached.
         */
        serverId: string;
        volumeId: string;
    }

    export interface GetVolumesVolumeIopsAttribute {
        frozened: boolean;
        /**
         * The ID of the attached resource in UUID format.
         */
        id: string;
        totalVal: number;
    }

    export interface GetVolumesVolumeLink {
        href: string;
        rel: string;
    }

    export interface GetVolumesVolumeThroughputAttribute {
        frozened: boolean;
        /**
         * The ID of the attached resource in UUID format.
         */
        id: string;
        totalVal: number;
    }

    export interface VolumeAttachment {
        attachedAt: string;
        attachedVolumeId: string;
        device: string;
        hostName: string;
        /**
         * Specifies a resource ID in UUID format.
         */
        id: string;
        instanceId: string;
        volumeId: string;
    }

    export interface VolumeIopsAttribute {
        frozened: boolean;
        /**
         * Specifies a resource ID in UUID format.
         */
        id: string;
        totalVal: number;
    }

    export interface VolumeLink {
        href: string;
        rel: string;
    }

    export interface VolumeThroughputAttribute {
        frozened: boolean;
        /**
         * Specifies a resource ID in UUID format.
         */
        id: string;
        totalVal: number;
    }

}

export namespace FunctionGraph {
    export interface FunctionCustomImage {
        /**
         * The command line arguments used to start the SWR image.
         */
        args?: string;
        /**
         * The startup commands of the SWR image.
         */
        command?: string;
        /**
         * The URL of SWR image.
         */
        url: string;
        /**
         * The user group ID that used to run SWR image.
         */
        userGroupId?: string;
        /**
         * The user ID that used to run SWR image.
         */
        userId?: string;
        /**
         * The working directory of the SWR image.
         */
        workingDir: string;
    }

    export interface FunctionFuncMount {
        /**
         * Specifies the function access path.
         */
        localMountPath: string;
        /**
         * Specifies the ID of the mounted resource (corresponding cloud service).
         */
        mountResource: string;
        /**
         * Specifies the remote mount path. Example: 192.168.0.12:/data.
         */
        mountSharePath: string;
        /**
         * Specifies the mount type. Options: sfs, sfsTurbo, and ecs.
         */
        mountType: string;
        /**
         * The mount status.
         */
        status: string;
    }

    export interface FunctionNetworkController {
        /**
         * Whether to disable the public network access.
         */
        disablePublicNetwork?: boolean;
        /**
         * The configuration of the VPCs that can trigger the function.
         */
        triggerAccessVpcs: outputs.FunctionGraph.FunctionNetworkControllerTriggerAccessVpc[];
    }

    export interface FunctionNetworkControllerTriggerAccessVpc {
        /**
         * Specifies the ID of VPC.
         */
        vpcId: string;
        /**
         * The ID of the VPC that can trigger the function.
         */
        vpcName: string;
    }

    export interface FunctionReservedInstance {
        /**
         * The number of reserved instance.
         */
        count: number;
        /**
         * Whether to enable the idle mode.
         */
        idleMode?: boolean;
        /**
         * The version name or alias name.
         */
        qualifierName: string;
        /**
         * The qualifier type of reserved instance.
         */
        qualifierType: string;
        /**
         * The auto scaling policies for reserved instance.
         */
        tacticsConfig?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfig;
    }

    export interface FunctionReservedInstanceTacticsConfig {
        /**
         * The list of scheduled policy configurations.
         */
        cronConfigs?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfigCronConfig[];
        /**
         * The list of metric policy configurations.
         */
        metricConfigs?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfigMetricConfig[];
    }

    export interface FunctionReservedInstanceTacticsConfigCronConfig {
        /**
         * The number of reserved instance to which the policy belongs.
         */
        count: number;
        /**
         * The cron expression.
         */
        cron: string;
        /**
         * The expiration timestamp of the policy.
         */
        expiredTime: number;
        /**
         * Specifies the name of the function.
         */
        name: string;
        /**
         * The effective timestamp of policy.
         */
        startTime: number;
    }

    export interface FunctionReservedInstanceTacticsConfigMetricConfig {
        /**
         * The minimun of traffic.
         */
        min: number;
        /**
         * Specifies the name of the function.
         */
        name: string;
        /**
         * The metric policy threshold.
         */
        threshold: number;
        /**
         * The type of metric policy.
         */
        type: string;
    }

    export interface FunctionVersion {
        /**
         * The aliases management for specified version.
         */
        aliases?: outputs.FunctionGraph.FunctionVersionAliases;
        /**
         * Specifies the description of the function.
         */
        description?: string;
        /**
         * Specifies the name of the function.
         */
        name: string;
    }

    export interface FunctionVersionAliases {
        /**
         * The description of the version alias.
         */
        additionalVersionStrategy?: string;
        /**
         * The percentage grayscale configuration of the version alias.
         */
        additionalVersionWeights?: string;
        /**
         * Specifies the description of the function.
         */
        description?: string;
        /**
         * Specifies the name of the function.
         */
        name: string;
    }

    export interface GetDependenciesPackage {
        /**
         * The unique ID of the dependency package.
         */
        etag: string;
        /**
         * The file name of the stored dependency package.
         */
        fileName: string;
        /**
         * The ID of the dependency package version.
         */
        id: string;
        /**
         * The OBS bucket path where the dependency package is located (FunctionGraph serivce side).
         */
        link: string;
        /**
         * Specifies the name of the dependency package.
         */
        name: string;
        /**
         * The owner of the dependency package.
         */
        owner: string;
        /**
         * Specifies the runtime of the dependency package.  
         * The valid values are as follows:
         * + **Java8**
         * + **Java11**
         * + **Node.js6.10**
         * + **Node.js8.10**
         * + **Node.js10.16**
         * + **Node.js12.13**
         * + **Node.js14.18**
         * + **Node.js16.17**
         * + **Node.js18.15**
         * + **Python2.7**
         * + **Python3.6**
         * + **Python3.9**
         * + **Python3.10**
         * + **Go1.x**
         * + **C#(.NET Core 2.0)**
         * + **C#(.NET Core 2.1)**
         * + **C#(.NET Core 3.1)**
         * + **Custom**
         * + **PHP7.3**
         * + **Cangjie1.0**
         * + **http**
         * + **Custom Image**
         */
        runtime: string;
        /**
         * The size of the dependency package.
         */
        size: number;
        /**
         * The list of the versions for the dependency package.
         * The versions structure is documented below.
         */
        versions: outputs.FunctionGraph.GetDependenciesPackageVersion[];
    }

    export interface GetDependenciesPackageVersion {
        /**
         * The ID of the dependency package version.
         */
        id: string;
        /**
         * The dependency package version.
         */
        version: number;
    }

}

export namespace Iam {
    export interface AclIpCidr {
        /**
         * Specifies the IPv4 CIDR block, for example, __192.168.0.0/24__.
         */
        cidr: string;
        /**
         * Specifies a description about an IPv4 CIDR block. This parameter can contain a
         * maximum of 255 characters and the following charactors are not allowed:__@#%^&*<>\\__.
         */
        description?: string;
    }

    export interface AclIpRange {
        /**
         * Specifies a description about an IP address range. This parameter can contain a
         * maximum of 255 characters and the following charactors are not allowed:__@#%^&*<>\\__.
         *
         * ->**NOTE:** Up to 200 `ipCidrs` and `ipRanges` can be created in total for each access method.
         */
        description?: string;
        /**
         * Specifies the Ip address range, for example, __0.0.0.0-255.255.255.0__.
         */
        range: string;
    }

    export interface AgencyProjectRole {
        /**
         * Specifies the name of project.
         */
        project: string;
        /**
         * Specifies an array of role names.
         *
         * > **NOTE**
         * - At least one of `projectRole` and `domainRoles` must be specified when creating an agency.
         * - We can get all **System-Defined Roles** form
         * [SberCloud](https://support.hc.sbercloud.ru/permissions/index.html).
         */
        roles: string[];
    }

    export interface GetGroupUser {
        /**
         * Specifies the description of the identity group.
         */
        description: string;
        /**
         * Indicates the whether the IAM user is enabled.
         */
        enabled: boolean;
        /**
         * Specifies the ID of the identity group.
         */
        id: string;
        /**
         * Specifies the name of the identity group.
         */
        name: string;
        /**
         * Indicates the time when the password will expire.
         * Null indicates that the password has unlimited validity.
         */
        passwordExpiresAt: string;
        /**
         * Indicates the password status. True means that the password needs to be changed,
         * and false means that the password is normal.
         */
        passwordStatus: boolean;
        /**
         * Indicates the password strength. The value can be high, mid, or low.
         */
        passwordStrength: string;
    }

    export interface GetProjectsProject {
        /**
         * Whether project is enabled.
         */
        enabled: boolean;
        /**
         * The project ID.
         */
        id: string;
        /**
         * Specifies the project name to query.
         */
        name: string;
    }

    export interface GetUsersUser {
        /**
         * Indicates the description of the IAM user.
         */
        description: string;
        /**
         * Specifies the status of the IAM user, the default value is **true**.
         */
        enabled: boolean;
        /**
         * Indicates the user groups to which an IAM user belongs.
         */
        groups: string[];
        /**
         * Indicates the ID of the User.
         */
        id: string;
        /**
         * Specifies the IAM user name.
         */
        name: string;
        /**
         * Indicates the time when the password will expire.
         * Null indicates that the password has unlimited validity.
         */
        passwordExpiresAt: string;
        /**
         * Indicates the password status. True means that the password needs to be changed,
         * and false means that the password is normal.
         */
        passwordStatus: boolean;
    }

    export interface ProviderAccessConfig {
        /**
         * Specifies the access type of the identity provider.
         * Available options are:
         */
        accessType: string;
        /**
         * Specifies the authorization endpoint of the OpenID Connect identity
         * provider. This field is required only if the access type is set to `programConsole`.
         */
        authorizationEndpoint: string;
        /**
         * Specifies the ID of a client registered with the OpenID Connect identity provider.
         */
        clientId: string;
        /**
         * Specifies the URL of the identity provider.
         * This field corresponds to the iss field in the ID token.
         */
        providerUrl: string;
        /**
         * Response mode.
         * Valid values is *form_post* and *fragment*, default value is *form_post*.
         * This field is required only if the access type is set to `programConsole`.
         */
        responseMode?: string;
        /**
         * Response type. Valid values is *id_token*, default value is *id_token*.
         * This field is required only if the access type is set to `programConsole`.
         */
        responseType?: string;
        /**
         * Specifies the scopes of authorization requests. It is an array of one or more scopes.
         * Valid values are *openid*, *email*, *profile* and other values defined by you.
         * This field is required only if the access type is set to `programConsole`.
         *
         * > **NOTE:** 1. *openid* must be specified for this field.
         * <br/>2. A maximum of 10 values can be specified, and they must be separated with spaces.
         * <br/>Example: openid email host.
         */
        scopes: string[];
        /**
         * Public key used to sign the ID token of the OpenID Connect identity provider.
         * This field is required only if the protocol is set to *oidc*.
         */
        signingKey: string;
    }

    export interface ProviderConversionConversionRule {
        /**
         * Specifies the federated user information on the cloud platform.
         */
        locals: outputs.Iam.ProviderConversionConversionRuleLocal[];
        /**
         * Specifies Federated user information in the IDP system.
         *
         * > **NOTE:** If the protocol of identity provider is SAML, this field is an expression consisting of assertion
         * attributes and operators.
         * If the protocol of identity provider is OIDC, the value of this field is determined by the ID token.
         */
        remotes: outputs.Iam.ProviderConversionConversionRuleRemote[];
    }

    export interface ProviderConversionConversionRuleLocal {
        /**
         * Specifies the user group to which the federated user belongs on the cloud platform.
         */
        group?: string;
        /**
         * Specifies the name of a federated user on the cloud platform.
         */
        username?: string;
    }

    export interface ProviderConversionConversionRuleRemote {
        /**
         * Specifies the attribute in the IDP assertion.
         */
        attribute: string;
        /**
         * Specifies the condition of conversion rule.
         * Available options are:
         */
        condition?: string;
        /**
         * Specifies the rule is matched only if the specified strings appear in the attribute type.
         */
        values?: string[];
    }

    export interface ProviderConversionRule {
        /**
         * The federated user information on the cloud platform.
         */
        locals: outputs.Iam.ProviderConversionRuleLocal[];
        /**
         * The description of the identity provider.
         */
        remotes: outputs.Iam.ProviderConversionRuleRemote[];
    }

    export interface ProviderConversionRuleLocal {
        /**
         * The user group to which the federated user belongs on the cloud platform.
         */
        group: string;
        /**
         * The name of a federated user on the cloud platform.
         */
        username: string;
    }

    export interface ProviderConversionRuleRemote {
        /**
         * The attribute in the IDP assertion.
         */
        attribute: string;
        /**
         * The condition of conversion rule.
         */
        condition: string;
        /**
         * The rule is matched only if the specified strings appear in the attribute type.
         */
        values: string[];
    }

}

export namespace Ims {
    export interface GetImagesImage {
        __supportAgentList: string;
        activeAt: string;
        architecture: string;
        backupId: string;
        containerFormat: string;
        createdAt: string;
        dataOrigin: string;
        description: string;
        diskFormat: string;
        enterpriseProjectId: string;
        file: string;
        id: string;
        imageType: string;
        maxRamMb: number;
        minDiskGb: number;
        minRamMb: number;
        name: string;
        os: string;
        osVersion: string;
        owner: string;
        protected: boolean;
        schema: string;
        sizeBytes: number;
        status: string;
        updatedAt: string;
        visibility: string;
    }

}

export namespace Mrs {
    export interface ClusterAnalysisCoreNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         *
         * **Role expression definition:**
         *
         * + If the role is deployed on all nodes in the node group, set this parameter to role_name, for example: `DataNode`.
         * + If the role is deployed on a specified subscript node in the node group: role_name:index1,index2..., indexN,
         * for example: `DataNode:1,2`. The subscript starts from 1.
         * + Some roles support multi-instance deployment (that is, multiple instances of the same role are deployed on a node):
         * role_name[instanceCount], for example: `EsNode[9]`.
         *
         * > `DBService` is a basic component of a cluster. Components such as Hive, Hue, Oozie, Loader, and Redis, and Loader
         * store their metadata in DBService, and provide the metadata backup and restoration functions by using DBService.
         */
        assignedRoles?: string[];
        autoRenew?: string;
        chargingMode: string;
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         *
         * Changing this will create a new MapReduce cluster resource.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         *
         * > **NOTE:** Only the core group and task group updations are allowed. The number of nodes after scaling cannot be
         * less than the number of nodes originally created.
         */
        nodeNumber: number;
        period?: number;
        periodUnit?: string;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterAnalysisTaskNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         *
         * **Role expression definition:**
         *
         * + If the role is deployed on all nodes in the node group, set this parameter to role_name, for example: `DataNode`.
         * + If the role is deployed on a specified subscript node in the node group: role_name:index1,index2..., indexN,
         * for example: `DataNode:1,2`. The subscript starts from 1.
         * + Some roles support multi-instance deployment (that is, multiple instances of the same role are deployed on a node):
         * role_name[instanceCount], for example: `EsNode[9]`.
         *
         * > `DBService` is a basic component of a cluster. Components such as Hive, Hue, Oozie, Loader, and Redis, and Loader
         * store their metadata in DBService, and provide the metadata backup and restoration functions by using DBService.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         *
         * Changing this will create a new MapReduce cluster resource.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         *
         * > **NOTE:** Only the core group and task group updations are allowed. The number of nodes after scaling cannot be
         * less than the number of nodes originally created.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterBootstrapScript {
        /**
         * Whether the bootstrap action script runs only on active master nodes.
         */
        activeMaster: boolean;
        /**
         * Whether the bootstrap action script is executed before component start.
         */
        beforeComponentStart: boolean;
        /**
         * Whether the bootstrap action script involves root user operations.
         */
        executeNeedSudoRoot: boolean;
        /**
         * The action after the bootstrap action script fails to be executed.
         */
        failAction: string;
        /**
         * Specifies the name of the MapReduce cluster. The name can contain 2 to 64
         * characters, which may consist of letters, digits, underscores (_) and hyphens (-). Changing this will create a new
         * MapReduce cluster resource.
         */
        name: string;
        /**
         * Name of the node group where the bootstrap action script is executed.
         */
        nodes: string[];
        /**
         * Bootstrap action script parameters.
         */
        parameters?: string;
        /**
         * The execution time of one bootstrap action script, in RFC-3339 format.
         */
        startTime: string;
        /**
         * The status of one bootstrap action script.
         */
        state: string;
        /**
         * Path of a bootstrap action script. Set this parameter to an OBS bucket path or a local VM path.
         */
        uri: string;
    }

    export interface ClusterComponentConfig {
        configs: outputs.Mrs.ClusterComponentConfigConfig[];
        /**
         * Specifies the name of the MapReduce cluster. The name can contain 2 to 64
         * characters, which may consist of letters, digits, underscores (_) and hyphens (-). Changing this will create a new
         * MapReduce cluster resource.
         */
        name: string;
    }

    export interface ClusterComponentConfigConfig {
        configFileName: string;
        key: string;
        value: string;
    }

    export interface ClusterCustomNode {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         *
         * **Role expression definition:**
         *
         * + If the role is deployed on all nodes in the node group, set this parameter to role_name, for example: `DataNode`.
         * + If the role is deployed on a specified subscript node in the node group: role_name:index1,index2..., indexN,
         * for example: `DataNode:1,2`. The subscript starts from 1.
         * + Some roles support multi-instance deployment (that is, multiple instances of the same role are deployed on a node):
         * role_name[instanceCount], for example: `EsNode[9]`.
         *
         * > `DBService` is a basic component of a cluster. Components such as Hive, Hue, Oozie, Loader, and Redis, and Loader
         * store their metadata in DBService, and provide the metadata backup and restoration functions by using DBService.
         */
        assignedRoles?: string[];
        autoRenew?: string;
        chargingMode: string;
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         *
         * Changing this will create a new MapReduce cluster resource.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * Specifies the name of nodes for the node group.
         *
         * > **NOTE:** Only the customNodes has this argument
         */
        groupName: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         *
         * > **NOTE:** Only the core group and task group updations are allowed. The number of nodes after scaling cannot be
         * less than the number of nodes originally created.
         */
        nodeNumber: number;
        period?: number;
        periodUnit?: string;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterExternalDatasource {
        componentName: string;
        dataConnectionId?: string;
        roleType: string;
        sourceType: string;
    }

    export interface ClusterMasterNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         *
         * **Role expression definition:**
         *
         * + If the role is deployed on all nodes in the node group, set this parameter to role_name, for example: `DataNode`.
         * + If the role is deployed on a specified subscript node in the node group: role_name:index1,index2..., indexN,
         * for example: `DataNode:1,2`. The subscript starts from 1.
         * + Some roles support multi-instance deployment (that is, multiple instances of the same role are deployed on a node):
         * role_name[instanceCount], for example: `EsNode[9]`.
         *
         * > `DBService` is a basic component of a cluster. Components such as Hive, Hue, Oozie, Loader, and Redis, and Loader
         * store their metadata in DBService, and provide the metadata backup and restoration functions by using DBService.
         */
        assignedRoles?: string[];
        autoRenew?: string;
        chargingMode: string;
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         *
         * Changing this will create a new MapReduce cluster resource.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         *
         * > **NOTE:** Only the core group and task group updations are allowed. The number of nodes after scaling cannot be
         * less than the number of nodes originally created.
         */
        nodeNumber: number;
        period?: number;
        periodUnit?: string;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterSmnNotify {
        /**
         * The subscription rule name.
         */
        subscriptionName: string;
        /**
         * The Uniform Resource Name (URN) of the topic.
         */
        topicUrn: string;
    }

    export interface ClusterStreamingCoreNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         *
         * **Role expression definition:**
         *
         * + If the role is deployed on all nodes in the node group, set this parameter to role_name, for example: `DataNode`.
         * + If the role is deployed on a specified subscript node in the node group: role_name:index1,index2..., indexN,
         * for example: `DataNode:1,2`. The subscript starts from 1.
         * + Some roles support multi-instance deployment (that is, multiple instances of the same role are deployed on a node):
         * role_name[instanceCount], for example: `EsNode[9]`.
         *
         * > `DBService` is a basic component of a cluster. Components such as Hive, Hue, Oozie, Loader, and Redis, and Loader
         * store their metadata in DBService, and provide the metadata backup and restoration functions by using DBService.
         */
        assignedRoles?: string[];
        autoRenew?: string;
        chargingMode: string;
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         *
         * Changing this will create a new MapReduce cluster resource.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         *
         * > **NOTE:** Only the core group and task group updations are allowed. The number of nodes after scaling cannot be
         * less than the number of nodes originally created.
         */
        nodeNumber: number;
        period?: number;
        periodUnit?: string;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

    export interface ClusterStreamingTaskNodes {
        /**
         * Specifies the roles deployed in a node group.This argument is mandatory
         * when the cluster type is CUSTOM. Each character string represents a role expression.
         *
         * **Role expression definition:**
         *
         * + If the role is deployed on all nodes in the node group, set this parameter to role_name, for example: `DataNode`.
         * + If the role is deployed on a specified subscript node in the node group: role_name:index1,index2..., indexN,
         * for example: `DataNode:1,2`. The subscript starts from 1.
         * + Some roles support multi-instance deployment (that is, multiple instances of the same role are deployed on a node):
         * role_name[instanceCount], for example: `EsNode[9]`.
         *
         * > `DBService` is a basic component of a cluster. Components such as Hive, Hue, Oozie, Loader, and Redis, and Loader
         * store their metadata in DBService, and provide the metadata backup and restoration functions by using DBService.
         */
        assignedRoles?: string[];
        /**
         * Specifies the data disk number of the nodes. The number configuration
         * of each node are as follows:
         * + master_nodes: 1.
         * + analysis_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_core_nodes: minimum is one and the maximum is subject to the configuration of the corresponding flavor.
         * + analysis_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         * + streaming_task_nodes: minimum is zero and the maximum is subject to the configuration of the corresponding flavor.
         *
         * Changing this will create a new MapReduce cluster resource.
         */
        dataVolumeCount: number;
        /**
         * Specifies the data disk size of the nodes,in GB. The value range is 10
         * to 32768. Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce
         * cluster resource.
         */
        dataVolumeSize?: number;
        /**
         * Specifies the data disk flavor of the nodes.
         * Required if `dataVolumeCount` is greater than zero. Changing this will create a new MapReduce cluster resource.
         * The following disk types are supported:
         * + `SATA`: common I/O disk
         * + `SAS`: high I/O disk
         * + `SSD`: ultra-high I/O disk
         */
        dataVolumeType?: string;
        /**
         * Specifies the instance specifications for each nodes in node group.
         * Changing this will create a new MapReduce cluster resource.
         */
        flavor: string;
        /**
         * The host list of this nodes group in the cluster.
         */
        hostIps: string[];
        /**
         * Specifies the number of nodes for the node group.
         *
         * > **NOTE:** Only the core group and task group updations are allowed. The number of nodes after scaling cannot be
         * less than the number of nodes originally created.
         */
        nodeNumber: number;
        /**
         * Specifies the system disk size of the nodes. Changing this will create
         * a new MapReduce cluster resource.
         */
        rootVolumeSize: number;
        /**
         * Specifies the system disk flavor of the nodes. Changing this will
         * create a new MapReduce cluster resource.
         */
        rootVolumeType: string;
    }

}

export namespace Nat {
    export interface GatewaySessionConf {
        /**
         * The ICMP session expiration time.
         */
        icmpSessionExpireTime: number;
        /**
         * The TCP session expiration time.
         */
        tcpSessionExpireTime: number;
        /**
         * The duration of TIME_WAIT state when TCP connection is closed.
         */
        tcpTimeWaitTime: number;
        /**
         * The UDP session expiration time.
         */
        udpSessionExpireTime: number;
    }

}

export namespace Obs {
    export interface BucketCorsRule {
        /**
         * Specifies the allowed header of cross-origin requests.
         * Only CORS requests matching the allowed header are valid.
         */
        allowedHeaders?: string[];
        /**
         * Specifies the acceptable operation type of buckets and objects.
         * The methods include `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
         */
        allowedMethods: string[];
        /**
         * Requests from this origin can access the bucket. Multiple matching rules are allowed.
         * One rule occupies one line, and allows one wildcard character (*) at most.
         */
        allowedOrigins: string[];
        /**
         * Specifies the exposed header in CORS responses, providing additional information for clients.
         */
        exposeHeaders?: string[];
        /**
         * Specifies the duration that your browser can cache CORS responses, expressed in seconds.
         * The default value is 100.
         */
        maxAgeSeconds?: number;
    }

    export interface BucketLifecycleRule {
        abortIncompleteMultipartUploads?: outputs.Obs.BucketLifecycleRuleAbortIncompleteMultipartUpload[];
        /**
         * Specifies lifecycle rule status.
         */
        enabled: boolean;
        /**
         * Specifies a period when objects that have been last updated are automatically deleted. (documented below).
         */
        expirations?: outputs.Obs.BucketLifecycleRuleExpiration[];
        /**
         * Unique identifier for lifecycle rules. The Rule Name contains a maximum of 255 characters.
         */
        name: string;
        /**
         * Specifies a period when noncurrent object versions are automatically deleted. (documented below).
         */
        noncurrentVersionExpirations?: outputs.Obs.BucketLifecycleRuleNoncurrentVersionExpiration[];
        /**
         * Specifies a period when noncurrent object versions are automatically transitioned to `WARM` or `COLD` storage class (documented below).
         *
         * At least one of `expiration`, `transition`, `noncurrentVersionExpiration`, `noncurrentVersionTransition` must be specified.
         */
        noncurrentVersionTransitions?: outputs.Obs.BucketLifecycleRuleNoncurrentVersionTransition[];
        /**
         * Object key prefix identifying one or more objects to which the rule applies.
         * If omitted, all objects in the bucket will be managed by the lifecycle rule.
         * The prefix cannot start or end with a slash (/), cannot have consecutive slashes (/), and cannot contain the following special characters: \:*?"<>|.
         */
        prefix?: string;
        /**
         * Specifies a period when objects that have been last updated are automatically transitioned to `WARM` or `COLD` storage class (documented below).
         */
        transitions?: outputs.Obs.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleAbortIncompleteMultipartUpload {
        days: number;
    }

    export interface BucketLifecycleRuleExpiration {
        /**
         * Specifies the number of days when objects that have been last updated are automatically deleted.
         * The expiration time must be greater than the transition times.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionExpiration {
        /**
         * Specifies the number of days when noncurrent object versions are automatically deleted.
         */
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionTransition {
        /**
         * Specifies the number of days when noncurrent object versions are automatically transitioned to the specified storage class.
         */
        days: number;
        /**
         * The class of storage used to store the object. Only `WARM` and `COLD` are supported.
         */
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        /**
         * Specifies the number of days when objects that have been last updated are automatically transitioned to the specified storage class.
         */
        days: number;
        /**
         * The class of storage used to store the object. Only `WARM` and `COLD` are supported.
         */
        storageClass: string;
    }

    export interface BucketLogging {
        /**
         * schema: Required
         */
        agency: string;
        /**
         * The name of the bucket that will receive the log objects.
         * The acl policy of the target bucket should be `log-delivery-write`.
         */
        targetBucket: string;
        /**
         * To specify a key prefix for log objects.
         */
        targetPrefix?: string;
    }

    export interface BucketStorageInfo {
        /**
         * The number of objects stored in the bucket.
         */
        objectNumber: number;
        /**
         * The stored size of the bucket.
         */
        size: number;
    }

    export interface BucketWebsite {
        /**
         * Specifies the error page returned when an error occurs during static website access.
         * Only HTML, JPG, PNG, BMP, and WEBP files under the root directory are supported.
         */
        errorDocument?: string;
        /**
         * Unless using `redirectAllRequestsTo`. Specifies the default homepage of the static website, only HTML web pages are supported.
         * OBS only allows files such as `index.html` in the root directory of a bucket to function as the default homepage.
         * That is to say, do not set the default homepage with a multi-level directory structure (for example, /page/index.html).
         */
        indexDocument?: string;
        /**
         * A hostname to redirect all website requests for this bucket to. Hostname can optionally be prefixed with a protocol (`http://` or `https://`) to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        redirectAllRequestsTo?: string;
        /**
         * A JSON or XML format containing routing rules describing redirect behavior and when redirects are applied.
         * Each rule contains a `Condition` and a `Redirect` as shown in the following table:
         *
         * Parameter | Key
         * --- | ---
         * Condition | KeyPrefixEquals, HttpErrorCodeReturnedEquals
         * Redirect | Protocol, HostName, ReplaceKeyPrefixWith, ReplaceKeyWith, HttpRedirectCode
         */
        routingRules?: string;
    }

    export interface GetBucketsBucket {
        /**
         * The name of the OBS bucket.
         */
        bucket: string;
        /**
         * The date when the OBS bucket was created.
         */
        createdAt: string;
        /**
         * The enterprise project id of the OBS bucket.
         */
        enterpriseProjectId: string;
        /**
         * The region in which to obtain the OBS bucket.
         * If omitted, the provider-level region will be used.
         */
        region: string;
        /**
         * The storage class of the OBS bucket.
         */
        storageClass: string;
    }

}

export namespace Rds {
    export interface BackupDatabase {
        /**
         * Database to be backed up for Microsoft SQL Server.
         */
        name: string;
    }

    export interface GetBackupsBackup {
        /**
         * Whether a DDM instance has been associated.
         */
        associatedWithDdm: boolean;
        /**
         * Start time in the "yyyy-mm-ddThh:mm:ssZ" format.
         */
        beginTime: string;
        /**
         * Database been backed up.
         * The databases structure is documented below.
         */
        databases: outputs.Rds.GetBackupsBackupDatabase[];
        /**
         * The database information.
         * The datastore structure is documented below.
         */
        datastores: outputs.Rds.GetBackupsBackupDatastore[];
        /**
         * End time in the "yyyy-mm-ddThh:mm:ssZ" format.
         */
        endTime: string;
        /**
         * Backup ID.
         */
        id: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Backup name.
         */
        name: string;
        /**
         * Backup size in KB.
         */
        size: number;
        /**
         * Backup status.  
         * The options are as follows:
         * - **BUILDING**: Backup in progress.
         * - **COMPLETED**: Backup completed.
         * - **FAILED**: Backup failed.
         * - **DELETING**: Backup being deleted.
         */
        status: string;
        /**
         * DB engine.  
         * The value can be: **MySQL**, **PostgreSQL**, **SQLServer**.
         */
        type: string;
    }

    export interface GetBackupsBackupDatabase {
        /**
         * Backup name.
         */
        name: string;
    }

    export interface GetBackupsBackupDatastore {
        /**
         * DB engine.  
         * The value can be: **MySQL**, **PostgreSQL**, **SQLServer**.
         */
        type: string;
        /**
         * DB engine version.
         */
        version: string;
    }

    export interface GetEngineVersionsVersion {
        /**
         * Version ID.
         */
        id: string;
        /**
         * Version name.
         */
        name: string;
    }

    export interface GetFlavorsFlavor {
        /**
         * The availability zones which the RDS flavor belongs to.
         */
        availabilityZones: string[];
        /**
         * The Available versions of the database.
         */
        dbVersions: string[];
        /**
         * Specifies the performance specification, the valid values are as follows:
         * + **normal**: General enhanced.
         * + **normal2**: General enhanced type II.
         */
        groupType: string;
        /**
         * The ID of the rds flavor.
         */
        id: string;
        /**
         * The mode of instance. Value: *ha*(indicates primary/standby instance),
         * *single*(indicates single instance) and *replica*(indicates read replicas).
         */
        instanceMode: string;
        /**
         * Specifies the memory size(GB) in the RDS flavor.
         */
        memory: number;
        /**
         * See 'instance_mode' above.
         *
         * @deprecated use instanceMode instead
         */
        mode: string;
        /**
         * The name of the rds flavor.
         */
        name: string;
        /**
         * Specifies the number of vCPUs in the RDS flavor.
         */
        vcpus: number;
    }

    export interface GetInstancesInstance {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZones: string[];
        /**
         * Indicates the advanced backup policy. Structure is documented below.
         */
        backupStrategies: outputs.Rds.GetInstancesInstanceBackupStrategy[];
        /**
         * Indicates the creation time.
         */
        created: string;
        /**
         * Indicates the database information. Structure is documented below.
         */
        dbs: outputs.Rds.GetInstancesInstanceDb[];
        /**
         * Specifies the enterprise project id.
         */
        enterpriseProjectId: string;
        /**
         * Indicates the intranet floating IP address of the instance.
         */
        fixedIp: string;
        /**
         * Indicates the instance specifications.
         */
        flavor: string;
        /**
         * Indicates the replication mode for the standby DB instance.
         */
        haReplicationMode: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the instance nodes information. Structure is documented below.
         */
        nodes: outputs.Rds.GetInstancesInstanceNode[];
        /**
         * Indicates the configuration ID.
         */
        paramGroupId: string;
        /**
         * Indicates the private ips in list.
         */
        privateIps: string[];
        /**
         * Indicates the public ips in list.
         */
        publicIps: string[];
        /**
         * The region in which to obtain the instances. If omitted, the provider-level region will
         * be used.
         */
        region: string;
        /**
         * Indicates the security group ID.
         */
        securityGroupId: string;
        /**
         * Indicates whether to enable SSL.
         */
        sslEnable: boolean;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Specifies the network ID of a subnet.
         */
        subnetId: string;
        /**
         * Indicates the tags of the instance.
         */
        tags: {[key: string]: string};
        /**
         * Indicates the time zone.
         */
        timeZone: string;
        /**
         * Indicates the volume information. Structure is documented below.
         */
        volumes: outputs.Rds.GetInstancesInstanceVolume[];
        /**
         * Specifies the VPC ID.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceBackupStrategy {
        /**
         * Indicates the number of days to retain the generated.
         */
        keepDays: number;
        /**
         * Indicates the backup time window.
         */
        startTime: string;
    }

    export interface GetInstancesInstanceDb {
        /**
         * Indicates the database port.
         */
        port: number;
        /**
         * Specifies the type of the instance. Valid values are: Single, Ha, Replica, and Enterprise.
         */
        type: string;
        /**
         * Indicates the database user name.
         */
        userName: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface GetInstancesInstanceNode {
        /**
         * Indicates the availability zone where the node resides.
         */
        availabilityZone: string;
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Specifies the name of the instance.
         */
        name: string;
        /**
         * Indicates the node type.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface GetInstancesInstanceVolume {
        /**
         * Indicates the kms key id.
         */
        diskEncryptionId: string;
        /**
         * Indicates the volume size.
         */
        size: number;
        /**
         * Specifies the type of the instance. Valid values are: Single, Ha, Replica, and Enterprise.
         */
        type: string;
    }

    export interface GetPgAccountsUser {
        attributes: outputs.Rds.GetPgAccountsUserAttribute[];
        description: string;
        memberofs: string[];
        name: string;
    }

    export interface GetPgAccountsUserAttribute {
        rolbypassrls: boolean;
        rolcanlogin: boolean;
        rolconnlimit: number;
        rolcreatedb: boolean;
        rolcreaterole: boolean;
        rolinherit: boolean;
        rolreplication: boolean;
        rolsuper: boolean;
    }

    export interface GetPgDatabasesDatabase {
        characterSet: string;
        description: string;
        lcCollate: string;
        name: string;
        owner: string;
        size: number;
    }

    export interface GetPgPluginsPlugin {
        /**
         * Indicates whether the plugin has been created.
         */
        created: boolean;
        /**
         * Indicates the plugin description.
         */
        description: string;
        /**
         * Indicates the plugin name.
         */
        name: string;
        /**
         * Indicates the dependent preloaded library.
         */
        sharedPreloadLibraries: string;
        /**
         * Indicates the plugin version.
         */
        version: string;
    }

    export interface GetPgSqlLimitsSqlLimit {
        /**
         * Indicates the ID of SQL limit.
         */
        id: string;
        /**
         * Indicates whether the SQL limit is effective.
         */
        isEffective: boolean;
        /**
         * Indicates the number of SQL statements executed simultaneously.
         */
        maxConcurrency: number;
        /**
         * Indicates the max waiting time in seconds.
         */
        maxWaiting: number;
        /**
         * Indicates the query ID.
         */
        queryId: string;
        /**
         * Indicates the text form of SQL statement.
         */
        queryString: string;
        /**
         * Indicates the query order for names that are not schema qualified.
         */
        searchPath: string;
    }

    export interface GetStorageTypesStorageType {
        /**
         * The status details of the AZs to which the specification belongs.
         * Key indicates the AZ ID, and value indicates the specification status in the AZ.
         * The options of value are as follows:
         * - **normal**: The specifications in the AZ are available.
         * - **unsupported**: The specifications are not supported by the AZ.
         * - **sellout**: The specifications in the AZ are sold out.
         */
        azStatus: {[key: string]: string};
        /**
         * Storage type.  
         * The options are as follows:
         * - **ULTRAHIGH**: SSD storage.
         * - **LOCALSSD**: Local SSD storage.
         * - **CLOUDSSD**: Cloud SSD storage.
         * This storage type is supported only with general-purpose and dedicated DB instances.
         * - **ESSD**: extreme SSD storage.
         * This storage type is supported only with dedicated DB instances.
         */
        name: string;
        /**
         * Performance specifications.
         * The options are as follows:
         * - **normal**: General-enhanced.
         * - **normal2**: General-enhanced II.
         * - **armFlavors**: Kunpeng general-enhanced.
         * - **dedicicatenormal**: Exclusive x86.
         * - **armlocalssd**: Standard Kunpeng.
         * - **normallocalssd**: Standard x86.
         * - **general**: General-purpose.
         * - **dedicated**: Dedicated, which is only supported for cloud SSDs.
         * - **rapid**: Dedicated, which is only supported for extreme SSDs.
         * - **bigmen**: Large-memory.
         */
        supportComputeGroupTypes: string[];
    }

    export interface InstanceBackupStrategy {
        /**
         * Specifies the retention days for specific backup files. The value range is from 0 to 732.
         *
         * > **NOTE:** Primary/standby DB instances of Microsoft SQL Server do not support disabling the automated backup
         * policy.
         */
        keepDays: number;
        /**
         * Specifies the backup cycle. Automatic backups will be performed on the specified days of
         * the week, except when disabling the automatic backup policy. The value range is a comma-separated number, where each
         * number represents a day of the week. For example, a value of 1,2,3,4 would set the backup cycle to Monday, Tuesday,
         * Wednesday, and Thursday. The default value is 1,2,3,4,5,6,7.
         */
        period: string;
        /**
         * Specifies the backup time window. Automated backups will be triggered during the
         * backup time window. It must be a valid value in the **hh:mm-HH:MM**
         * format. The current time is in the UTC format. The HH value must be 1 greater than the hh value. The values of mm and
         * MM must be the same and must be set to any of the following: 00, 15, 30, or 45. Example value: 08:15-09:15 23:00-00:
         * 00.
         */
        startTime: string;
    }

    export interface InstanceDb {
        /**
         * Specifies the database password. The value should contain 8 to 32 characters,
         * including uppercase and lowercase letters, digits, and the following special characters: ~!@#%^*-_=+? You are advised
         * to enter a strong password to improve security, preventing security risks such as brute force cracking.
         */
        password?: string;
        /**
         * Specifies the database port.
         * + The MySQL database port ranges from 1024 to 65535 (excluding 12017 and 33071, which are occupied by the RDS system
         * and cannot be used). The default value is 3306.
         * + The PostgreSQL database port ranges from 2100 to 9500. The default value is 5432.
         * + The Microsoft SQL Server database port can be 1433 or ranges from 2100 to 9500, excluding 5355 and 5985. The
         * default value is 1433.
         * + The MariaDB database port ranges from 1024 to 65535 (excluding 12017 and 33071, which are occupied by the RDS system
         * and cannot be used). The default value is 3306.
         */
        port: number;
        /**
         * Specifies the DB engine. Available value are **MySQL**, **PostgreSQL**
         * and **SQLServer**. Changing this parameter will create a new resource.
         */
        type: string;
        userName: string;
        /**
         * Specifies the database version. Changing this parameter will create a new
         * resource.
         */
        version: string;
    }

    export interface InstanceMsdtcHost {
        /**
         * Specifies the host name.
         */
        hostName: string;
        /**
         * Indicates the host ID.
         */
        id: string;
        /**
         * Specifies the host IP address.
         */
        ip: string;
    }

    export interface InstanceNode {
        /**
         * Specifies the list of AZ name. Changing this parameter will create a
         * new resource.
         */
        availabilityZone: string;
        /**
         * Indicates the host ID.
         */
        id: string;
        /**
         * Specifies the DB instance name. The DB instance name of the same type must be unique for
         * the same tenant. The value must be 4 to 64 characters in length and start with a letter. It is case-sensitive and can
         * contain only letters, digits, hyphens (-), and underscores (_).
         */
        name: string;
        /**
         * Indicates the node type. The value can be master or slave, indicating the primary node or standby node
         * respectively.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
    }

    export interface InstanceParameter {
        /**
         * Specifies the parameter name. Some of them needs the instance to be restarted
         * to take effect.
         */
        name: string;
        /**
         * Specifies the parameter value.
         *
         * <a name="RdsInstance_MsdtcHosts"></a>
         * The `msdtcHosts` block supports:
         */
        value: string;
    }

    export interface InstanceRestore {
        /**
         * Specifies the ID of the backup used to restore data. Changing this
         * parameter will create a new resource.
         */
        backupId: string;
        /**
         * Specifies the database to be restored. This parameter applies only to
         * Microsoft SQL Server databases. Changing this parameter will create a new resource.
         */
        databaseName?: {[key: string]: string};
        /**
         * Specifies the source DB instance ID. Changing this parameter will create
         * a new resource.
         */
        instanceId: string;
    }

    export interface InstanceVolume {
        /**
         * Specifies the key ID for disk encryption.
         * Changing this parameter will create a new resource.
         */
        diskEncryptionId: string;
        /**
         * Specifies the upper limit of automatic expansion of storage, in GB.
         */
        limitSize?: number;
        /**
         * Specifies the volume size. Its value range is from 40 GB to 4000 GB. The value must be a
         * multiple of 10 and greater than the original size.
         */
        size: number;
        /**
         * Specifies the threshold to trigger automatic expansion.  
         * If the available storage drops to this threshold or `10` GB, the automatic expansion is triggered.
         * The valid values are as follows:
         * + **10**
         * + **15**
         * + **20**
         */
        triggerThreshold?: number;
        /**
         * Specifies the volume type. Its value can be any of the following and is
         * case-sensitive:
         * + **CLOUDSSD**: cloud SSD storage. This storage type is supported only with general-purpose and dedicated DB
         * instances (MySQL and PostreSQL).
         * + **ESSD**: extreme SSD storage. Supported by: MySQL primary/standby, PostgeSQL (both single and primary/standby).
         * + **ULTRAHIGH** the only storage type for SQLServer, not supported by other DB engines.
         *
         * Changing this parameter will create a new resource.
         */
        type: string;
    }

    export interface MysqlDatabasePrivilegeUser {
        /**
         * Specifies the username of the database account.
         */
        name: string;
        /**
         * Specifies the read-only permission. The value can be:
         * + **true**: indicates the read-only permission.
         * + **false**: indicates the read and write permission.
         *
         * The default value is **false**.
         */
        readonly: boolean;
    }

    export interface MysqlDatabaseTableRestoreDatabase {
        /**
         * Specifies the name of the table after restoration.
         *
         * Changing this creates a new resource.
         */
        newName: string;
        /**
         * Specifies the name of the table before restoration.
         *
         * Changing this creates a new resource.
         */
        oldName: string;
    }

    export interface MysqlDatabaseTableRestoreRestoreTable {
        /**
         * Specifies the database name.
         *
         * Changing this creates a new resource.
         */
        database: string;
        /**
         * Specifies the tables.
         * The tables structure is documented below.
         *
         * Changing this creates a new resource.
         *
         * <a name="tablesStruct"></a>
         * The `tables` block supports:
         */
        tables: outputs.Rds.MysqlDatabaseTableRestoreRestoreTableTable[];
    }

    export interface MysqlDatabaseTableRestoreRestoreTableTable {
        /**
         * Specifies the name of the table after restoration.
         *
         * Changing this creates a new resource.
         */
        newName: string;
        /**
         * Specifies the name of the table before restoration.
         *
         * Changing this creates a new resource.
         */
        oldName: string;
    }

    export interface ParametergroupConfigurationParameter {
        /**
         * The parameter group description. It contains a maximum of 256 characters and cannot contain the following special characters:>!<"&'= the value is left blank by default.
         */
        description: string;
        /**
         * The parameter group name. It contains a maximum of 64 characters.
         */
        name: string;
        /**
         * Indicates whether the parameter is read-only.
         */
        readonly: boolean;
        /**
         * Indicates whether a restart is required.
         */
        restartRequired: boolean;
        /**
         * Indicates the parameter type.
         */
        type: string;
        /**
         * Indicates the parameter value.
         */
        value: string;
        /**
         * Indicates the parameter value range.
         */
        valueRange: string;
    }

    export interface ParametergroupDatastore {
        /**
         * The DB engine. Currently, MySQL, PostgreSQL, and Microsoft SQL Server are supported. The value is case-insensitive and can be mysql, postgresql, or sqlserver.
         */
        type: string;
        /**
         * Specifies the database version.
         *
         * * MySQL databases support MySQL 5.6, 5.7 and 8.0. Example value: 5.7.
         * * PostgreSQL databases support PostgreSQL 9.5, 9.6, 10, 11 and 12. Example value: 9.5.
         * * Microsoft SQL Server databases support 2012_SE, 2014_SE, 2016_SE, 2012_EE, 2014_EE, 2016_EE and 2017_EE. Example value: 2014_SE.
         */
        version: string;
    }

    export interface PgAccountAttribute {
        /**
         * Indicates whether a user bypasses each row-level security policy.
         */
        rolBypassRls: boolean;
        /**
         * Indicates whether a user can log in to the database.
         */
        rolCanLogin: boolean;
        /**
         * Indicates the maximum number of concurrent connections to a DB instance.
         */
        rolConnLimit: number;
        /**
         * Indicates whether a user can create a database.
         */
        rolCreateDb: boolean;
        /**
         * Indicates whether a user can create other sub-users.
         */
        rolCreateRole: boolean;
        /**
         * Indicates whether a user automatically inherits the permissions of the role to which the user belongs.
         */
        rolInherit: boolean;
        /**
         * Indicates whether the user is a replication role.
         */
        rolReplication: boolean;
        /**
         * Indicates whether a user has the super-user permission.
         */
        rolSuper: boolean;
    }

    export interface PgHbaHostBasedAuthentication {
        /**
         * Specifies the client IP address.
         */
        address: string;
        /**
         * Specifies the database name.
         */
        database: string;
        /**
         * Specifies the subnet mask.
         */
        mask: string;
        /**
         * Specifies the authentication mode.
         */
        method: string;
        /**
         * Specifies the connection type.
         */
        type: string;
        /**
         * Specifies the Name of a user.
         */
        user: string;
    }

    export interface ReadReplicaInstanceDb {
        /**
         * Indicates the database port information.
         */
        port: number;
        /**
         * Indicates the DB engine. Value: MySQL, PostgreSQL, SQLServer.
         */
        type: string;
        /**
         * Indicates the default user name of database.
         */
        userName: string;
        /**
         * Indicates the database version.
         */
        version: string;
    }

    export interface ReadReplicaInstanceParameter {
        /**
         * Specifies the DB instance name. The DB instance name of the same type
         * must be unique for the same tenant. The value must be 4 to 64 characters in length and start with a letter.
         * It is case-sensitive and can contain only letters, digits, hyphens (-), and underscores (_).
         * Changing this parameter will create a new resource.
         */
        name: string;
        value: string;
    }

    export interface ReadReplicaInstanceVolume {
        /**
         * Specifies the key ID for disk encryption.
         * Changing this parameter will create a new resource.
         */
        diskEncryptionId: string;
        limitSize?: number;
        size: number;
        triggerThreshold?: number;
        /**
         * Specifies the volume type. Its value can be any of the following and is case-sensitive:
         * - *ESSD* - ultrahigh I/O.
         * - *CLOUDSSD* - high I/O.
         *
         * Changing this parameter will create a new resource.
         */
        type: string;
    }

    export interface SqlserverDatabasePrivilegeUser {
        /**
         * Specifies the username of the database account.
         */
        name: string;
        /**
         * Specifies the read-only permission. Value options:
         * + **true**: indicates the read-only permission.
         * + **false**: indicates the read and write permission.
         *
         * Defaults to **false**.
         */
        readonly: boolean;
    }

}

export namespace Sfs {
    export interface FileSystemAccessRule {
        /**
         * Specifies the access level of the shared file system. Possible values are *ro* (read-only)
         * and *rw* (read-write). The default value is *rw* (read/write). Changing this will create a new access rule.
         */
        accessLevel: string;
        /**
         * The UUID of the share access rule.
         */
        accessRuleId: string;
        /**
         * Specifies the value that defines the access rule. The value contains 1 to 255 characters.
         * Changing this will create a new access rule. The value varies according to the scenario:
         * - Set the VPC ID in VPC authorization scenarios.
         * - Set this parameter in IP address authorization scenario.
         *
         * - For an NFS shared file system, the value in the format of *VPC_ID#IP_address#priority#user_permission*.
         * For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#100#all_squash,root_squash.
         *
         * - For a CIFS shared file system, the value in the format of *VPC_ID#IP_address#priority*.
         * For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#0.
         *
         * > **NOTE:** If you want to create more access rules, please using sbercloud_sfs_access_rule.
         */
        accessTo: string;
        /**
         * Specifies the type of the share access rule. The default value is *cert*.
         * Changing this will create a new access rule.
         */
        accessType: string;
        /**
         * The status of the share access rule.
         */
        status: string;
    }

    export interface GetTurbosTurbo {
        /**
         * The availability zone where the SFS turbo file system is located.
         */
        availabilityZone: string;
        /**
         * The available capacity of the SFS turbo file system, in GB.
         */
        availableCapacity: string;
        /**
         * The ID of a KMS key to encrypt the SFS turbo file system.
         */
        cryptKeyId: string;
        /**
         * Whether the SFS turbo file system is enhanced.
         */
        enhanced: boolean;
        /**
         * The enterprise project ID of the SFS turbo file system.
         */
        enterpriseProjectId: string;
        /**
         * The mount point of the SFS turbo file system.
         */
        exportLocation: string;
        /**
         * The resource ID of the SFS turbo file system.
         */
        id: string;
        /**
         * Specifies the name of the SFS turbo file system.
         */
        name: string;
        /**
         * The ID of the security group to which the SFS turbo belongs.
         */
        securityGroupId: string;
        /**
         * Specifies the protocol of the SFS turbo file system. The valid value is **NFS**.
         */
        shareProto: string;
        /**
         * Specifies the type of the SFS turbo file system.
         * The valid values are **STANDARD** and **PERFORMANCE**.
         */
        shareType: string;
        /**
         * Specifies the capacity of the SFS turbo file system, in GB.
         * The value ranges from `500` to `32,768`, and must be large than `10,240` for an enhanced file system.
         */
        size: number;
        /**
         * The **network ID** of the subnet to which the SFS turbo belongs.
         */
        subnetId: string;
        /**
         * The version of the SFS turbo file system.
         */
        version: string;
        /**
         * The ID of the VPC to which the SFS turbo belongs.
         */
        vpcId: string;
    }

}

export namespace SharedApig {
    export interface ApiBackendParam {
        /**
         * Specifies the description of the API. The description cannot exceed 255 characters.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * Specifies the name of the API. An API name consists of 3–64 characters, starting with a
         * letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiFuncGraph {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The alias URN of the FunctionGraph function.
         */
        functionAliasUrn?: string;
        /**
         * The URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * The invocation type.
         */
        invocationType?: string;
        /**
         * The network architecture (framework) type of the FunctionGraph function.
         */
        networkType?: string;
        /**
         * Specifies the request protocol. The value can be 'HTTP', 'HTTPS', and 'BOTH'
         * which means the API can be accessed through both 'HTTP' and 'HTTPS'. Defaults to 'HTTPS'.
         */
        requestProtocol?: string;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * Specifies the version of the API. A maximum of 16 characters are allowed.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The configaiton list of the backend parameters.
         */
        backendParams?: outputs.SharedApig.ApiFuncGraphPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.SharedApig.ApiFuncGraphPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The alias URN of the FunctionGraph function.
         */
        functionAliasUrn?: string;
        /**
         * The URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * The invocation mode of the FunctionGraph function.
         */
        invocationMode?: string;
        /**
         * The invocation mode of the FunctionGraph function.
         */
        invocationType?: string;
        /**
         * Specifies the name of the API. An API name consists of 3–64 characters, starting with a
         * letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * The network (framework) type of the FunctionGraph function.
         */
        networkType?: string;
        /**
         * Specifies the request protocol. The value can be 'HTTP', 'HTTPS', and 'BOTH'
         * which means the API can be accessed through both 'HTTP' and 'HTTPS'. Defaults to 'HTTPS'.
         */
        requestProtocol?: string;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * Specifies the version of the API. A maximum of 16 characters are allowed.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicyBackendParam {
        /**
         * Specifies the description of the API. The description cannot exceed 255 characters.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * Specifies the name of the API. An API name consists of 3–64 characters, starting with a
         * letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiFuncGraphPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface ApiMock {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The response content of the mock.
         */
        response?: string;
        /**
         * The custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The configuration list of backend parameters.
         */
        backendParams?: outputs.SharedApig.ApiMockPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.SharedApig.ApiMockPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * Specifies the name of the API. An API name consists of 3–64 characters, starting with a
         * letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * The response content of the mock.
         */
        response?: string;
        /**
         * The custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicyBackendParam {
        /**
         * Specifies the description of the API. The description cannot exceed 255 characters.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * Specifies the name of the API. An API name consists of 3–64 characters, starting with a
         * letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiMockPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface ApiRequestParam {
        /**
         * The default value of the parameter.
         */
        default: string;
        /**
         * Specifies the description of the API. The description cannot exceed 255 characters.
         */
        description: string;
        /**
         * The enumerated value.
         */
        enumeration: string;
        /**
         * The parameter example.
         */
        example: string;
        /**
         * Where this parameter is located.
         */
        location?: string;
        /**
         * The maximum value or length (string parameter) for parameter.
         */
        maximum: number;
        /**
         * The minimum value or length (string parameter) for parameter.
         */
        minimum: number;
        /**
         * Specifies the name of the API. An API name consists of 3–64 characters, starting with a
         * letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * The list of orchestration rules that parameter used.
         */
        orchestrations?: string[];
        /**
         * Whether to transparently transfer the parameter.
         */
        passthrough: boolean;
        /**
         * Whether this parameter is required.
         */
        required: boolean;
        /**
         * The parameter type.
         */
        type?: string;
        /**
         * Whether to enable the parameter validation.
         */
        validEnable: number;
    }

    export interface ApiWeb {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The backend service address, which consists of a domain name or IP address, and a port number.
         */
        backendAddress?: string;
        /**
         * The proxy host header.
         */
        hostHeader?: string;
        /**
         * The backend request path.
         */
        path: string;
        /**
         * Specifies the request method, including 'GET','POST','PUT' and etc..
         */
        requestMethod?: string;
        /**
         * Specifies the request protocol. The value can be 'HTTP', 'HTTPS', and 'BOTH'
         * which means the API can be accessed through both 'HTTP' and 'HTTPS'. Defaults to 'HTTPS'.
         */
        requestProtocol?: string;
        /**
         * The number of retry attempts to request the backend service.
         */
        retryCount?: number;
        /**
         * Whether to enable two-way authentication.
         */
        sslEnable?: boolean;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The VPC channel ID.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The backend service address
         */
        backendAddress?: string;
        /**
         * The configuration list of the backend parameters.
         */
        backendParams?: outputs.SharedApig.ApiWebPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.SharedApig.ApiWebPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The proxy host header.
         */
        hostHeader?: string;
        /**
         * Specifies the name of the API. An API name consists of 3–64 characters, starting with a
         * letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        /**
         * The backend request address.
         */
        path: string;
        /**
         * Specifies the request method, including 'GET','POST','PUT' and etc..
         */
        requestMethod: string;
        /**
         * Specifies the request protocol. The value can be 'HTTP', 'HTTPS', and 'BOTH'
         * which means the API can be accessed through both 'HTTP' and 'HTTPS'. Defaults to 'HTTPS'.
         */
        requestProtocol?: string;
        /**
         * The number of retry attempts to request the backend service.
         */
        retryCount?: number;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The VPC channel ID.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicyBackendParam {
        /**
         * Specifies the description of the API. The description cannot exceed 255 characters.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * Specifies the name of the API. An API name consists of 3–64 characters, starting with a
         * letter. Only letters, digits, and underscores (_) are allowed.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiWebPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface GroupEnvironment {
        /**
         * The ID of the environment to which the variables belongs.
         */
        environmentId: string;
        /**
         * The array of one or more environment variables. Each `variable` block supports the following:
         */
        variables: outputs.SharedApig.GroupEnvironmentVariable[];
    }

    export interface GroupEnvironmentVariable {
        /**
         * The ID of the variable that the group has.
         */
        id: string;
        /**
         * The variable name.
         */
        name: string;
        /**
         * The variable value.
         */
        value: string;
        /**
         * The ID of the variable that the group has.  
         * _Deprecated: Use `id` instead._
         *
         * @deprecated Use 'id' instead
         */
        variableId: string;
    }

    export interface GroupUrlDomain {
        /**
         * Whether to enable redirection from HTTP to HTTPS.
         */
        isHttpRedirectToHttps: boolean;
        /**
         * The minimum SSL protocol version.
         */
        minSslVersion: string;
        /**
         * The group name.
         */
        name: string;
    }

}

export namespace Vpc {
    export interface AddressGroupIpExtraSet {
        ip: string;
        remarks?: string;
    }

    export interface BandwidthPublicip {
        /**
         * The ID of the EIP or IPv6 port that uses the bandwidth.
         */
        id: string;
        /**
         * The IPv4 or IPv6 address.
         */
        ipAddress: string;
        /**
         * The IP version, either 4 or 6.
         */
        ipVersion: number;
        /**
         * The EIP type.
         */
        type: string;
    }

    export interface EipBandwidth {
        /**
         * Specifies whether the bandwidth is billed by traffic or by bandwidth
         * size. The value can be *traffic* or *bandwidth*. Changing this creates a new eip.
         */
        chargeMode: string;
        /**
         * The shared bandwidth id. This parameter is mandatory when
         * `shareType` is set to *WHOLE*. Changing this creates a new eip.
         */
        id: string;
        /**
         * The bandwidth name, which is a string of 1 to 64 characters that contain letters, digits,
         * underscores (_), and hyphens (-). This parameter is mandatory when `shareType` is set to *PER*.
         */
        name: string;
        /**
         * Whether the bandwidth is dedicated or shared. Changing this creates a new
         * eip. Possible values are as follows:
         * + *PER*: Dedicated bandwidth
         * + *WHOLE*: Shared bandwidth
         */
        shareType: string;
        /**
         * The bandwidth size. The value ranges from 1 to 300 Mbit/s. This parameter is mandatory
         * when `shareType` is set to *PER*.
         */
        size: number;
    }

    export interface EipPublicip {
        /**
         * The value must be a valid IP address in the available IP address segment.
         * Changing this creates a new eip.
         */
        ipAddress: string;
        /**
         * The IP version.
         */
        ipVersion: number;
        /**
         * The port id which this eip will associate with. If the value is "" or this not
         * specified, the eip will be in unbind state.
         */
        portId: string;
        /**
         * The type of the eip. Changing this creates a new eip.
         */
        type?: string;
    }

    export interface GetAddressGroupsAddressGroup {
        /**
         * IP address sets in an IP address group.
         * Value range: a single IP address, IP address range, or CIDR block.
         */
        addresses: string[];
        /**
         * Time when the IP address group is created.
         */
        createdAt: string;
        /**
         * Provides supplementary information about an IP address group,
         * which can be used to filter the IP address group.
         */
        description: string;
        /**
         * Enterprise project ID.
         */
        enterpriseProjectId: string;
        /**
         * IP address group ID, which uniquely identifies the IP address group.
         */
        id: string;
        /**
         * IP addresses and their remarks in an IP address group.
         */
        ipExtraSets: outputs.Vpc.GetAddressGroupsAddressGroupIpExtraSet[];
        /**
         * Version of IP addresses in an IP address group,
         * which can be used to filter the IP address group.
         */
        ipVersion: number;
        /**
         * Maximum number of entries in an address group,
         * which limits the number of addresses that can be contained in an address group.
         */
        maxCapacity: number;
        /**
         * Name of an IP address group, which can be used to filter the IP address group.
         */
        name: string;
        /**
         * The status of IP address group.
         * Valid values are:
         * + `NORMAL`: normal status.
         * + `UPDATING`: updating.
         * + `UPDATE_FAILED`: update failed.
         * When the status of IP address group is `UPDATING`, the IP address group cannot be updated again.
         */
        status: string;
        /**
         * The status details of IP address group.
         */
        statusMessage: string;
        /**
         * Time when the IP address group was last updated.
         */
        updatedAt: string;
    }

    export interface GetAddressGroupsAddressGroupIpExtraSet {
        /**
         * An IP address, IP address range, or CIDR block.
         */
        ip: string;
        /**
         * Provides supplementary information about the IP address, IP address range, or CIDR block.
         */
        remarks: string;
    }

    export interface GetRouteTableRoute {
        /**
         * (String) - The description about the route.
         */
        description: string;
        /**
         * (String) - The destination address in the CIDR notation format
         */
        destination: string;
        /**
         * (String) - The next hop.
         */
        nexthop: string;
        /**
         * (String) - The route type.
         */
        type: string;
    }

    export interface GetRoutesRoute {
        /**
         * Specifies the route destination.
         */
        destination: string;
        /**
         * The route ID.
         */
        id: string;
        /**
         * The next hop of the route.
         */
        nexthop: string;
        /**
         * Specifies the route type.
         */
        type: string;
        /**
         * Specifies the ID of the VPC to which the route belongs.
         */
        vpcId: string;
    }

    export interface GetSecgroupRule {
        /**
         * The effective policy.
         */
        action: string;
        /**
         * The supplementary information about the security group rule.
         */
        description: string;
        /**
         * The direction of the rule. The value can be *egress* or *ingress*.
         */
        direction: string;
        /**
         * The IP protocol version. The value can be *IPv4* or *IPv6*.
         */
        ethertype: string;
        /**
         * The security group rule ID.
         */
        id: string;
        /**
         * schema: Deprecated
         */
        portRangeMax: number;
        /**
         * schema: Deprecated
         */
        portRangeMin: number;
        /**
         * The port value range.
         */
        ports: string;
        /**
         * The priority number.
         */
        priority: number;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The ID of the remote address group.
         */
        remoteAddressGroupId: string;
        /**
         * The ID of the peer security group.
         */
        remoteGroupId: string;
        /**
         * The remote IP address. The value can be in the CIDR format or IP addresses.
         */
        remoteIpPrefix: string;
    }

    export interface GetSecgroupsSecurityGroup {
        /**
         * The creation time, in UTC format.
         */
        createdAt: string;
        /**
         * Specifies the description of the security group. The security groups can be
         * filtered by keywords in the description.
         */
        description: string;
        /**
         * Specifies the enterprise project ID of the security group.
         */
        enterpriseProjectId: string;
        /**
         * Specifies the id of the desired security group.
         */
        id: string;
        /**
         * Specifies the name of the security group.
         */
        name: string;
        /**
         * The last update time, in UTC format.
         */
        updatedAt: string;
    }

    export interface GetSubnetsSubnet {
        /**
         * Specifies the availability zone (AZ) to which the desired subnet belongs to.
         */
        availabilityZone: string;
        /**
         * Specifies the network segment of desired subnet. The value must be in CIDR format.
         */
        cidr: string;
        description: string;
        dhcpEnable: boolean;
        dnsLists: string[];
        /**
         * Specifies the subnet gateway address of desired subnet.
         */
        gatewayIp: string;
        /**
         * Specifies the id of the desired subnet.
         */
        id: string;
        ipv4SubnetId: string;
        ipv6Cidr: string;
        ipv6Enable: boolean;
        ipv6Gateway: string;
        ipv6SubnetId: string;
        /**
         * Specifies the name of the desired subnet.
         */
        name: string;
        /**
         * Specifies the IP address of DNS server 1 on the desired subnet.
         */
        primaryDns: string;
        /**
         * Specifies the IP address of DNS server 2 on the desired subnet.
         */
        secondaryDns: string;
        /**
         * Specifies the current status of the desired subnet.
         * the value can be ACTIVE, DOWN, UNKNOWN, or ERROR.
         */
        status: string;
        /**
         * schema: Deprecated
         */
        subnetId: string;
        /**
         * Specifies the included key/value pairs which associated with the desired subnet.
         *
         * > A maximum of 10 tag keys are allowed for each query operation. Each tag key can have up to 10 tag values.
         * The tag key cannot be left blank or set to an empty string. Each tag key must be unique, and each tag value in a
         * tag must be unique, use commas(,) to separate the multiple values. An empty for values indicates any value.
         * The values are in the OR relationship.
         */
        tags: {[key: string]: string};
        /**
         * Specifies the id of the VPC that the desired subnet belongs to.
         */
        vpcId: string;
    }

    export interface GetVpcRoute {
        destination: string;
        nexthop: string;
    }

    export interface GetVpcsVpc {
        /**
         * Specifies the cidr block of the desired VPC.
         */
        cidr: string;
        /**
         * Indicates the description of the VPC.
         */
        description: string;
        /**
         * Specifies the enterprise project ID which the desired VPC belongs to.
         */
        enterpriseProjectId: string;
        /**
         * Specifies the id of the desired VPC.
         */
        id: string;
        /**
         * Specifies the name of the desired VPC. The value is a string of no more than 64 characters
         * and can contain digits, letters, underscores (_) and hyphens (-).
         */
        name: string;
        secondaryCidrs: string[];
        /**
         * Specifies the current status of the desired VPC. The value can be CREATING, OK or ERROR.
         */
        status: string;
        /**
         * Specifies the included key/value pairs which associated with the desired VPC.
         *
         * > A maximum of 10 tag keys are allowed for each query operation. Each tag key can have up to 10 tag values.
         * The tag key cannot be left blank or set to an empty string. Each tag key must be unique, and each tag value in a
         * tag must be unique, use commas(,) to separate the multiple values. An empty for values indicates any value.
         * The values are in the OR relationship.
         */
        tags: {[key: string]: string};
    }

    export interface RouteTableRoute {
        /**
         * Specifies the supplementary information about the route.
         * The value is a string of no more than 255 characters and cannot contain angle brackets (< or >).
         */
        description?: string;
        /**
         * Specifies the destination address in the CIDR notation format,
         * for example, 192.168.200.0/24. The destination of each route must be unique and cannot overlap
         * with any subnet in the VPC.
         */
        destination: string;
        /**
         * Specifies the next hop.
         * + If the route type is **ecs**, the value is an ECS instance ID in the VPC.
         * + If the route type is **eni**, the value is the extension NIC of an ECS in the VPC.
         * + If the route type is **vip**, the value is a virtual IP address.
         * + If the route type is **nat**, the value is a VPN gateway ID.
         * + If the route type is **peering**, the value is a VPC peering connection ID.
         * + If the route type is **vpn**, the value is a VPN gateway ID.
         * + If the route type is **dc**, the value is a Direct Connect gateway ID.
         * + If the route type is **cc**, the value is a Cloud Connection ID.
         */
        nexthop: string;
        /**
         * Specifies the route type. Currently, the value can be:
         * **ecs**, **eni**, **vip**, **nat**, **peering**, **vpn**, **dc** and **cc**.
         */
        type: string;
    }

    export interface SecgroupRule {
        /**
         * The effective policy.
         */
        action: string;
        /**
         * Description of the security group.
         */
        description: string;
        /**
         * The direction of the rule. The value can be *egress* or *ingress*.
         */
        direction: string;
        /**
         * The IP protocol version. The value can be *IPv4* or *IPv6*.
         */
        ethertype: string;
        /**
         * The security group rule ID.
         */
        id: string;
        /**
         * schema: Deprecated
         */
        portRangeMax: number;
        /**
         * schema: Deprecated
         */
        portRangeMin: number;
        /**
         * The port value range.
         */
        ports: string;
        /**
         * The priority number.
         */
        priority: number;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The ID of the remote address group.
         */
        remoteAddressGroupId: string;
        /**
         * The ID of the peer security group.
         */
        remoteGroupId: string;
        /**
         * The remote IP address. The value can be in the CIDR format or IP addresses.
         */
        remoteIpPrefix: string;
    }

    export interface VpcRoute {
        destination: string;
        nexthop: string;
    }

}

export namespace Vpcep {
    export interface GetPublicServicesService {
        id: string;
        isCharge: boolean;
        owner: string;
        serviceName: string;
        serviceType: string;
    }

    export interface ServiceConnection {
        /**
         * Specifies the description of the VPC endpoint service.
         */
        description: string;
        /**
         * The user's domain ID.
         */
        domainId: string;
        /**
         * The unique ID of the VPC endpoint.
         */
        endpointId: string;
        /**
         * The packet ID of the VPC endpoint.
         */
        packetId: number;
        /**
         * The connection status of the VPC endpoint.
         */
        status: string;
    }

    export interface ServicePortMapping {
        /**
         * Specifies the protocol used in port mappings. Only **TCP** is supported.
         */
        protocol?: string;
        /**
         * Specifies the port for accessing the VPC endpoint service. This port is provided by
         * the backend service to provide services. The value ranges from 1 to 65535.
         */
        servicePort?: number;
        /**
         * Specifies the port for accessing the VPC endpoint. This port is provided by the VPC
         * endpoint, allowing you to access the VPC endpoint service. The value ranges from 1 to 65535.
         */
        terminalPort?: number;
    }

}

export namespace config {
    export interface AssumeRole {
        agencyName: string;
        domainName: string;
    }

}
