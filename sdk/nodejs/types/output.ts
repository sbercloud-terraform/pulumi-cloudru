// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApigApplicationQuotaAssociateApplication {
    /**
     * The binding time, in RFC3339 format.
     */
    bindTime: string;
    /**
     * The application ID bound to the application quota.
     */
    id: string;
}

export interface ApigChannelHealthCheck {
    /**
     * Whether to enable two-way authentication.
     */
    enableClientSsl: boolean;
    /**
     * The response codes for determining a successful HTTP response.
     */
    httpCodes: string;
    /**
     * The interval between consecutive check, in second.
     */
    interval: number;
    /**
     * The request method for health check.
     */
    method: string;
    /**
     * The destination path for health check.
     */
    path: string;
    /**
     * The destination host port for health check.
     */
    port: number;
    /**
     * The rotocol for performing health check on backend servers.
     */
    protocol: string;
    /**
     * The status of health check.
     */
    status: number;
    /**
     * The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
     */
    thresholdAbnormal: number;
    /**
     * The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
     */
    thresholdNormal: number;
    /**
     * The timeout for determining whether a health check fails, in second.
     */
    timeout: number;
}

export interface ApigChannelMember {
    /**
     * The group name of the backend server.
     */
    groupName: string;
    /**
     * The IP address of the backend server.
     */
    host: string;
    /**
     * The ID of the backend server.
     */
    id: string;
    /**
     * Whether this member is the backup member.
     */
    isBackup: boolean;
    /**
     * The name of the backend server.
     */
    name: string;
    /**
     * The port of the backend server.
     */
    port: number;
    /**
     * The status of the backend server.
     */
    status: number;
    /**
     * The weight of current backend server.
     */
    weight: number;
}

export interface ApigChannelMemberGroup {
    /**
     * The description of the member group.
     */
    description: string;
    /**
     * The microservice tags of the backend server group.
     */
    microserviceLabels: {[key: string]: string};
    /**
     * The microservice port of the backend server group.
     */
    microservicePort: number;
    /**
     * The microservice version of the backend server group.
     */
    microserviceVersion: string;
    /**
     * The name of the member group.
     */
    name: string;
    /**
     * The ID of the reference load balance channel.
     */
    referenceVpcChannelId: string;
    /**
     * The weight of the current member group.
     */
    weight: number;
}

export interface ApigChannelMicroservice {
    /**
     * The CCE microservice details.
     */
    cceConfig: outputs.ApigChannelMicroserviceCceConfig;
    /**
     * schema:Internal; The CSE microservice details.
     */
    cseConfig: outputs.ApigChannelMicroserviceCseConfig;
}

export interface ApigChannelMicroserviceCceConfig {
    /**
     * The ID of the CCE cluster.
     */
    clusterId: string;
    /**
     * The service label key.
     */
    labelKey?: string;
    /**
     * The service label value.
     */
    labelValue?: string;
    /**
     * The name of the CCE namespace.
     */
    namespace: string;
    /**
     * The workload name.
     */
    workloadName?: string;
    /**
     * The workload type.
     */
    workloadType: string;
}

export interface ApigChannelMicroserviceCseConfig {
    /**
     * schema:Internal; The microservice engine ID.
     */
    engineId: string;
    /**
     * schema:Internal; The microservice ID.
     */
    serviceId: string;
}

export interface CbrBackupShareMember {
    /**
     * The creation time of the backup shared member.
     */
    createdAt: string;
    /**
     * The ID of the project with which the backup is shared.
     */
    destProjectId: string;
    /**
     * The ID of the backup shared member record.
     */
    id: string;
    /**
     * The ID of the image registered with the shared backup copy.
     */
    imageId: string;
    /**
     * The backup shared status.
     */
    status: string;
    /**
     * The latest update time of the backup shared member.
     */
    updatedAt: string;
    /**
     * The ID of the vault where the shared backup is stored.
     */
    vaultId: string;
}

export interface CbrCheckpointBackup {
    /**
     * The backup ID.
     */
    id: string;
    /**
     * The backup time.
     */
    protectedAt: string;
    /**
     * The ID of backup resource.
     */
    resourceId: string;
    /**
     * The backup resource size.
     */
    resourceSize: number;
    /**
     * The backup status.
     */
    status: string;
    /**
     * The type of the backup resource.
     */
    type: string;
    /**
     * The latest update time of the backup.
     */
    updatedAt: string;
}

export interface DcsParametersConfigurationParameter {
    name: string;
    needRestart: boolean;
    type: string;
    userPermission: string;
    value: string;
}

export interface DcsRestoreRestoreRecord {
    backupId: string;
    backupName: string;
    backupRemark: string;
    createdAt: string;
    errorCode: string;
    progress: string;
    restoreId: string;
    restoreName: string;
    restoreRemark: string;
    sourceInstanceId: string;
    sourceInstanceName: string;
    status: string;
    updatedAt: string;
}

export interface DdsParameterTemplateCompareDifference {
    parameterName: string;
    sourceValue: string;
    targetValue: string;
}

export interface DdsParameterTemplateCopyParameter {
    /**
     * Indicates the parameter description.
     */
    description: string;
    /**
     * Indicates the parameter name.
     */
    name: string;
    /**
     * Indicates whether the parameter is read-only.
     */
    readonly: boolean;
    /**
     * Indicates whether the instance needs to be restarted.
     */
    restartRequired: boolean;
    /**
     * Indicates the parameter type.
     */
    type: string;
    /**
     * Indicates the parameter value.
     */
    value: string;
    /**
     * Indicates the value range.
     */
    valueRange: string;
}

export interface DdsParameterTemplateParameter {
    /**
     * Indicates the parameter description.
     */
    description: string;
    /**
     * Indicates the parameter name.
     */
    name: string;
    /**
     * Indicates whether the parameter is read-only.
     */
    readonly: boolean;
    /**
     * Indicates whether the instance needs to be restarted.
     */
    restartRequired: boolean;
    /**
     * Indicates the parameter type.
     */
    type: string;
    /**
     * Indicates the parameter value.
     */
    value: string;
    /**
     * Indicates the value range.
     */
    valueRange: string;
}

export interface DmsKafkaMessageProducePropertyList {
    name: string;
    value: string;
}

export interface DmsRocketmqConsumptionVerifyResendResult {
    /**
     * Indicates the error code.
     */
    errorCode: string;
    /**
     * Indicates the error message.
     */
    errorMessage: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
}

export interface DmsRocketmqDeadLetterResendResendResult {
    /**
     * Indicates the error code.
     */
    errorCode: string;
    /**
     * Indicates the error message.
     */
    errorMessage: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
}

export interface DmsRocketmqInstanceConfig {
    name: string;
    value: string;
}

export interface DmsRocketmqInstanceCrossVpcAccess {
    advertisedIp: string;
    /**
     * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
     */
    lisenterIp: string;
    listenerIp: string;
    port: number;
    portId: string;
}

export interface DmsRocketmqMigrationTaskBinding {
    /**
     * Specifies the message target.
     */
    destination?: string;
    /**
     * Specifies the message target type.
     */
    destinationType: string;
    /**
     * Specifies the routing key.
     */
    routingKey: string;
    /**
     * Specifies the message source.
     */
    source: string;
    /**
     * Specifies the virtual host name.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskExchange {
    /**
     * Specifies whether to enable data persistence.
     */
    durable: boolean;
    /**
     * Specifies the switch name.
     */
    name: string;
    /**
     * Specifies the exchange type.
     */
    type: string;
    /**
     * Specifies the virtual host name.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskQueue {
    /**
     * Specifies whether to enable data persistence.
     */
    durable: boolean;
    /**
     * Specifies the queue name.
     */
    name: string;
    /**
     * Specifies the virtual host name.
     */
    vhost: string;
}

export interface DmsRocketmqMigrationTaskSubscriptionGroup {
    /**
     * Specifies whether to enable broadcast.
     */
    consumeBroadcastEnable: boolean;
    /**
     * Specifies whether to enable consumption.
     */
    consumeEnable: boolean;
    /**
     * Specifies whether to enable consumption from the earliest offset.
     */
    consumeFromMinEnable: boolean;
    /**
     * Specifies the name of a consumer group.
     */
    groupName: string;
    /**
     * Specifies whether to notify changes of consumer IDs.
     */
    notifyConsumeridsChangedEnable: boolean;
    /**
     * Specifies the maximum number of consumption retries.
     */
    retryMaxTimes: number;
    /**
     * Specifies the number of retry queues.
     */
    retryQueueNum: number;
    /**
     * Specifies the ID of the broker selected for slow consumption.
     */
    whichBrokerWhenConsumeSlow: number;
}

export interface DmsRocketmqMigrationTaskTopicConfig {
    /**
     * Specifies whether a message is an ordered message.
     */
    order: boolean;
    /**
     * Specifies the number of permission.
     */
    perm: number;
    /**
     * Specifies the number of read queues.
     */
    readQueueNum: number;
    /**
     * Specifies the filter type of a topic.
     */
    topicFilterType: string;
    /**
     * Specifies the topic name.
     */
    topicName: string;
    /**
     * Specifies the system flag of a topic.
     */
    topicSysFlag: number;
    /**
     * Specifies the number of write queues.
     */
    writeQueueNum: number;
}

export interface DmsRocketmqMigrationTaskVhost {
    /**
     * Specifies the virtual host name.
     */
    name: string;
}

export interface DmsRocketmqTopicBroker {
    /**
     * Indicates the name of the broker.
     */
    name: string;
    /**
     * Indicates the read queues number of the broker.
     */
    readQueueNum: number;
    /**
     * Indicates the read queues number of the broker.
     */
    writeQueueNum: number;
}

export interface DmsRocketmqTopicQueue {
    /**
     * Specifies the associated broker.
     */
    broker?: string;
    /**
     * Specifies the number of the queues.
     */
    queueNum?: number;
}

export interface DmsRocketmqUserGroupPerm {
    /**
     * Indicates the name of a topic or consumer group.
     */
    name: string;
    /**
     * Indicates the permissions of the topic or consumer group.
     * Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
     */
    perm: string;
}

export interface DmsRocketmqUserTopicPerm {
    /**
     * Indicates the name of a topic or consumer group.
     */
    name: string;
    /**
     * Indicates the permissions of the topic or consumer group.
     * Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
     */
    perm: string;
}

export interface ElbIpgroupIpList {
    description?: string;
    ip: string;
}

export interface ElbL7policyFixedResponseConfig {
    contentType: string;
    insertHeadersConfig?: outputs.ElbL7policyFixedResponseConfigInsertHeadersConfig;
    messageBody?: string;
    removeHeadersConfig?: outputs.ElbL7policyFixedResponseConfigRemoveHeadersConfig;
    statusCode: string;
    trafficLimitConfig?: outputs.ElbL7policyFixedResponseConfigTrafficLimitConfig;
}

export interface ElbL7policyFixedResponseConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyFixedResponseConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyFixedResponseConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyFixedResponseConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyFixedResponseConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyFixedResponseConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7policyFixedResponseConfigTrafficLimitConfig {
    burst?: number;
    perSourceIpQps?: number;
    qps?: number;
}

export interface ElbL7policyRedirectPoolsConfig {
    poolId: string;
    weight: number;
}

export interface ElbL7policyRedirectPoolsExtendConfig {
    insertHeadersConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfig;
    removeHeadersConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfig;
    rewriteUrlConfig: outputs.ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfig;
    rewriteUrlEnabled: boolean;
    trafficLimitConfig?: outputs.ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfig;
}

export interface ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfig {
    host: string;
    path: string;
    query?: string;
}

export interface ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfig {
    burst?: number;
    perSourceIpQps?: number;
    qps?: number;
}

export interface ElbL7policyRedirectPoolsStickySessionConfig {
    enable: boolean;
    timeout: number;
}

export interface ElbL7policyRedirectUrlConfig {
    host: string;
    insertHeadersConfig?: outputs.ElbL7policyRedirectUrlConfigInsertHeadersConfig;
    path: string;
    port: string;
    protocol: string;
    query?: string;
    removeHeadersConfig?: outputs.ElbL7policyRedirectUrlConfigRemoveHeadersConfig;
    statusCode: string;
}

export interface ElbL7policyRedirectUrlConfigInsertHeadersConfig {
    configs: outputs.ElbL7policyRedirectUrlConfigInsertHeadersConfigConfig[];
}

export interface ElbL7policyRedirectUrlConfigInsertHeadersConfigConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface ElbL7policyRedirectUrlConfigRemoveHeadersConfig {
    configs: outputs.ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfig[];
}

export interface ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfig {
    key: string;
}

export interface ElbL7ruleCondition {
    key?: string;
    value: string;
}

export interface ElbListenerPortRange {
    endPort: number;
    startPort: number;
}

export interface ElbMemberReason {
    expectedResponse: string;
    healthcheckResponse: string;
    reasonCode: string;
}

export interface ElbMemberStatus {
    listenerId: string;
    operatingStatus: string;
    reasons: outputs.ElbMemberStatusReason[];
}

export interface ElbMemberStatusReason {
    expectedResponse: string;
    healthcheckResponse: string;
    reasonCode: string;
}

export interface ElbPoolPersistence {
    cookieName?: string;
    timeout: number;
    type: string;
}

export interface ElbSecurityPolicyListener {
    id: string;
}

export interface FgsApplicationRepository {
    /**
     * The HTTP address of the repository.
     */
    httpsUrl: string;
    /**
     * The project ID of the repository.
     */
    projectId: string;
    /**
     * The repository status.
     */
    status: string;
    /**
     * The repository link.
     */
    webUrl: string;
}

export interface FgsApplicationStackResource {
    /**
     * The cloud service name.
     */
    displayName: string;
    /**
     * The hyperlink.
     */
    href: string;
    /**
     * The logical resource name.
     */
    logicalResourceName: string;
    /**
     * The logical resource type.
     */
    logicalResourceType: string;
    /**
     * The physical resource ID.
     */
    physicalResourceId: string;
    /**
     * The physical resource name.
     */
    physicalResourceName: string;
    /**
     * The status of resource.
     */
    resourceStatus: string;
    /**
     * The status information.
     */
    statusMessage: string;
}

export interface FgsAsyncInvokeConfigurationOnFailure {
    /**
     * The object type.
     */
    destination: string;
    /**
     * The parameters (in JSON format) corresponding to the target service.
     */
    param: string;
}

export interface FgsAsyncInvokeConfigurationOnSuccess {
    /**
     * The object type.
     */
    destination: string;
    /**
     * The parameters (in JSON format) corresponding to the target service.
     */
    param: string;
}

export interface GesGraphEncryption {
    /**
     * Whether to enable data encryption The value can be true or false. The default value is false.
     */
    enable: boolean;
    /**
     * ID of the customer master key created by DEW in the project corresponding to the graph creation.
     */
    masterKeyId: string;
}

export interface GesGraphLtsOperationTrace {
    /**
     * LTS log group name.
     */
    auditLogGroupName: string;
    /**
     * Whether to enable graph audit. The default value is false.
     */
    enableAudit: boolean;
}

export interface GesGraphPublicIp {
    /**
     * The EIP ID.
     */
    eipId: string;
    /**
     * The bind type of public IP.
     */
    publicBindType: string;
}

export interface GesGraphVertexIdType {
    /**
     * The length of ID.
     */
    idLength: number;
    /**
     * Vertex ID type.
     */
    idType: string;
}

export interface GetApigAclPoliciesPolicy {
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The entity type of the ACL policy.
     */
    entityType: string;
    /**
     * The ID of the ACL policy.
     */
    id: string;
    /**
     * The name of the ACL policy.
     */
    name: string;
    /**
     * The type of the ACL policy.
     */
    type: string;
    /**
     * The latest update time of the policy.
     */
    updatedAt: string;
    /**
     * The value of the ACL policy.
     */
    value: string;
}

export interface GetApigApiAssociatedAclPoliciesPolicy {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the ACL policy is bound to the API.
     */
    bindTime: string;
    /**
     * The entity type of the ACL policy.
     */
    entityType: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the ACL policy.
     */
    id: string;
    /**
     * The name of the ACL policy.
     */
    name: string;
    /**
     * The type of the ACL policy.
     */
    type: string;
    /**
     * One or more objects from which the access will be controlled.
     */
    value: string;
}

export interface GetApigApiAssociatedApplicationsApplication {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the application is bound to the API.
     */
    bindTime: string;
    /**
     * The description of the application.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the application.
     */
    id: string;
    /**
     * The name of the application.
     */
    name: string;
}

export interface GetApigApiAssociatedPluginsPlugin {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the plugin is bound to the API.
     */
    bindTime: string;
    /**
     * The configuration details for the plugin.
     */
    content: string;
    /**
     * The description of the plugin.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the plugin.
     */
    id: string;
    /**
     * The name of the plugin.
     */
    name: string;
    /**
     * The type of the plugin.
     */
    type: string;
}

export interface GetApigApiAssociatedSignaturesSignature {
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the signature is bound to the API.
     */
    bindTime: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the signature.
     */
    id: string;
    /**
     * The signature key.
     */
    key: string;
    /**
     * The name of the signature.
     */
    name: string;
    /**
     * The signature secret.
     */
    secret: string;
    /**
     * The type of the signature.
     */
    type: string;
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicy {
    /**
     * The array of one or more special throttling policies for APP limit.
     */
    appThrottles: outputs.GetApigApiAssociatedThrottlingPoliciesPolicyAppThrottle[];
    /**
     * The bind ID.
     */
    bindId: string;
    /**
     * The time that the throttling policy is bound to the API, in RFC3339 format.
     */
    bindTime: string;
    /**
     * The creation time of the throttling policy, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of the throttling policy.
     */
    description: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of the throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The maximum number of times the API can be accessed by an app within the same period.
     */
    maxAppRequests: number;
    /**
     * The maximum number of times the API can be accessed by an IP address within the same period.
     */
    maxIpRequests: number;
    /**
     * The maximum number of times the API can be accessed by a user within the same period.
     */
    maxUserRequests: number;
    /**
     * The name of the throttling policy.
     */
    name: string;
    /**
     * The period of time for limiting the number of API calls.
     */
    period: number;
    /**
     * The time unit for limiting the number of API calls.
     */
    periodUnit: string;
    /**
     * The type of the throttling policy.
     */
    type: string;
    /**
     * The array of one or more special throttling policies for IAM user limit.
     */
    userThrottles: outputs.GetApigApiAssociatedThrottlingPoliciesPolicyUserThrottle[];
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicyAppThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigApiAssociatedThrottlingPoliciesPolicyUserThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigApiBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiBasicConfigurationsConfiguration {
    /**
     * The ID of the authorizer to which the API request used.
     */
    authorizerId: string;
    /**
     * The backend type of the API.
     */
    backendType: string;
    /**
     * Whether CORS is supported.
     */
    cors: boolean;
    /**
     * The description of the API.
     */
    description: string;
    /**
     * The ID of the environment where the API is published.
     */
    envId: string;
    /**
     * The name of the environment where the API is published.
     */
    envName: string;
    /**
     * The ID of group corresponding to the API.
     */
    groupId: string;
    /**
     * The name of group corresponding to the API.
     */
    groupName: string;
    /**
     * The version of group corresponding to the API.
     */
    groupVersion: string;
    /**
     * The ID of the API.
     */
    id: string;
    /**
     * The matching mode of the API.
     */
    matching: string;
    /**
     * The name of the API.
     */
    name: string;
    /**
     * The ID of publish corresponding to the API.
     */
    publishId: string;
    /**
     * The published time of the API, in RFC3339 format.
     */
    publishedAt: string;
    /**
     * The registered time of the API, in RFC3339 format.
     */
    registeredAt: string;
    /**
     * The request method of the API.
     */
    requestMethod: string;
    /**
     * The request address of the API.
     */
    requestPath: string;
    /**
     * The request protocol of the API.
     */
    requestProtocol: string;
    /**
     * The security authentication mode of the API request.
     */
    securityAuthentication: string;
    /**
     * Whether the authentication of the application code is enabled.
     */
    simpleAuthentication: boolean;
    /**
     * The list of tags configuration.
     */
    tags: string[];
    /**
     * The type of the API.
     */
    type: string;
    /**
     * The latest update time of the API, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigApiFuncGraph {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The ID of the FunctionGraph backend configuration.
     */
    id: string;
    /**
     * The invocation type.
     */
    invocationType: string;
    /**
     * The network architecture (framework) type of the FunctionGraph function.
     */
    networkType: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The version of the FunctionGraph function.
     */
    version: string;
}

export interface GetApigApiFuncGraphPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The configaiton list of the backend parameters.
     */
    backendParams: outputs.GetApigApiFuncGraphPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiFuncGraphPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The alias URN of the FunctionGraph function.
     */
    functionAliasUrn: string;
    /**
     * The URN of the FunctionGraph function.
     */
    functionUrn: string;
    /**
     * The ID of the FunctionGraph backend policy.
     */
    id: string;
    /**
     * The invocation mode of the FunctionGraph function.
     */
    invocationType: string;
    /**
     * The name of the backend policy.
     */
    name: string;
    /**
     * The network (framework) type of the FunctionGraph function.
     */
    networkType: string;
    /**
     * The request protocol of the FunctionGraph function.
     */
    requestProtocol: string;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The version of the FunctionGraph function.
     */
    version: string;
}

export interface GetApigApiFuncGraphPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiFuncGraphPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigApiMock {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The ID of the mock backend configuration.
     */
    id: string;
    /**
     * The response of the mock backend configuration.
     */
    response: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface GetApigApiMockPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The configuration list of backend parameters.
     */
    backendParams: outputs.GetApigApiMockPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiMockPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The ID of the mock backend policy.
     */
    id: string;
    /**
     * The backend policy name.
     */
    name: string;
    /**
     * The response of the backend policy.
     */
    response: string;
    /**
     * The custom status code of the mock response.
     */
    statusCode: number;
}

export interface GetApigApiMockPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiMockPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigApiRequestParam {
    /**
     * The default value of the parameter.
     */
    default: string;
    /**
     * The parameter description.
     */
    description: string;
    /**
     * The enumerated value.
     */
    enumeration: string;
    /**
     * The parameter example.
     */
    example: string;
    /**
     * The ID of the request parameter.
     */
    id: string;
    /**
     * Where this parameter is located.
     */
    location: string;
    /**
     * The maximum value or length (string parameter) for parameter.
     */
    maximum: number;
    /**
     * The minimum value or length (string parameter) for parameter.
     */
    minimum: number;
    /**
     * The name of the request parameter.
     */
    name: string;
    /**
     * Whether to transparently transfer the parameter.
     */
    passthrough: boolean;
    /**
     * Whether this parameter is required.
     */
    required: boolean;
    /**
     * The parameter type.
     */
    type: string;
    /**
     * Whether to enable the parameter validation.
     */
    validEnable: number;
}

export interface GetApigApiWeb {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The backend service address.
     */
    backendAddress: string;
    /**
     * The proxy host header.
     */
    hostHeader: string;
    /**
     * The ID of the backend configuration.
     */
    id: string;
    /**
     * The backend request path.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod: string;
    /**
     * The web protocol type of the API request.
     */
    requestProtocol: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount: number;
    /**
     * Whether to enable two-way authentication.
     */
    sslEnable: boolean;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId: string;
}

export interface GetApigApiWebPolicy {
    /**
     * The ID of the backend custom authorization.
     */
    authorizerId: string;
    /**
     * The backend service address
     */
    backendAddress: string;
    /**
     * The configuration list of the backend parameters.
     */
    backendParams: outputs.GetApigApiWebPolicyBackendParam[];
    /**
     * The policy conditions.
     */
    conditions: outputs.GetApigApiWebPolicyCondition[];
    /**
     * The effective mode of the backend policy.
     */
    effectiveMode: string;
    /**
     * The proxy host header.
     */
    hostHeader: string;
    /**
     * The ID of the web policy.
     */
    id: string;
    /**
     * The name of the web policy.
     */
    name: string;
    /**
     * The backend request address.
     */
    path: string;
    /**
     * The backend request method of the API.
     */
    requestMethod: string;
    /**
     * The backend request protocol.
     */
    requestProtocol: string;
    /**
     * The number of retry attempts to request the backend service.
     */
    retryCount: number;
    /**
     * The timeout for API requests to backend service.
     */
    timeout: number;
    /**
     * The VPC channel ID.
     */
    vpcChannelId: string;
}

export interface GetApigApiWebPolicyBackendParam {
    /**
     * The description of the constant or system parameter.
     */
    description: string;
    /**
     * The ID of the backend parameter.
     */
    id: string;
    /**
     * Where the parameter is located.
     */
    location: string;
    /**
     * The name of parameter.
     */
    name: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The type of the system parameter.
     */
    systemParamType: string;
    /**
     * The name of parameter.
     */
    type: string;
    /**
     * The value of the parameter.
     */
    value: string;
}

export interface GetApigApiWebPolicyCondition {
    /**
     * The cookie parameter name.
     */
    cookieName: string;
    /**
     * The frontend authentication parameter name.
     */
    frontendAuthorizerName: string;
    /**
     * The ID of the backend policy condition.
     */
    id: string;
    /**
     * The request parameter name.
     */
    paramName: string;
    /**
     * The ID of the corresponding request parameter.
     */
    requestId: string;
    /**
     * The location of the corresponding request parameter.
     */
    requestLocation: string;
    /**
     * The type of the backend policy.
     */
    source: string;
    /**
     * The gateway built-in parameter name.
     */
    sysName: string;
    /**
     * The condition type of the backend policy.
     */
    type: string;
    /**
     * The value corresponding to the parameter name.
     */
    value: string;
}

export interface GetApigAppcodesAppcode {
    /**
     * The ID of the application.
     */
    applicationId: string;
    /**
     * The creation time of the APPCODE, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The ID of the APPCODE.
     */
    id: string;
    /**
     * The APPCODE value (content).
     */
    value: string;
}

export interface GetApigApplicationQuotasQuota {
    /**
     * The number of applications bound to the quota policy.
     */
    boundAppNum: number;
    /**
     * The maximum number of times a application quota can be called.
     */
    callLimits: number;
    /**
     * The creation time of the application quota, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of the application quota.
     */
    description: string;
    /**
     * The ID of the application quota.
     */
    id: string;
    /**
     * The name of the application quota.
     */
    name: string;
    /**
     * The time limit of a quota.
     */
    timeInterval: number;
    /**
     * The time unit.
     */
    timeUnit: string;
}

export interface GetApigApplicationsApplication {
    /**
     * The key of the application.
     */
    appKey: string;
    /**
     * The secret of the application.
     */
    appSecret: string;
    /**
     * The type of the application.
     */
    appType: string;
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The creation time of the application.
     */
    createdAt: string;
    /**
     * The creator of the application.
     */
    createdBy: string;
    /**
     * The description of the application.
     */
    description: string;
    /**
     * The ID of the application.
     */
    id: string;
    /**
     * The name of the application.
     */
    name: string;
    /**
     * The status of the application.
     */
    status: number;
    /**
     * The latest update time of the application.
     */
    updatedAt: string;
}

export interface GetApigChannelsVpcChannel {
    /**
     * The distribution algorithm.
     */
    balanceStrategy: number;
    /**
     * The creation time of channel, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The ID of the VPC channel.
     */
    id: string;
    /**
     * The parameter member groups of the VPC channels.
     */
    memberGroups: outputs.GetApigChannelsVpcChannelMemberGroup[];
    /**
     * The member type of the VPC channel.
     */
    memberType: string;
    /**
     * The name of the VPC channel.
     */
    name: string;
    /**
     * The port of the backend server.
     */
    port: number;
    /**
     * The type of the VPC channel.
     */
    type: number;
}

export interface GetApigChannelsVpcChannelMemberGroup {
    /**
     * The description of the member group.
     */
    description: string;
    /**
     * The ID of the member group.
     */
    id: string;
    /**
     * The microservice tags of the backend server group.
     */
    microserviceLabels: outputs.GetApigChannelsVpcChannelMemberGroupMicroserviceLabel[];
    /**
     * The microservice port of the backend server group.
     */
    microservicePort: number;
    /**
     * The microservice version of the backend server group.
     */
    microserviceVersion: string;
    /**
     * The name of the member group.
     */
    name: string;
    /**
     * The weight of the current member group.
     */
    weight: number;
}

export interface GetApigChannelsVpcChannelMemberGroupMicroserviceLabel {
    /**
     * The name of the microservice label.
     */
    name: string;
    /**
     * The value of the microservice label.
     */
    value: string;
}

export interface GetApigCustomAuthorizersAuthorizer {
    /**
     * The maximum cache age of custom authorizer.
     */
    cacheAge: number;
    /**
     * The creation time of custom authorizer.
     */
    createdAt: string;
    /**
     * The version alias URI of the FGS function.
     */
    functionAliasUri: string;
    /**
     * The type of the FGS function.
     */
    functionType: string;
    /**
     * The URN of the FGS function.
     */
    functionUrn: string;
    /**
     * The version of the FGS function.
     */
    functionVersion: string;
    /**
     * The ID of the custom authorizer.
     */
    id: string;
    /**
     * The parameter identities of the custom authorizer.
     */
    identities: outputs.GetApigCustomAuthorizersAuthorizerIdentity[];
    /**
     * Whether to send the body of custom authorizer.
     */
    isBodySend: boolean;
    /**
     * The name of the custom authorizer.
     */
    name: string;
    /**
     * The network architecture types of function.
     */
    networkType: string;
    /**
     * The type of the custom authorizer.
     */
    type: string;
    /**
     * The user data of custom authorizer.
     */
    userData: string;
}

export interface GetApigCustomAuthorizersAuthorizerIdentity {
    /**
     * The parameter location of identity.
     */
    location: string;
    /**
     * The name of the parameter to be verified.
     */
    name: string;
    /**
     * The parameter verification expression of identity.
     */
    validation: string;
}

export interface GetApigEndpointConnectionsConnection {
    /**
     * The creation time of the endpoint connection, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The IAM account ID of the endpoint connection creator.
     */
    domainId: string;
    /**
     * The ID of the endpoint connection.
     */
    id: string;
    /**
     * The packet ID of the endpoint connection.
     */
    packetId: number;
    /**
     * The current status of the endpoint connection.
     */
    status: string;
    /**
     * The latest time of the endpoint connection, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigEnvironmentVariablesVariable {
    /**
     * The environment ID corresponding to the environment variable.
     */
    envId: string;
    /**
     * The group ID corresponding to the environment variable.
     */
    groupId: string;
    /**
     * The ID of the environment variable.
     */
    id: string;
    /**
     * The name of the environment variable.
     */
    name: string;
    /**
     * The value of the environment variable.
     */
    value: string;
}

export interface GetApigGroupsGroup {
    createdAt: string;
    description: string;
    /**
     * The array of one or more environments of the associated group.
     */
    environments: outputs.GetApigGroupsGroupEnvironment[];
    id: string;
    isDefault: number;
    name: string;
    onSellStatus: number;
    slDomain: string;
    slDomains: string[];
    status: number;
    updatedAt: string;
    urlDomains: outputs.GetApigGroupsGroupUrlDomain[];
}

export interface GetApigGroupsGroupEnvironment {
    /**
     * The ID of the environment to which the variables belongs.
     */
    environmentId: string;
    /**
     * The array of one or more environment variables.
     */
    variables: outputs.GetApigGroupsGroupEnvironmentVariable[];
}

export interface GetApigGroupsGroupEnvironmentVariable {
    /**
     * The ID of the variable that the group has.
     */
    id: string;
    /**
     * The variable name.
     */
    name: string;
    /**
     * The variable value.
     */
    value: string;
}

export interface GetApigGroupsGroupUrlDomain {
    cnameStatus: number;
    id: string;
    isHasTrustedRootCa: boolean;
    minSslVersion: string;
    name: string;
    sslId: string;
    sslName: string;
    verifiedClientCertificateEnabled: boolean;
}

export interface GetApigInstanceFeaturesFeature {
    /**
     * The detailed configuration of the instance feature.
     */
    config: string;
    /**
     * Whether the feature is enabled.
     */
    enabled: boolean;
    /**
     * The ID of the feature.
     */
    id: string;
    /**
     * The name of the feature.
     */
    name: string;
    /**
     * The latest update time of the feature, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetApigInstancesInstance {
    /**
     * The creation time of the instance, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The edition of instance.
     */
    edition: string;
    /**
     * The elastic IP address of instance binding.
     */
    eipAddress: string;
    /**
     * The enterprise project ID of the instance.
     */
    enterpriseProjectId: string;
    /**
     * The ID of instance.
     */
    id: string;
    /**
     * The type of load balancer used by the instance.
     */
    loadbalancerProvider: string;
    /**
     * The name of instance.
     */
    name: string;
    /**
     * The status of instance.
     */
    status: string;
    /**
     * The type of instance.
     */
    type: string;
}

export interface GetApigSignaturesSignature {
    /**
     * The algorithm of the signature.
     */
    algorithm: string;
    /**
     * The number of bound APIs.
     */
    bindNum: number;
    /**
     * The creation time of the signature.
     */
    createdAt: string;
    /**
     * The ID of the signature.
     */
    id: string;
    /**
     * The key of the signature.
     */
    key: string;
    /**
     * The name of the signature.
     */
    name: string;
    /**
     * The secret of the signature.
     */
    secret: string;
    /**
     * The type of the signature.
     */
    type: string;
    /**
     * The latest update time of the signature.
     */
    updatedAt: string;
}

export interface GetApigThrottlingPoliciesPolicy {
    /**
     * The array of one or more special throttling policies for APP limit.
     */
    appThrottles: outputs.GetApigThrottlingPoliciesPolicyAppThrottle[];
    /**
     * The number of APIs bound to the throttling policy.
     */
    bindNum: number;
    /**
     * The creation time of the throttling policy, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The description of throttling policy.
     */
    description: string;
    /**
     * The ID of the throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The maximum number of times the API can be accessed by an app within the same period.
     */
    maxAppRequests: number;
    /**
     * The maximum number of times the API can be accessed by an IP address within the same period.
     */
    maxIpRequests: number;
    /**
     * The maximum number of times the API can be accessed by a user within the same period.
     */
    maxUserRequests: number;
    /**
     * The name of the throttling policy.
     */
    name: string;
    /**
     * The period of time for limiting the number of API calls.
     */
    period: number;
    /**
     * The time unit for limiting the number of API calls.
     */
    periodUnit: string;
    /**
     * The type of the throttling policy.
     */
    type: string;
    /**
     * The array of one or more special throttling policies for IAM user limit.
     */
    userThrottles: outputs.GetApigThrottlingPoliciesPolicyUserThrottle[];
}

export interface GetApigThrottlingPoliciesPolicyAppThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetApigThrottlingPoliciesPolicyUserThrottle {
    /**
     * The ID of the special user/application throttling policy.
     */
    id: string;
    /**
     * The maximum number of times an API can be accessed within a specified period.
     */
    maxApiRequests: number;
    /**
     * The object ID which the special user/application throttling policy belongs.
     */
    throttlingObjectId: string;
    /**
     * The object name which the special user/application throttling policy belongs.
     */
    throttlingObjectName: string;
}

export interface GetCbhAvailabilityZonesAvailabilityZone {
    displayName: string;
    name: string;
    regionId: string;
    status: string;
    type: string;
}

export interface GetCbhFlavorsFlavor {
    asset: number;
    dataDiskSize: number;
    ecsSystemDataSize: number;
    id: string;
    maxConnection: number;
    memory: number;
    type: string;
    vcpus: number;
}

export interface GetCbhInstancesInstance {
    /**
     * Indicates the availability zone name.
     */
    availabilityZone: string;
    /**
     * Indicates the specification of the instance.
     */
    flavorId: string;
    /**
     * Indicates the ID of the instance.
     */
    id: string;
    /**
     * Indicates the instance name.
     */
    name: string;
    /**
     * Indicates the private IP address of the instance.
     */
    privateIp: string;
    /**
     * Indicates the elastic IP address.
     */
    publicIp: string;
    /**
     * Indicates the ID of the elastic IP.
     */
    publicIpId: string;
    /**
     * Indicates the ID of a security group.
     */
    securityGroupId: string;
    /**
     * Indicates the status of the instance.
     */
    status: string;
    /**
     * Indicates the ID of a subnet.
     */
    subnetId: string;
    /**
     * Indicates the current version of the instance image.
     */
    version: string;
    /**
     * Indicates the ID of a VPC.
     */
    vpcId: string;
}

export interface GetCbrBackupChildren {
    /**
     * The restore point ID of the sub-backup resource.
     */
    checkpointId: string;
    /**
     * The creation time of the sub-backup.
     */
    createdAt: string;
    /**
     * The sub-backup description.
     */
    description: string;
    /**
     * The enterprise project to which the backup sub-backup resource belongs.
     */
    enterpriseProjectId: string;
    /**
     * The expiration time of the sub-backup.
     */
    expiredAt: string;
    /**
     * The extended information.
     */
    extendInfos: outputs.GetCbrBackupChildrenExtendInfo[];
    /**
     * The sub-backup ID.
     */
    id: string;
    /**
     * The sub-backup name.
     */
    name: string;
    /**
     * The replication records.
     */
    replicationRecords: outputs.GetCbrBackupChildrenReplicationRecord[];
    /**
     * The availability zone where the backup sub-backup resource is located.
     */
    resourceAz: string;
    /**
     * The sub-backup resource ID.
     */
    resourceId: string;
    /**
     * The sub-backup resource name.
     */
    resourceName: string;
    /**
     * The sub-backup resource size, in GB.
     */
    resourceSize: number;
    /**
     * The sub-backup resource type.
     */
    resourceType: string;
    /**
     * The sub-backup status.
     */
    status: string;
    /**
     * The sub-backup type.
     */
    type: string;
    /**
     * The latest update time of the sub-backup.
     */
    updatedAt: string;
    /**
     * The vault to which the backup sub-backup resource belongs.
     */
    vaultId: string;
}

export interface GetCbrBackupChildrenExtendInfo {
    /**
     * Whether the backup is automatically generated.
     */
    autoTrigger: boolean;
    /**
     * Whether the backup is a system disk backup.
     */
    bootable: boolean;
    /**
     * Whether the VM backup data contains system disk data.
     */
    containSystemDisk: boolean;
    /**
     * Whether the backup is encrypted.
     */
    encrypted: boolean;
    /**
     * Whether the backup is an incremental backup.
     */
    incremental: boolean;
    /**
     * Whether the disk is a system disk.
     */
    isSystemDisk: boolean;
    /**
     * The ID list of images created using backups.
     */
    osRegistryImages: string[];
    /**
     * Snapshot ID of the disk backup.
     */
    snapshotId: string;
    /**
     * Whether to allow lazyloading for fast restoration.
     */
    supportLld: boolean;
    /**
     * The restoration mode.
     */
    supportedRestoreMode: string;
}

export interface GetCbrBackupChildrenReplicationRecord {
    /**
     * The creation time of the replication.
     */
    createdAt: string;
    /**
     * The ID of the destination backup used for replication.
     */
    destinationBackupId: string;
    /**
     * The record ID of the destination backup used for replication.
     */
    destinationCheckpointId: string;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The replication destination region.
     */
    destinationRegion: string;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The additional information of the replication.
     */
    extraInfos: outputs.GetCbrBackupChildrenReplicationRecordExtraInfo[];
    /**
     * The replication record ID.
     */
    id: string;
    /**
     * The ID of the source backup used for replication.
     */
    sourceBackupId: string;
    /**
     * The ID of the source backup record used for replication.
     */
    sourceCheckpointId: string;
    /**
     * The ID of the replication source project.
     */
    sourceProjectId: string;
    /**
     * The replication source region.
     */
    sourceRegion: string;
    /**
     * The replication status.
     */
    status: string;
    /**
     * The ID of the vault where the backup resides.
     */
    vaultId: string;
}

export interface GetCbrBackupChildrenReplicationRecordExtraInfo {
    /**
     * Whether replication is automatically scheduled.
     */
    autoTrigger: boolean;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The error code.
     */
    failCode: string;
    /**
     * The error cause.
     */
    failReason: string;
    /**
     * The replication progress.
     */
    progress: number;
}

export interface GetCbrBackupExtendInfo {
    /**
     * Whether the backup is automatically generated.
     */
    autoTrigger: boolean;
    /**
     * Whether the backup is a system disk backup.
     */
    bootable: boolean;
    /**
     * Whether the VM backup data contains system disk data.
     */
    containSystemDisk: boolean;
    /**
     * Whether the backup is encrypted.
     */
    encrypted: boolean;
    /**
     * Whether the backup is an incremental backup.
     */
    incremental: boolean;
    /**
     * Whether the disk is a system disk.
     */
    isSystemDisk: boolean;
    /**
     * The ID list of images created using backups.
     */
    osRegistryImages: string[];
    /**
     * Snapshot ID of the disk backup.
     */
    snapshotId: string;
    /**
     * Whether to allow lazyloading for fast restoration.
     */
    supportLld: boolean;
    /**
     * The restoration mode.
     */
    supportedRestoreMode: string;
}

export interface GetCbrBackupReplicationRecord {
    /**
     * The creation time of the replication.
     */
    createdAt: string;
    /**
     * The ID of the destination backup used for replication.
     */
    destinationBackupId: string;
    /**
     * The record ID of the destination backup used for replication.
     */
    destinationCheckpointId: string;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The replication destination region.
     */
    destinationRegion: string;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The additional information of the replication.
     */
    extraInfos: outputs.GetCbrBackupReplicationRecordExtraInfo[];
    /**
     * The replication record ID.
     */
    id: string;
    /**
     * The ID of the source backup used for replication.
     */
    sourceBackupId: string;
    /**
     * The ID of the source backup record used for replication.
     */
    sourceCheckpointId: string;
    /**
     * The ID of the replication source project.
     */
    sourceProjectId: string;
    /**
     * The replication source region.
     */
    sourceRegion: string;
    /**
     * The replication status.
     */
    status: string;
    /**
     * The ID of the vault where the backup resides.
     */
    vaultId: string;
}

export interface GetCbrBackupReplicationRecordExtraInfo {
    /**
     * Whether replication is automatically scheduled.
     */
    autoTrigger: boolean;
    /**
     * The destination vault ID.
     */
    destinationVaultId: string;
    /**
     * The error code.
     */
    failCode: string;
    /**
     * The error cause.
     */
    failReason: string;
    /**
     * The replication progress.
     */
    progress: number;
}

export interface GetCbrPoliciesPolicy {
    /**
     * The vault associated with the CBR policy
     */
    associatedVaults: outputs.GetCbrPoliciesPolicyAssociatedVault[];
    /**
     * The scheduling rule for the CBR policy backup execution.
     */
    backupCycles: outputs.GetCbrPoliciesPolicyBackupCycle[];
    /**
     * The maximum number of retained backups.
     */
    backupQuantity: number;
    /**
     * The ID of the replication destination project.
     */
    destinationProjectId: string;
    /**
     * The name of the replication destination region.
     */
    destinationRegion: string;
    /**
     * Whether to enable the acceleration function to shorten the replication time for cross-region
     */
    enableAcceleration: boolean;
    /**
     * Whether to enable the CBR policy.
     */
    enabled: boolean;
    /**
     * The policy ID.
     */
    id: string;
    /**
     * The long-term retention rules.
     */
    longTermRetentions: outputs.GetCbrPoliciesPolicyLongTermRetention[];
    /**
     * The policy name.
     */
    name: string;
    /**
     * The duration (in days) for retained backups.
     */
    timePeriod: number;
    /**
     * The UTC time zone.
     */
    timeZone: string;
    /**
     * The protection type of the CBR policy.
     */
    type: string;
}

export interface GetCbrPoliciesPolicyAssociatedVault {
    /**
     * The destination vault ID associated with CBR policy
     */
    destinationVaultId: string;
    /**
     * The vault ID of the associated CBR policy
     */
    vaultId: string;
}

export interface GetCbrPoliciesPolicyBackupCycle {
    /**
     * The weekly backup time.
     */
    days: string;
    /**
     * The execution time of the policy.
     */
    executionTimes: string[];
    /**
     * The number of days between each backup.
     */
    interval: number;
}

export interface GetCbrPoliciesPolicyLongTermRetention {
    /**
     * The latest backup of each day is saved in the long term.
     */
    daily: number;
    /**
     * How often (after how many incremental backups) a full backup is performed.
     */
    fullBackupInterval: number;
    /**
     * The latest backup of each month is saved in the long term.
     */
    monthly: number;
    /**
     * The latest backup of each week is saved in the long term.
     */
    weekly: number;
    /**
     * The latest backup of each year is saved in the long term.
     */
    yearly: number;
}

export interface GetCdmFlavorsFlavor {
    cpu: string;
    id: string;
    memory: string;
    name: string;
}

export interface GetDcsAccountsAccount {
    /**
     * Account name.
     */
    accountName: string;
    /**
     * Account permissions.
     */
    accountRole: string;
    /**
     * Account type.
     */
    accountType: string;
    /**
     * Account description.
     */
    description: string;
    /**
     * Account ID.
     */
    id: string;
    /**
     * Account status.
     */
    status: string;
}

export interface GetDmsKafkaConsumerGroupsGroup {
    /**
     * Indicates the partition assignment strategy.
     */
    assignmentStrategy: string;
    /**
     * Indicates the coordinator ID.
     */
    coordinatorId: number;
    /**
     * Indicates the create time.
     */
    createdAt: string;
    /**
     * Indicates the consumer group description.
     */
    description: string;
    /**
     * Indicates the group message offsets.
     */
    groupMessageOffsets: outputs.GetDmsKafkaConsumerGroupsGroupGroupMessageOffset[];
    /**
     * Indicates the number of accumulated messages.
     */
    lag: number;
    /**
     * Indicates the consumer group members.
     */
    members: outputs.GetDmsKafkaConsumerGroupsGroupMember[];
    /**
     * Indicates the consumer group name.
     */
    name: string;
    /**
     * Indicates the consumer group status.
     */
    state: string;
}

export interface GetDmsKafkaConsumerGroupsGroupGroupMessageOffset {
    /**
     * Indicates the number of accumulated messages.
     */
    lag: number;
    /**
     * Indicates the message current offset.
     */
    messageCurrentOffset: number;
    /**
     * Indicates the message log end offset.
     */
    messageLogEndOffset: number;
    /**
     * Indicates the partition.
     */
    partition: number;
    /**
     * Indicates the topic name.
     */
    topic: string;
}

export interface GetDmsKafkaConsumerGroupsGroupMember {
    /**
     * Indicates the details about the partition assigned to the consumer.
     */
    assignments: outputs.GetDmsKafkaConsumerGroupsGroupMemberAssignment[];
    /**
     * Indicates the client ID.
     */
    clientId: string;
    /**
     * Indicates the consumer address.
     */
    host: string;
    /**
     * Indicates the member ID.
     */
    memberId: string;
}

export interface GetDmsKafkaConsumerGroupsGroupMemberAssignment {
    /**
     * Indicates the partitions.
     */
    partitions: number[];
    /**
     * Indicates the topic name.
     */
    topic: string;
}

export interface GetDmsKafkaMessagesMessage {
    /**
     * Indicates the application ID.
     */
    appId: string;
    /**
     * Indicates the big data flag.
     */
    hugeMessage: boolean;
    /**
     * Indicates the message key.
     */
    key: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
    /**
     * Indicates the message offset.
     */
    messageOffset: number;
    /**
     * Indicates the partition where the message is located.
     */
    partition: number;
    /**
     * Indicates the message size.
     */
    size: number;
    /**
     * Indicates the message label.
     */
    tag: string;
    /**
     * Indicates the message production time.
     */
    timestamp: string;
    /**
     * Indicates the message content.
     */
    value: string;
}

export interface GetDmsKafkaUsersUser {
    /**
     * Indicates the create time.
     */
    createdAt: string;
    /**
     * Indicates whether the application is the default application.
     */
    defaultApp: boolean;
    /**
     * Indicates the description.
     */
    description: string;
    /**
     * Indicates the username.
     */
    name: string;
    /**
     * Indicates the user role.
     */
    role: string;
}

export interface GetDmsRabbitmqFlavorsFlavor {
    archTypes: string[];
    chargingModes: string[];
    id: string;
    ios: outputs.GetDmsRabbitmqFlavorsFlavorIo[];
    properties: outputs.GetDmsRabbitmqFlavorsFlavorProperty[];
    supportFeatures: outputs.GetDmsRabbitmqFlavorsFlavorSupportFeature[];
    type: string;
    vmSpecification: string;
}

export interface GetDmsRabbitmqFlavorsFlavorIo {
    availabilityZones: string[];
    storageSpecCode: string;
    type: string;
    unavailabilityZones: string[];
}

export interface GetDmsRabbitmqFlavorsFlavorProperty {
    flavorAlias: string;
    maxBandwidthPerBroker: number;
    maxBroker: number;
    maxConsumerPerBroker: number;
    maxPartitionPerBroker: number;
    maxStoragePerNode: number;
    maxTpsPerBroker: number;
    minBroker: number;
    minStoragePerNode: number;
}

export interface GetDmsRabbitmqFlavorsFlavorSupportFeature {
    name: string;
    properties: outputs.GetDmsRabbitmqFlavorsFlavorSupportFeatureProperty[];
}

export interface GetDmsRabbitmqFlavorsFlavorSupportFeatureProperty {
    maxNode: number;
    maxTask: number;
    minNode: number;
    minTask: number;
}

export interface GetDmsRocketmqConsumerGroupAccessUsersPolicy {
    /**
     * Indicates the user name.
     */
    accessKey: string;
    /**
     * Indicates whether the user is an administrator.
     */
    admin: boolean;
    /**
     * Indicates the permissions.
     */
    perm: string;
    /**
     * Indicates the IP address whitelist.
     */
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqConsumerGroupsGroup {
    broadcast: boolean;
    brokers: string[];
    description: string;
    enabled: boolean;
    name: string;
    retryMaxTimes: number;
}

export interface GetDmsRocketmqConsumersClient {
    /**
     * Indicates the client address.
     */
    clientAddress: string;
    /**
     * Indicates the client ID.
     */
    clientId: string;
    /**
     * Indicates the client language.
     */
    language: string;
    /**
     * Indicates the subscription list.
     */
    subscriptions: outputs.GetDmsRocketmqConsumersClientSubscription[];
    /**
     * Indicates the client version.
     */
    version: string;
}

export interface GetDmsRocketmqConsumersClientSubscription {
    /**
     * Indicates the subscription tag.
     */
    expression: string;
    /**
     * Indicates the name of the subscribed topic.
     */
    topic: string;
    /**
     * Indicates the subscription type.
     */
    type: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavor {
    /**
     * Indicates the list of supported CPU architectures.
     */
    archTypes: string[];
    /**
     * Indicates the AZs where there are available resources.
     */
    availableZones: string[];
    /**
     * Indicates the billing code.
     */
    billingCode: string;
    /**
     * Indicates the list of supported billing modes.
     */
    chargingModes: string[];
    /**
     * Indicates the flavor ID.
     */
    id: string;
    /**
     * Indicates the list of supported disk IO types.
     */
    ios: outputs.GetDmsRocketmqExtendFlavorsFlavorIo[];
    /**
     * Indicates the properties of the current specification.
     */
    properties: outputs.GetDmsRocketmqExtendFlavorsFlavorProperty[];
    /**
     * Indicates the supported features.
     */
    supportFeatures: outputs.GetDmsRocketmqExtendFlavorsFlavorSupportFeature[];
    /**
     * Indicates the flavor type.
     */
    type: string;
    /**
     * Indicates the AZs where resources are unavailable.
     */
    unavailableZones: string[];
    /**
     * Indicates the underlying VM specification.
     */
    vmSpecification: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavorIo {
    /**
     * Indicates the list of availability zones with available resources.
     */
    availableZones: string[];
    /**
     * Indicates the disk IO encoding.
     */
    storageSpecCode: string;
    /**
     * Indicates the disk type.
     */
    type: string;
    /**
     * Indicates the list of unavailability zones with available resources.
     */
    unavailableZones: string[];
}

export interface GetDmsRocketmqExtendFlavorsFlavorProperty {
    /**
     * Indicates the version of the message engine.
     */
    engineVersions: string;
    /**
     * Indicates the alias of **flavor_id**.
     */
    flavorAlias: string;
    /**
     * Indicates the maximum number of brokers.
     */
    maxBroker: string;
    /**
     * Indicates the maximum number of consumers of each broker.
     */
    maxConsumerPerBroker: string;
    /**
     * Indicates the maximum storage space of each broker. Unit: GB.
     */
    maxStoragePerNode: string;
    /**
     * Indicates the maximum number of topics that can be created on each broker.
     */
    maxTopicPerBroker: string;
    /**
     * Indicates the minimum number of brokers.
     */
    minBroker: string;
    /**
     * Indicates the minimum storage space of each broker. Unit: GB.
     */
    minStoragePerNode: string;
}

export interface GetDmsRocketmqExtendFlavorsFlavorSupportFeature {
    /**
     * Indicates the feature name.
     */
    name: string;
    /**
     * Indicates the key-value pair of a feature.
     */
    properties: {[key: string]: string};
}

export interface GetDmsRocketmqFlavorsFlavor {
    /**
     * Indicates the list of the types of CPU architecture.
     */
    archTypes: string[];
    /**
     * Indicates the list of the billing modes.
     */
    chargingModes: string[];
    /**
     * Indicates the ID of the flavor.
     */
    id: string;
    /**
     * Indicates the list of disk IO types.
     */
    ios: outputs.GetDmsRocketmqFlavorsFlavorIo[];
    /**
     * Indicates the list of the properties of the current specification.
     */
    properties: outputs.GetDmsRocketmqFlavorsFlavorProperty[];
    /**
     * Indicates the list of features supported by the current specification.
     */
    supportFeatures: outputs.GetDmsRocketmqFlavorsFlavorSupportFeature[];
    /**
     * Indicates the type of the flavor.
     */
    type: string;
    /**
     * Indicates the underlying VM specification.
     */
    vmSpecification: string;
}

export interface GetDmsRocketmqFlavorsFlavorIo {
    /**
     * Indicates the list of availability zone names.
     */
    availabilityZones: string[];
    /**
     * Indicates the disk IO encoding.
     */
    storageSpecCode: string;
    /**
     * Indicates the disk type.
     */
    type: string;
    /**
     * Indicates the list of unavailability zone names.
     */
    unavailabilityZones: string[];
}

export interface GetDmsRocketmqFlavorsFlavorProperty {
    /**
     * Indicates the alias of the flavor.
     */
    flavorAlias: string;
    /**
     * Indicates the maximum bandwidth per broker.
     */
    maxBandwidthPerBroker: number;
    /**
     * Indicates the maximum number of brokers.
     */
    maxBroker: number;
    /**
     * Indicates the maximum number of consumers per broker.
     */
    maxConsumerPerBroker: number;
    /**
     * Indicates the maximum number of partitions per broker.
     */
    maxPartitionPerBroker: number;
    /**
     * Indicates the maximum storage per node. The unit is GB.
     */
    maxStoragePerNode: number;
    /**
     * Indicates the maximum TPS per broker.
     */
    maxTpsPerBroker: number;
    /**
     * Indicates the minimum number of brokers.
     */
    minBroker: number;
    /**
     * Indicates the minimum storage per node. The unit is GB.
     */
    minStoragePerNode: number;
}

export interface GetDmsRocketmqFlavorsFlavorSupportFeature {
    /**
     * Indicates the function name.
     */
    name: string;
    /**
     * Indicates the list of the function property details.
     */
    properties: outputs.GetDmsRocketmqFlavorsFlavorSupportFeatureProperty[];
}

export interface GetDmsRocketmqFlavorsFlavorSupportFeatureProperty {
    /**
     * Indicates the maximum number of nodes for the dump function.
     */
    maxNode: number;
    /**
     * Indicates the maximum number of tasks for the dump function.
     */
    maxTask: number;
    /**
     * Indicates the minimum number of nodes for the dump function.
     */
    minNode: number;
    /**
     * Indicates the minimum number of tasks for the dump function.
     */
    minTask: number;
}

export interface GetDmsRocketmqInstancesInstance {
    /**
     * Indicates the list of availability zone names.
     */
    availabilityZones: string[];
    /**
     * Indicates the service data address.
     */
    brokerAddress: string;
    /**
     * Indicates the broker numbers.
     */
    brokerNum: number;
    /**
     * Indicates the Cross-VPC access information.
     */
    crossVpcAccesses: outputs.GetDmsRocketmqInstancesInstanceCrossVpcAccess[];
    /**
     * Indicates the description of the DMS RocketMQ instance.
     */
    description: string;
    /**
     * Indicates whether access control is enabled.
     */
    enableAcl: boolean;
    /**
     * Indicates whether to enable public access.
     */
    enablePublicip: boolean;
    /**
     * Indicates the version of the RocketMQ engine.
     */
    engineVersion: string;
    /**
     * Indicates a product ID.
     */
    flavorId: string;
    /**
     * Indicates the ID of the DMS RocketMQ instance.
     */
    id: string;
    /**
     * Indicates whether to support IPv6.
     */
    ipv6Enable: boolean;
    /**
     * Indicates the time at which the maintenance window starts. The format is HH:mm:ss.
     */
    maintainBegin: string;
    /**
     * Indicates the time at which the maintenance window ends. The format is HH:mm:ss.
     */
    maintainEnd: string;
    /**
     * Indicates the name of the DMS RocketMQ instance.
     */
    name: string;
    /**
     * Indicates the metadata address.
     */
    namesrvAddress: string;
    /**
     * Indicates whether billing based on new specifications is enabled.
     */
    newSpecBillingEnable: boolean;
    /**
     * Indicates the node quantity.
     */
    nodeNum: number;
    /**
     * Indicates the public network service data address.
     */
    publicBrokerAddress: string;
    /**
     * Indicates the public network metadata address.
     */
    publicNamesrvAddress: string;
    /**
     * Indicates the public IP address.
     */
    publicipAddress: string;
    /**
     * Indicates the ID of the EIP bound to the instance.
     */
    publicipId: string;
    /**
     * Indicates the resource specifications.
     */
    resourceSpecCode: string;
    /**
     * Indicates the ID of a security group.
     */
    securityGroupId: string;
    /**
     * Indicates the instance specification.
     */
    specification: string;
    /**
     * Indicates whether the RocketMQ SASL_SSL is enabled.
     */
    sslEnable: boolean;
    /**
     * Indicates the status of the DMS RocketMQ instance.
     */
    status: string;
    /**
     * Indicates the message storage capacity. Unit: GB.
     */
    storageSpace: number;
    /**
     * Indicates the storage I/O specification.
     */
    storageSpecCode: string;
    /**
     * Indicates the ID of a subnet.
     */
    subnetId: string;
    /**
     * Indicates the DMS RocketMQ instance type. Value: cluster.
     */
    type: string;
    /**
     * Indicates the used message storage space. Unit: GB.
     */
    usedStorageSpace: number;
    /**
     * Indicates the ID of a VPC.
     */
    vpcId: string;
}

export interface GetDmsRocketmqInstancesInstanceCrossVpcAccess {
    advertisedIp: string;
    /**
     * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
     */
    lisenterIp: string;
    listenerIp: string;
    port: number;
    portId: string;
}

export interface GetDmsRocketmqMessageTracesTrace {
    /**
     * Specifies the message body length.
     */
    bodyLength: number;
    /**
     * Specifies the IP address of the host that generates the message.
     */
    clientHost: string;
    /**
     * Specifies the consumption status.
     */
    consumeStatus: number;
    /**
     * Specifies the time spent.
     */
    costTime: number;
    /**
     * Specifies whether the response is a transaction check response.
     */
    fromTransactionCheck: boolean;
    /**
     * Specifies the producer group or consumer group.
     */
    groupName: string;
    /**
     * Specifies the message keys.
     */
    keys: string;
    /**
     * Specifies the message ID.
     */
    messageId: string;
    /**
     * Specifies the message type.
     */
    messageType: string;
    /**
     * Specifies the offset message ID.
     */
    offsetMessageId: string;
    /**
     * Specifies the request ID.
     */
    requestId: string;
    /**
     * Specifies the number of retry times.
     */
    retryTimes: number;
    /**
     * Specifies the IP address of the host that stores the message.
     */
    storeHost: string;
    /**
     * Specifies whether the request is successful.
     */
    success: boolean;
    /**
     * Specifies the message tag.
     */
    tags: string;
    /**
     * Specifies the time.
     */
    time: string;
    /**
     * Specifies the topic name.
     */
    topic: string;
    /**
     * Specifies the trace type.
     */
    traceType: string;
    /**
     * Specifies the transaction ID.
     */
    transactionId: string;
    /**
     * Specifies the transaction status.
     */
    transactionState: string;
}

export interface GetDmsRocketmqMessagesMessage {
    /**
     * Indicates the message body.
     */
    body: string;
    /**
     * Indicates the message body checksum.
     */
    bodyCrc: number;
    /**
     * Indicates the IP address of the host that generates the message.
     */
    bornHost: string;
    /**
     * Indicates the message generated time.
     */
    bornTime: string;
    /**
     * Indicates the message ID.
     */
    messageId: string;
    /**
     * Indicates the property list.
     */
    propertyLists: outputs.GetDmsRocketmqMessagesMessagePropertyList[];
    /**
     * Indicates the queue ID.
     */
    queueId: number;
    /**
     * Indicates the offset in the queue.
     */
    queueOffset: number;
    /**
     * Indicates the number of retry times.
     */
    reconsumeTimes: number;
    /**
     * Indicates the IP address of the host that stores the message.
     */
    storeHost: string;
    /**
     * Indicates the storage size.
     */
    storeSize: number;
    /**
     * Indicates the message stored time.
     */
    storeTime: string;
}

export interface GetDmsRocketmqMessagesMessagePropertyList {
    /**
     * Indicates the property name.
     */
    name: string;
    /**
     * Indicates the property value.
     */
    value: string;
}

export interface GetDmsRocketmqMigrationTasksTask {
    /**
     * Indicates the ID of a metadata migration task.
     */
    id: string;
    /**
     * Indicates the name of a metadata migration task.
     */
    name: string;
    /**
     * Indicates the start time of a metadata migration task.
     */
    startDate: string;
    /**
     * Indicates the status of a metadata migration task.
     */
    status: string;
    /**
     * Indicates the metadata migration task type.
     */
    type: string;
}

export interface GetDmsRocketmqTopicAccessUsersPolicy {
    /**
     * Indicates the user name.
     */
    accessKey: string;
    /**
     * Indicates whether the user is an administrator.
     */
    admin: boolean;
    /**
     * Indicates the permissions.
     */
    perm: string;
    /**
     * Indicates the IP address whitelist.
     */
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqTopicsTopic {
    brokers: outputs.GetDmsRocketmqTopicsTopicBroker[];
    name: string;
    permission: string;
    totalReadQueueNum: number;
    totalWriteQueueNum: number;
}

export interface GetDmsRocketmqTopicsTopicBroker {
    brokerName: string;
    readQueueNum: number;
    writeQueueNum: number;
}

export interface GetDmsRocketmqUsersUser {
    accessKey: string;
    admin: boolean;
    defaultGroupPerm: string;
    defaultTopicPerm: string;
    groupPerms: outputs.GetDmsRocketmqUsersUserGroupPerm[];
    topicPerms: outputs.GetDmsRocketmqUsersUserTopicPerm[];
    whiteRemoteAddress: string;
}

export interface GetDmsRocketmqUsersUserGroupPerm {
    name: string;
    perm: string;
}

export interface GetDmsRocketmqUsersUserTopicPerm {
    name: string;
    perm: string;
}

export interface GetElbFlavorsFlavor {
    bandwidth: number;
    category: number;
    cps: number;
    flavorSoldOut: boolean;
    httpsCps: number;
    id: string;
    lcu: number;
    maxConnections: number;
    name: string;
    publicBorderGroup: string;
    qps: number;
    shared: boolean;
    type: string;
}

export interface GetElbPoolsPool {
    anyPortEnable: boolean;
    /**
     * Whether to enable delayed logout.
     */
    connectionDrainEnabled: boolean;
    /**
     * The timeout of the delayed logout in seconds.
     */
    connectionDrainTimeout: number;
    createdAt: string;
    /**
     * The description of pool.
     */
    description: string;
    enterpriseProjectId: string;
    /**
     * The health monitor ID of the ELB pool.
     */
    healthmonitorId: string;
    /**
     * The pool ID.
     */
    id: string;
    /**
     * The IP version of pool.
     */
    ipVersion: string;
    /**
     * The method of the ELB pool.
     */
    lbMethod: string;
    /**
     * Listener list. For details, see Data structure of the listener field.
     */
    listeners: outputs.GetElbPoolsPoolListener[];
    /**
     * Loadbalancer list. For details, see Data structure of the loadbalancer field.
     */
    loadbalancers: outputs.GetElbPoolsPoolLoadbalancer[];
    memberDeletionProtectionEnable: boolean;
    /**
     * Loadbalancer list. For details, see Data structure of the members field.
     */
    members: outputs.GetElbPoolsPoolMember[];
    /**
     * The timeout of the delayed logout in seconds.
     */
    minimumHealthyMemberCount: number;
    /**
     * The pool name.
     */
    name: string;
    /**
     * Whether connections in the same session will be processed by the same pool member or not.
     */
    persistences: outputs.GetElbPoolsPoolPersistence[];
    /**
     * The reason for update protection.
     */
    protectionReason: string;
    /**
     * The protection status for update.
     */
    protectionStatus: string;
    /**
     * The protocol of pool.
     */
    protocol: string;
    publicBorderGroup: string;
    quicCidHashStrategies: outputs.GetElbPoolsPoolQuicCidHashStrategy[];
    /**
     * The slow start duration, in seconds.
     */
    slowStartDuration: number;
    /**
     * Whether to enable slow start.
     */
    slowStartEnabled: boolean;
    /**
     * The type of the backend server group.
     */
    type: string;
    updatedAt: string;
    /**
     * The ID of the VPC where the backend server group works.
     */
    vpcId: string;
}

export interface GetElbPoolsPoolListener {
    /**
     * The listener ID.
     */
    id: string;
}

export interface GetElbPoolsPoolLoadbalancer {
    /**
     * The loadbalancer ID.
     */
    id: string;
}

export interface GetElbPoolsPoolMember {
    /**
     * The member ID.
     */
    id: string;
}

export interface GetElbPoolsPoolPersistence {
    /**
     * The name of the cookie if persistence mode is set appropriately.
     */
    cookieName: string;
    /**
     * The stickiness duration, in minutes.
     */
    timeout: number;
    /**
     * The type of persistence mode.
     */
    type: string;
}

export interface GetElbPoolsPoolQuicCidHashStrategy {
    len: number;
    offset: number;
}

export interface GetFgsApplicationTemplatesTemplate {
    /**
     * The template category.
     */
    category: string;
    /**
     * The description of template.
     */
    description: string;
    /**
     * The template ID.
     */
    id: string;
    /**
     * The template name.
     */
    name: string;
    /**
     * The template runtime.
     */
    runtime: string;
    /**
     * The type of the function application.
     */
    type: string;
}

export interface GetFgsApplicationsApplication {
    /**
     * The latest update time of the application, in RFC3339 format.
     */
    description: string;
    /**
     * The ID of application.
     */
    id: string;
    /**
     * The name of application.
     */
    name: string;
    /**
     * The status of application.
     */
    status: string;
    /**
     * The description of application.
     */
    updatedAt: string;
}

export interface GetFgsDependencyVersionsVersion {
    /**
     * The ID of the dependency package corresponding to the version.
     */
    dependencyId: string;
    /**
     * The name of the dependency package corresponding to the version.
     */
    dependencyName: string;
    /**
     * The description of the dependency package version.
     */
    description: string;
    /**
     * The unique ID of the dependency.
     */
    etag: string;
    /**
     * The ID of the dependency package version.
     */
    id: string;
    /**
     * The OBS bucket path where the dependency package version is located.
     */
    link: string;
    /**
     * The dependency owner, public indicates a public dependency.
     */
    owner: string;
    /**
     * The runtime of the dependency package version.
     */
    runtime: string;
    /**
     * The size of the ZIP file used by the dependency package version, in bytes.
     */
    size: number;
    /**
     * The dependency package version.
     */
    version: number;
}

export interface GetFgsFunctionEventsEvent {
    /**
     * The event ID.
     */
    id: string;
    /**
     * The event name.
     */
    name: string;
    /**
     * The latest update time of the function event, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetFgsFunctionTriggersTrigger {
    /**
     * The creation time of the function trigger, in RFC3339 format.
     */
    createdAt: string;
    /**
     * The detailed configuration of the function trigger.
     */
    eventData: string;
    /**
     * The ID of the function trigger.
     */
    id: string;
    /**
     * The current status of the function trigger.
     */
    status: string;
    /**
     * The type of the function trigger.
     */
    type: string;
    /**
     * The latest update time of the function trigger, in RFC3339 format.
     */
    updatedAt: string;
}

export interface GetFgsFunctionsFunction {
    /**
     * The IAM agency name for the function configuration.
     */
    agency: string;
    /**
     * The IAM agency name for the function execution.
     */
    appAgency: string;
    /**
     * The name of the function file.
     */
    codeFilename: string;
    /**
     * The function code type.
     */
    codeType: string;
    /**
     * The code URL.
     */
    codeUrl: string;
    /**
     * The description of the function.
     */
    description: string;
    /**
     * The custom user data (key/value pairs) defined to be encrypted for the function.
     */
    encryptedUserData: string;
    /**
     * The enterprise project ID to which the function belongs.
     */
    enterpriseProjectId: string;
    /**
     * The functionGraph version.
     */
    functiongraphVersion: string;
    /**
     * The entry point of the function.
     */
    handler: string;
    /**
     * The initializer of the function.
     */
    initializerHandler: string;
    /**
     * The maximum duration the function can be initialized.
     */
    initializerTimeout: number;
    /**
     * The LTS log group ID.
     */
    logGroupId: string;
    /**
     * The LTS log stream ID.
     */
    logStreamId: string;
    /**
     * The maximum number of instances for a single function.
     */
    maxInstanceNum: string;
    /**
     * The memory size(MB) allocated to the function.
     */
    memorySize: number;
    /**
     * The function name.
     */
    name: string;
    /**
     * The network ID of subnet to which the function belongs.
     */
    networkId: string;
    /**
     * The package name that function used.
     */
    package: string;
    /**
     * The dependency package runtime of the function.
     */
    runtime: string;
    /**
     * The timeout interval of the function.
     */
    timeout: number;
    /**
     * The function URN.
     */
    urn: string;
    /**
     * The custom user data (key/value pairs) defined for the function.
     */
    userData: string;
    /**
     * The function version.
     */
    version: string;
    /**
     * The VPC ID to which the function belongs.
     */
    vpcId: string;
}

export interface GetFgsQuotasQuota {
    /**
     * The number of available quota.
     */
    limit: number;
    /**
     * The resource type corresponding to quota.
     */
    type: string;
    /**
     * The unit of usage.
     */
    unit: string;
    /**
     * The number of quota used.
     */
    used: number;
}

export interface GetKpsFailedTasksTask {
    /**
     * The ID of the task.
     */
    id: string;
    /**
     * The name of the keypair associated with the task.
     */
    keypairName: string;
    /**
     * The operation type of the task.
     */
    operateType: string;
    /**
     * The ID of the instance associated with the task.
     */
    serverId: string;
    /**
     * The name of the instance associated with the task.
     */
    serverName: string;
    /**
     * The error code of the task execution failure.
     */
    taskErrorCode: string;
    /**
     * The error information of the task execution failure.
     */
    taskErrorMsg: string;
    /**
     * The start time of the task, in RFC3339 format.
     */
    taskTime: string;
}

export interface GetKpsRunningTasksTask {
    /**
     * The ID of the task.
     */
    id: string;
    /**
     * The name of the keypair associated with the task.
     */
    keypairName: string;
    /**
     * The operation type of the task.
     */
    operateType: string;
    /**
     * The ID of the instance associated with the task.
     */
    serverId: string;
    /**
     * The name of the instance associated with the task.
     */
    serverName: string;
    /**
     * The start time of the task, in RFC3339 format.
     */
    taskTime: string;
}

export interface GetSfsTurboDataTasksTask {
    /**
     * The destination path prefix of the data task.
     */
    destPrefix: string;
    /**
     * The target end information of the data task.
     */
    destTarget: string;
    /**
     * The end time of the data task, in RFC3339 format.
     */
    endTime: string;
    /**
     * The ID of the data task.
     */
    id: string;
    /**
     * The data task execution result information.
     */
    message: string;
    /**
     * The source path prefix of the data task.
     */
    srcPrefix: string;
    /**
     * The linkage directory name.
     */
    srcTarget: string;
    /**
     * The start time of the data task, in RFC3339 format.
     */
    startTime: string;
    /**
     * The status of the data task.
     */
    status: string;
    /**
     * The type of the data task.
     */
    type: string;
}

export interface GetSfsTurboDuTasksTask {
    /**
     * The start time of the DU task, in RFC3339 format.
     */
    beginTime: string;
    /**
     * The resource usages of a directory (including subdirectories).
     */
    dirUsages: outputs.GetSfsTurboDuTasksTaskDirUsage[];
    /**
     * The end time of the DU task, in RFC3339 format.
     */
    endTime: string;
    /**
     * The ID of the DU task.
     */
    id: string;
    /**
     * The status of the DU task.
     */
    status: string;
}

export interface GetSfsTurboDuTasksTaskDirUsage {
    /**
     * The total number of files in the directory.
     */
    fileCounts: outputs.GetSfsTurboDuTasksTaskDirUsageFileCount[];
    /**
     * The error message.
     */
    message: string;
    /**
     * The full path to a legal directory in the file system.
     */
    path: string;
    /**
     * The used capacity, in byte.
     */
    usedCapacity: number;
}

export interface GetSfsTurboDuTasksTaskDirUsageFileCount {
    /**
     * The number of block devices.
     */
    block: number;
    /**
     * The number of character devices.
     */
    char: number;
    /**
     * The number of directories.
     */
    dir: number;
    /**
     * The number of pipe files.
     */
    pipe: number;
    /**
     * The number of common files.
     */
    regular: number;
    /**
     * The number of sockets.
     */
    socket: number;
    /**
     * The number of symbolic links.
     */
    symlink: number;
}

export interface GetSfsTurboObsTargetsTarget {
    /**
     * The creation time of the OBS target.
     */
    createdAt: string;
    /**
     * The linkage directory name of the OBS target.
     */
    fileSystemPath: string;
    /**
     * The ID of the OBS target.
     */
    id: string;
    /**
     * The detail of the OBS bucket.
     */
    obs: outputs.GetSfsTurboObsTargetsTargetOb[];
    /**
     * The status of the OBS target.
     */
    status: string;
}

export interface GetSfsTurboObsTargetsTargetOb {
    /**
     * The name of the OBS bucket associated with the OBS target.
     */
    bucket: string;
    /**
     * The domain name of the region where the OBS bucket belongs.
     */
    endpoint: string;
}

export interface GetSfsTurboPermRulesRule {
    /**
     * The ID of the permission rule.
     */
    id: string;
    /**
     * The IP address or IP address range of the authorized object.
     */
    ipCidr: string;
    /**
     * The read and write permission of the authorized object.
     */
    rwType: string;
    /**
     * The file system access permission granted to the user of the authorized object.
     */
    userType: string;
}

export interface GetVpnConnectionHealthChecksConnectionHealthCheck {
    connectionId: string;
    destinationIp: string;
    id: string;
    protoType: string;
    sourceIp: string;
    status: string;
    type: string;
}

export interface GetVpnConnectionsConnection {
    connectionMonitorId: string;
    createdAt: string;
    customerGatewayId: string;
    enableNqa: boolean;
    enterpriseProjectId: string;
    gatewayId: string;
    gatewayIp: string;
    haRole: string;
    id: string;
    ikepolicies: outputs.GetVpnConnectionsConnectionIkepolicy[];
    ipsecpolicies: outputs.GetVpnConnectionsConnectionIpsecpolicy[];
    name: string;
    peerSubnets: string[];
    policyRules: outputs.GetVpnConnectionsConnectionPolicyRule[];
    status: string;
    tunnelLocalAddress: string;
    tunnelPeerAddress: string;
    updatedAt: string;
    vpnType: string;
}

export interface GetVpnConnectionsConnectionIkepolicy {
    authenticationAlgorithm: string;
    authenticationMethod: string;
    dhGroup: string;
    dpds: outputs.GetVpnConnectionsConnectionIkepolicyDpd[];
    encryptionAlgorithm: string;
    ikeVersion: string;
    lifetimeSeconds: number;
    localId: string;
    localIdType: string;
    peerId: string;
    peerIdType: string;
    phase1NegotiationMode: string;
}

export interface GetVpnConnectionsConnectionIkepolicyDpd {
    interval: number;
    msg: string;
    timeout: number;
}

export interface GetVpnConnectionsConnectionIpsecpolicy {
    authenticationAlgorithm: string;
    encapsulationMode: string;
    encryptionAlgorithm: string;
    lifetimeSeconds: number;
    pfs: string;
    transformProtocol: string;
}

export interface GetVpnConnectionsConnectionPolicyRule {
    destinations: string[];
    ruleIndex: number;
    source: string;
}

export interface GetVpnCustomerGatewaysCustomerGateway {
    asn: number;
    caCertificates: outputs.GetVpnCustomerGatewaysCustomerGatewayCaCertificate[];
    createdAt: string;
    id: string;
    idType: string;
    idValue: string;
    ip: string;
    name: string;
    routeMode: string;
    updatedAt: string;
}

export interface GetVpnCustomerGatewaysCustomerGatewayCaCertificate {
    expireTime: string;
    isUpdatable: boolean;
    issuer: string;
    serialNumber: string;
    signatureAlgorithm: string;
    subject: string;
}

export interface GetVpnGatewaysGateway {
    /**
     * The list of private access IPs.
     */
    accessPrivateIps: string[];
    /**
     * The ID of the access subnet.
     */
    accessSubnetId: string;
    /**
     * The ID of the access VPC.
     */
    accessVpcId: string;
    /**
     * The attachment type.
     */
    attachmentType: string;
    /**
     * The availability zone IDs.
     */
    availabilityZones: string[];
    /**
     * The ASN number of BGP
     */
    bgpAsn: number;
    /**
     * The VPC network segment used by the VPN gateway
     */
    connectSubnet: string;
    /**
     * The max number of connections.
     */
    connectionNumber: number;
    /**
     * The create time.
     */
    createdAt: string;
    eips: outputs.GetVpnGatewaysGatewayEip[];
    /**
     * The enterprise project ID
     */
    enterpriseProjectId: string;
    /**
     * The ER attachment ID.
     */
    erAttachmentId: string;
    /**
     * The ID of the ER to which the VPN gateway is connected.
     */
    erId: string;
    /**
     * The flavor of the VPN gateway.
     */
    flavor: string;
    /**
     * The HA mode.
     */
    haMode: string;
    /**
     * The ID of the gateway
     */
    id: string;
    /**
     * The local subnets.
     */
    localSubnets: string[];
    /**
     * The name of the gateway.
     */
    name: string;
    /**
     * The network type of the gateway.
     */
    networkType: string;
    /**
     * The status of the gateway.
     */
    status: string;
    /**
     * The update time.
     */
    updatedAt: string;
    /**
     * The number of used connection groups.
     */
    usedConnectionGroup: number;
    /**
     * The number of used connections.
     */
    usedConnectionNumber: number;
    /**
     * The ID of the VPC to which the VPN gateway is connected.
     */
    vpcId: string;
}

export interface GetVpnGatewaysGatewayEip {
    /**
     * The bandwidth billing info.
     */
    bandwidthBillingInfo: string;
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s.
     */
    bandwidthSize: number;
    /**
     * The billing info.
     */
    billingInfo: string;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export interface ObsBucketAclAccountPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
    /**
     * Specifies the account id to authorize. The account id cannot be the bucket owner, 
     * and must be unique.
     */
    accountId: string;
}

export interface ObsBucketAclLogDeliveryUserPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface ObsBucketAclOwnerPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface ObsBucketAclPublicPermission {
    /**
     * Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
     */
    accessToAcls?: string[];
    /**
     * Specifies the access to bucket. Valid values are **READ** and **WRITE**.
     */
    accessToBuckets?: string[];
}

export interface SfsTurboDuTaskDirUsage {
    fileCounts: outputs.SfsTurboDuTaskDirUsageFileCount[];
    message: string;
    path: string;
    usedCapacity: number;
}

export interface SfsTurboDuTaskDirUsageFileCount {
    block: number;
    char: number;
    dir: number;
    pipe: number;
    regular: number;
    socket: number;
    symlink: number;
}

export interface SfsTurboObsTargetObs {
    attributes?: outputs.SfsTurboObsTargetObsAttributes;
    bucket: string;
    endpoint: string;
    policy?: outputs.SfsTurboObsTargetObsPolicy;
}

export interface SfsTurboObsTargetObsAttributes {
    dirMode: string;
    fileMode: string;
    gid: number;
    uid: number;
}

export interface SfsTurboObsTargetObsPolicy {
    autoExportPolicy?: outputs.SfsTurboObsTargetObsPolicyAutoExportPolicy;
}

export interface SfsTurboObsTargetObsPolicyAutoExportPolicy {
    events: string[];
    prefix: string;
    suffix: string;
}

export interface SmnSubscriptionExtension {
    clientId?: string;
    clientSecret?: string;
    header?: {[key: string]: string};
    keyword?: string;
    signSecret?: string;
}

export interface SmnSubscriptionFilterPolicy {
    /**
     * The filter policy name. The policy name must be unique.
     */
    name: string;
    /**
     * The string array for exact match.
     */
    stringEquals: string[];
}

export interface SwrOrganizationPermissionsSelfPermission {
    permission: string;
    userId: string;
    userName: string;
}

export interface SwrOrganizationPermissionsUser {
    permission: string;
    userId: string;
    userName: string;
}

export interface VpnConnectionIkepolicy {
    /**
     * The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
     */
    authenticationAlgorithm: string;
    /**
     * The authentication method during IKE negotiation.
     */
    authenticationMethod: string;
    /**
     * Specifies the DH group used for key exchange in phase 1.
     */
    dhGroup: string;
    /**
     * Specifies the dead peer detection (DPD) object.
     */
    dpd: outputs.VpnConnectionIkepolicyDpd;
    /**
     * The encryption algorithm, 3DES is less secure, please use them with caution.
     */
    encryptionAlgorithm: string;
    /**
     * The IKE negotiation version.
     */
    ikeVersion: string;
    /**
     * The life cycle of SA in seconds, when the life cycle expires, IKE SA will be automatically updated.
     */
    lifetimeSeconds: number;
    /**
     * The local ID.
     */
    localId: string;
    /**
     * The local ID type.
     */
    localIdType: string;
    /**
     * The peer ID.
     */
    peerId: string;
    /**
     * The peer ID type.
     */
    peerIdType: string;
    /**
     * The DH key group used by PFS.
     */
    pfs: string;
    /**
     * The negotiation mode, only works when the ikeVersion is v1.
     */
    phase1NegotiationMode: string;
}

export interface VpnConnectionIkepolicyDpd {
    /**
     * Specifies the DPD idle timeout period.
     */
    interval: number;
    /**
     * Specifies the format of DPD packets.
     */
    msg: string;
    /**
     * Specifies the interval for retransmitting DPD packets.
     */
    timeout: number;
}

export interface VpnConnectionIpsecpolicy {
    /**
     * The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
     */
    authenticationAlgorithm: string;
    /**
     * The encapsulation mode, only **tunnel** supported for now.
     */
    encapsulationMode: string;
    /**
     * The encryption algorithm, 3DES is less secure, please use them with caution.
     */
    encryptionAlgorithm: string;
    /**
     * The lifecycle time of Ipsec tunnel in seconds.
     */
    lifetimeSeconds: number;
    /**
     * The DH key group used by PFS.
     */
    pfs: string;
    /**
     * The transform protocol. Only **esp** supported for now.
     */
    transformProtocol: string;
}

export interface VpnConnectionPolicyRule {
    /**
     * The list of destination CIDRs.
     */
    destinations: string[];
    /**
     * The rule index.
     */
    ruleIndex: number;
    /**
     * The source CIDR.
     */
    source: string;
}

export interface VpnGatewayCertificate {
    certificateChain: string;
    certificateChainExpireTime: string;
    certificateChainSerialNumber: string;
    certificateChainSubject: string;
    certificateExpireTime: string;
    certificateId: string;
    certificateSerialNumber: string;
    certificateSubject: string;
    content: string;
    createdAt: string;
    encCertificate: string;
    encCertificateExpireTime: string;
    encCertificateSerialNumber: string;
    encCertificateSubject: string;
    encPrivateKey: string;
    issuer: string;
    name: string;
    privateKey: string;
    signatureAlgorithm: string;
    status: string;
    updatedAt: string;
}

export interface VpnGatewayEip1 {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export interface VpnGatewayEip2 {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export interface VpnGatewayMasterEip {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export interface VpnGatewaySlaveEip {
    /**
     * The bandwidth ID.
     */
    bandwidthId: string;
    /**
     * The bandwidth name.
     */
    bandwidthName: string;
    /**
     * Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
     */
    bandwidthSize: number;
    /**
     * The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
     */
    chargeMode: string;
    /**
     * The public IP ID.
     */
    id: string;
    /**
     * The public IP address.
     */
    ipAddress: string;
    /**
     * The public IP version.
     */
    ipVersion: number;
    /**
     * The EIP type. The value can be **5_bgp** and **5_sbgp**.
     */
    type: string;
}

export namespace Aom {
    export interface ServiceDiscoveryRuleDiscoveryRule {
        checkContents: string[];
        checkMode: string;
        checkType: string;
    }

    export interface ServiceDiscoveryRuleLogPathRule {
        args: string[];
        nameType: string;
        values: string[];
    }

    export interface ServiceDiscoveryRuleNameRules {
        applicationNameRules: outputs.Aom.ServiceDiscoveryRuleNameRulesApplicationNameRule[];
        serviceNameRules: outputs.Aom.ServiceDiscoveryRuleNameRulesServiceNameRule[];
    }

    export interface ServiceDiscoveryRuleNameRulesApplicationNameRule {
        args: string[];
        nameType: string;
        values?: string[];
    }

    export interface ServiceDiscoveryRuleNameRulesServiceNameRule {
        args: string[];
        nameType: string;
        values?: string[];
    }

}

export namespace As {
    export interface BandwidthPolicyIntervalAlarmAction {
        /**
         * Specifies the operation restrictions.
         */
        limits: number;
        /**
         * Specifies the lower limit of the value range.
         */
        lowerBound: string;
        /**
         * Specifies the operation to be performed.
         */
        operation: string;
        /**
         * Specifies the operation size.
         */
        size: number;
        /**
         * Specifies the upper limit of the value range.
         */
        upperBound: string;
    }

    export interface BandwidthPolicyMetaData {
        /**
         * The bandwidth sharing type in the bandwidth policy.
         */
        metadataBandwidthShareType: string;
        /**
         * The EIP IP address for the bandwidth in the bandwidth policy.
         */
        metadataEipAddress: string;
        /**
         * The EIP ID for the bandwidth in the bandwidth policy.
         */
        metadataEipId: string;
    }

    export interface BandwidthPolicyScalingPolicyAction {
        /**
         * Specifies the operation restrictions.
         */
        limits: number;
        /**
         * Specifies the operation to be performed. The default operation is ADD.
         */
        operation: string;
        /**
         * Specifies the bandwidth (Mbit/s).
         */
        size: number;
    }

    export interface BandwidthPolicyScheduledPolicy {
        /**
         * Specifies the end time of the scaling action triggered periodically.
         */
        endTime: string;
        /**
         * Specifies the time when the scaling action is triggered. The time format complies with UTC.
         */
        launchTime: string;
        /**
         * Specifies the periodic triggering type.
         */
        recurrenceType: string;
        /**
         * Specifies the day when a periodic scaling action is triggered.
         */
        recurrenceValue: string;
        /**
         * Specifies the start time of the scaling action triggered periodically.
         */
        startTime: string;
    }

    export interface ConfigurationInstanceConfig {
        adminPass?: string;
        chargingMode?: string;
        dedicatedHostId: string;
        disks: outputs.As.ConfigurationInstanceConfigDisk[];
        ecsGroupId: string;
        flavor: string;
        flavorPriorityPolicy: string;
        image: string;
        instanceId: string;
        keyFingerprint: string;
        keyName: string;
        metadata?: {[key: string]: string};
        personalities: outputs.As.ConfigurationInstanceConfigPersonality[];
        publicIp: outputs.As.ConfigurationInstanceConfigPublicIp;
        /**
         * schema: Required
         */
        securityGroupIds: string[];
        tenancy: string;
        userData?: string;
    }

    export interface ConfigurationInstanceConfigDisk {
        dataDiskImageId: string;
        dedicatedStorageId: string;
        diskType: string;
        iops: number;
        kmsId: string;
        size: number;
        snapshotId: string;
        throughput: number;
        volumeType: string;
    }

    export interface ConfigurationInstanceConfigPersonality {
        content: string;
        path: string;
    }

    export interface ConfigurationInstanceConfigPublicIp {
        eip: outputs.As.ConfigurationInstanceConfigPublicIpEip;
    }

    export interface ConfigurationInstanceConfigPublicIpEip {
        bandwidth: outputs.As.ConfigurationInstanceConfigPublicIpEipBandwidth;
        ipType: string;
    }

    export interface ConfigurationInstanceConfigPublicIpEipBandwidth {
        chargingMode: string;
        id: string;
        shareType: string;
        size: number;
    }

    export interface GroupLbaasListener {
        listenerId: string;
        poolId: string;
        protocolPort: number;
        protocolVersion: string;
        weight?: number;
    }

    export interface GroupNetwork {
        id: string;
        ipv6BandwidthId?: string;
        ipv6Enable?: boolean;
        sourceDestCheck?: boolean;
    }

    export interface GroupSecurityGroup {
        id: string;
    }

    export interface PolicyScalingPolicyAction {
        instanceNumber: number;
        instancePercentage?: number;
        operation: string;
    }

    export interface PolicyScheduledPolicy {
        endTime: string;
        launchTime: string;
        recurrenceType: string;
        recurrenceValue: string;
        startTime: string;
    }

}

export namespace Cbr {
    export interface GetVaultsVault {
        /**
         * The allocated capacity of the vault, in GB.
         */
        allocated: number;
        /**
         * Whether automatic association is supported.
         */
        autoBind: boolean;
        /**
         * Whether to enable automatic expansion of the backup protection type vault.
         */
        autoExpandEnabled: boolean;
        /**
         * The rules for automatic association.
         */
        bindRules: {[key: string]: string};
        /**
         * The consistent level (specification) of the vault.
         */
        consistentLevel: string;
        /**
         * The enterprise project ID.
         */
        enterpriseProjectId: string;
        /**
         * The vault ID in UUID format.
         */
        id: string;
        /**
         * The vault name.
         */
        name: string;
        /**
         * The ID of the policy associated with the vault.
         */
        policyId: string;
        /**
         * The protection type of the vault.
         */
        protectionType: string;
        /**
         * The array of one or more resources to attach to the vault.
         */
        resources: outputs.Cbr.GetVaultsVaultResource[];
        /**
         * The vault capacity, in GB.
         */
        size: number;
        /**
         * The specification code.
         */
        specCode: string;
        /**
         * The vault status.
         */
        status: string;
        /**
         * The name of the bucket for the vault.
         */
        storage: string;
        /**
         * The key/value pairs to associate with the vault.
         */
        tags: {[key: string]: string};
        /**
         * The object type of the vault.
         */
        type: string;
        /**
         * The used capacity, in GB.
         */
        used: number;
    }

    export interface GetVaultsVaultResource {
        /**
         * The array of disk IDs which will be excluded in the backup.
         */
        excludes: string[];
        /**
         * The array of disk or SFS file system IDs which will be included in the backup.
         */
        includes: string[];
        /**
         * The ID of the ECS instance to be backed up.
         */
        serverId: string;
    }

    export interface PolicyBackupCycle {
        /**
         * The weekly backup time.
         */
        days?: string;
        /**
         * The execution time of the policy.
         */
        executionTimes: string[];
        /**
         * The number of days between each backup.
         */
        interval?: number;
    }

    export interface PolicyLongTermRetention {
        /**
         * The latest backup of each day is saved in the long term.
         */
        daily?: number;
        /**
         * How often (after how many incremental backups) a full backup is performed.
         */
        fullBackupInterval?: number;
        /**
         * The latest backup of each month is saved in the long term.
         */
        monthly?: number;
        /**
         * The latest backup of each week is saved in the long term.
         */
        weekly?: number;
        /**
         * The latest backup of each year is saved in the long term.
         */
        yearly?: number;
    }

    export interface VaultPolicy {
        /**
         * The ID of destination vault to which the replication policy will associated.
         */
        destinationVaultId?: string;
        /**
         * The policy ID.
         */
        id: string;
    }

    export interface VaultResource {
        /**
         * The array of disk IDs which will be excluded in the backup.
         */
        excludes: string[];
        /**
         * The array of disk or SFS file systems which will be included in the backup.
         */
        includes: string[];
        /**
         * The ID of the ECS instance to be backed up.
         */
        serverId?: string;
    }

}

export namespace Cce {
    export interface AddonValues {
        basic?: {[key: string]: string};
        basicJson?: string;
        custom?: {[key: string]: string};
        customJson?: string;
        flavor?: {[key: string]: string};
        flavorJson?: string;
    }

    export interface ClusterCertificateCluster {
        certificateAuthorityData: string;
        name: string;
        server: string;
    }

    export interface ClusterCertificateUser {
        clientCertificateData: string;
        clientKeyData: string;
        name: string;
    }

    export interface ClusterComponentConfiguration {
        configurations?: string;
        name: string;
    }

    export interface ClusterEncryptionConfig {
        kmsKeyId: string;
        mode: string;
    }

    export interface ClusterExtendParam {
        clusterAz?: string;
        cpuManagerPolicy?: string;
        decMasterFlavor?: string;
        dockerUmaskMode?: string;
        dssMasterVolumes?: string;
        fixPoolMask?: string;
    }

    export interface ClusterMaster {
        availabilityZone: string;
    }

    export interface GetAddonTemplateSupportVersion {
        bareMetals: string[];
        virtualMachines: string[];
    }

    export interface GetClusterCertificateCluster {
        certificateAuthorityData: string;
        name: string;
        server: string;
    }

    export interface GetClusterCertificateUser {
        clientCertificateData: string;
        clientKeyData: string;
        name: string;
    }

    export interface GetClusterCertificatesCluster {
        certificateAuthorityData: string;
        insecureSkipTlsVerify: boolean;
        name: string;
        server: string;
    }

    export interface GetClusterCertificatesContext {
        cluster: string;
        name: string;
        user: string;
    }

    export interface GetClusterCertificatesUser {
        clientCertificateData: string;
        clientKeyData: string;
        name: string;
    }

    export interface GetClusterEndpoint {
        type: string;
        url: string;
    }

    export interface GetClusterMaster {
        availabilityZone: string;
    }

    export interface GetClustersCluster {
        authenticationMode: string;
        billingMode: number;
        certificateClusters: outputs.Cce.GetClustersClusterCertificateCluster[];
        certificateUsers: outputs.Cce.GetClustersClusterCertificateUser[];
        clusterType: string;
        clusterVersion: string;
        containerNetworkCidr: string;
        containerNetworkType: string;
        description: string;
        endpoints: outputs.Cce.GetClustersClusterEndpoint[];
        eniSubnetCidr: string;
        eniSubnetId: string;
        enterpriseProjectId: string;
        flavorId: string;
        id: string;
        kubeConfigRaw: string;
        masters: outputs.Cce.GetClustersClusterMaster[];
        name: string;
        securityGroupId: string;
        serviceNetworkCidr: string;
        status: string;
        subnetId: string;
        vpcId: string;
    }

    export interface GetClustersClusterCertificateCluster {
        certificateAuthorityData: string;
        name: string;
        server: string;
    }

    export interface GetClustersClusterCertificateUser {
        clientCertificateData: string;
        clientKeyData: string;
        name: string;
    }

    export interface GetClustersClusterEndpoint {
        type: string;
        url: string;
    }

    export interface GetClustersClusterMaster {
        availabilityZone: string;
    }

    export interface GetNodeDataVolume {
        extendParams: {[key: string]: string};
        size: number;
        volumetype: string;
    }

    export interface GetNodeHostnameConfig {
        type: string;
    }

    export interface GetNodePoolDataVolume {
        extendParams: {[key: string]: string};
        size: number;
        volumetype: string;
    }

    export interface GetNodePoolHostnameConfig {
        type: string;
    }

    export interface GetNodePoolRootVolume {
        extendParams: {[key: string]: string};
        size: number;
        volumetype: string;
    }

    export interface GetNodeRootVolume {
        extendParams: {[key: string]: string};
        size: number;
        volumetype: string;
    }

    export interface GetNodesNode {
        availabilityZone: string;
        billingMode: number;
        dataVolumes: outputs.Cce.GetNodesNodeDataVolume[];
        ecsGroupId: string;
        enterpriseProjectId: string;
        flavorId: string;
        hostnameConfigs: outputs.Cce.GetNodesNodeHostnameConfig[];
        id: string;
        keyPair: string;
        name: string;
        os: string;
        privateIp: string;
        publicIp: string;
        rootVolumes: outputs.Cce.GetNodesNodeRootVolume[];
        serverId: string;
        status: string;
        subnetId: string;
        tags: {[key: string]: string};
    }

    export interface GetNodesNodeDataVolume {
        extendParams: {[key: string]: string};
        size: number;
        volumetype: string;
    }

    export interface GetNodesNodeHostnameConfig {
        type: string;
    }

    export interface GetNodesNodeRootVolume {
        extendParams: {[key: string]: string};
        size: number;
        volumetype: string;
    }

    export interface NodeAttachDataVolume {
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam: string;
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        kmsKeyId: string;
        size: number;
        throughput: number;
        volumetype: string;
    }

    export interface NodeAttachExtensionNic {
        subnetId: string;
    }

    export interface NodeAttachHostnameConfig {
        type: string;
    }

    export interface NodeAttachRootVolume {
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam: string;
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        kmsKeyId: string;
        size: number;
        throughput: number;
        volumetype: string;
    }

    export interface NodeAttachStorage {
        groups: outputs.Cce.NodeAttachStorageGroup[];
        selectors: outputs.Cce.NodeAttachStorageSelector[];
    }

    export interface NodeAttachStorageGroup {
        cceManaged?: boolean;
        name: string;
        selectorNames: string[];
        virtualSpaces: outputs.Cce.NodeAttachStorageGroupVirtualSpace[];
    }

    export interface NodeAttachStorageGroupVirtualSpace {
        lvmLvType?: string;
        lvmPath?: string;
        name: string;
        runtimeLvType?: string;
        size: string;
    }

    export interface NodeAttachStorageSelector {
        matchLabelCount?: string;
        matchLabelMetadataCmkid?: string;
        matchLabelMetadataEncrypted?: string;
        matchLabelSize?: string;
        matchLabelVolumeType?: string;
        name: string;
        type?: string;
    }

    export interface NodeAttachTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface NodeDataVolume {
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam?: string;
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        kmsKeyId: string;
        size: number;
        throughput: number;
        volumetype: string;
    }

    export interface NodeExtendParams {
        agencyName?: string;
        dockerBaseSize?: number;
        kubeReservedMem?: number;
        marketType?: string;
        maxPods?: number;
        nicThreshold?: string;
        nodeImageId?: string;
        nodeMultiQueue?: string;
        postinstall?: string;
        preinstall?: string;
        securityReinforcementType?: string;
        spotPrice?: string;
        systemReservedMem?: number;
    }

    export interface NodeExtensionNic {
        subnetId: string;
    }

    export interface NodeHostnameConfig {
        type: string;
    }

    export interface NodePoolDataVolume {
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam?: string;
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        kmsKeyId: string;
        size: number;
        throughput: number;
        volumetype: string;
    }

    export interface NodePoolExtendParams {
        agencyName: string;
        dockerBaseSize: number;
        kubeReservedMem: number;
        marketType: string;
        maxPods: number;
        nicThreshold: string;
        nodeImageId: string;
        nodeMultiQueue: string;
        postinstall: string;
        preinstall: string;
        securityReinforcementType: string;
        spotPrice: string;
        systemReservedMem: number;
    }

    export interface NodePoolExtensionScaleGroup {
        metadata?: outputs.Cce.NodePoolExtensionScaleGroupMetadata;
        spec?: outputs.Cce.NodePoolExtensionScaleGroupSpec;
    }

    export interface NodePoolExtensionScaleGroupMetadata {
        name?: string;
    }

    export interface NodePoolExtensionScaleGroupSpec {
        autoscaling?: outputs.Cce.NodePoolExtensionScaleGroupSpecAutoscaling;
        az?: string;
        capacityReservationSpecification?: outputs.Cce.NodePoolExtensionScaleGroupSpecCapacityReservationSpecification;
        flavor?: string;
    }

    export interface NodePoolExtensionScaleGroupSpecAutoscaling {
        enable?: boolean;
        extensionPriority?: number;
        maxNodeCount?: number;
        minNodeCount?: number;
    }

    export interface NodePoolExtensionScaleGroupSpecCapacityReservationSpecification {
        id?: string;
        preference?: string;
    }

    export interface NodePoolHostnameConfig {
        type: string;
    }

    export interface NodePoolRootVolume {
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam?: string;
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        kmsKeyId: string;
        size: number;
        throughput: number;
        volumetype: string;
    }

    export interface NodePoolStorage {
        groups: outputs.Cce.NodePoolStorageGroup[];
        selectors: outputs.Cce.NodePoolStorageSelector[];
    }

    export interface NodePoolStorageGroup {
        cceManaged?: boolean;
        name: string;
        selectorNames: string[];
        virtualSpaces: outputs.Cce.NodePoolStorageGroupVirtualSpace[];
    }

    export interface NodePoolStorageGroupVirtualSpace {
        lvmLvType?: string;
        lvmPath?: string;
        name: string;
        runtimeLvType?: string;
        size: string;
    }

    export interface NodePoolStorageSelector {
        matchLabelCount?: string;
        matchLabelMetadataCmkid?: string;
        matchLabelMetadataEncrypted?: string;
        matchLabelSize?: string;
        matchLabelVolumeType?: string;
        name: string;
        type?: string;
    }

    export interface NodePoolTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface NodeRootVolume {
        dssPoolId: string;
        /**
         * @deprecated use extendParams instead
         */
        extendParam?: string;
        extendParams: {[key: string]: string};
        /**
         * schema: Internal
         */
        hwPassthrough: boolean;
        iops: number;
        kmsKeyId: string;
        size: number;
        throughput: number;
        volumetype: string;
    }

    export interface NodeStorage {
        groups: outputs.Cce.NodeStorageGroup[];
        selectors: outputs.Cce.NodeStorageSelector[];
    }

    export interface NodeStorageGroup {
        cceManaged?: boolean;
        name: string;
        selectorNames: string[];
        virtualSpaces: outputs.Cce.NodeStorageGroupVirtualSpace[];
    }

    export interface NodeStorageGroupVirtualSpace {
        lvmLvType?: string;
        lvmPath?: string;
        name: string;
        runtimeLvType?: string;
        size: string;
    }

    export interface NodeStorageSelector {
        matchLabelCount?: string;
        matchLabelMetadataCmkid?: string;
        matchLabelMetadataEncrypted?: string;
        matchLabelSize?: string;
        matchLabelVolumeType?: string;
        name: string;
        type?: string;
    }

    export interface NodeTaint {
        effect: string;
        key: string;
        value?: string;
    }

}

export namespace Cdm {
    export interface ClusterInstance {
        id: string;
        manageIp: string;
        name: string;
        privateIp: string;
        publicIp: string;
        role: string;
        trafficIp: string;
        type: string;
    }

}

export namespace Ces {
    export interface AlarmruleAlarmAction {
        notificationLists: string[];
        type: string;
    }

    export interface AlarmruleCondition {
        comparisonOperator: string;
        count: number;
        filter: string;
        period: number;
        suppressDuration?: number;
        unit?: string;
        value: number;
    }

    export interface AlarmruleInsufficientdataAction {
        notificationLists: string[];
        type: string;
    }

    export interface AlarmruleMetric {
        dimensions?: outputs.Ces.AlarmruleMetricDimension[];
        metricName: string;
        namespace: string;
    }

    export interface AlarmruleMetricDimension {
        name: string;
        value: string;
    }

    export interface AlarmruleOkAction {
        notificationLists: string[];
        type: string;
    }

}

export namespace Cfw {
    export interface AclRuleCustomService {
        /**
         * The destination port.
         */
        destPort: string;
        /**
         * The protocol type.
         */
        protocol: number;
        /**
         * The source port.
         */
        sourcePort: string;
    }

    export interface AclRuleCustomServiceGroups {
        /**
         * The IDs of the service groups.
         */
        groupIds: string[];
        /**
         * The protocols used in the service groups.
         */
        protocols: number[];
    }

    export interface AclRuleDestinationRegionList {
        /**
         * The Chinese description of the region.
         */
        descriptionCn?: string;
        /**
         * The English description of the region.
         */
        descriptionEn?: string;
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The region type.
         */
        regionType: number;
    }

    export interface AclRulePredefinedServiceGroups {
        /**
         * The IDs of the service groups.
         */
        groupIds: string[];
        /**
         * The protocols used in the service groups.
         */
        protocols: number[];
    }

    export interface AclRuleSequence {
        /**
         * Whether to pin on bottom.
         */
        bottom?: number;
        /**
         * The ID of the rule that the added rule will follow.
         */
        destRuleId: string;
        /**
         * Whether to pin on top.
         */
        top?: number;
    }

    export interface AclRuleSourceRegionList {
        /**
         * The Chinese description of the region.
         */
        descriptionCn?: string;
        /**
         * The English description of the region.
         */
        descriptionEn?: string;
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The region type.
         */
        regionType: number;
    }

    export interface AntiVirusScanProtocolConfig {
        /**
         * The antivirus action.
         */
        action: number;
        /**
         * The protocol type.
         */
        protocolType: number;
    }

    export interface CaptureTaskDestination {
        /**
         * The address.
         */
        address: string;
        /**
         * The address type.
         */
        addressType: number;
    }

    export interface CaptureTaskService {
        /**
         * The destination port.
         */
        destPort?: string;
        /**
         * The protocol type.
         */
        protocol: number;
        /**
         * The source port.
         */
        sourcePort?: string;
    }

    export interface CaptureTaskSource {
        /**
         * The address.
         */
        address: string;
        /**
         * The address type.
         */
        addressType: number;
    }

    export interface DomainNameGroupDomainName {
        /**
         * Specifies the description.
         */
        description: string;
        /**
         * The DNS IP list.
         */
        dnsIps: string;
        /**
         * The domain address ID.
         */
        domainAddressId: string;
        /**
         * Specifies the domain name.
         */
        domainName: string;
    }

    export interface EipProtectionProtectedEip {
        /**
         * The ID of the protected EIP.
         */
        id: string;
        /**
         * The IPv4 address of the protected EIP.
         */
        publicIpv4: string;
        /**
         * The IPv6 address of the protected EIP.
         */
        publicIpv6: string;
    }

    export interface FirewallFlavor {
        /**
         * Specifies the bandwidth of the firewall.
         */
        bandwidth: number;
        /**
         * Specifies the default bandwidth of the firewall.
         */
        defaultBandwidth: number;
        /**
         * Specifies the default EIP number of the firewall.
         */
        defaultEipCount: number;
        /**
         * Specifies the default log storage of the firewall.
         */
        defaultLogStorage: number;
        /**
         * Specifies the default VPC number of the firewall.
         */
        defaultVpcCount: number;
        /**
         * Specifies the EIP number of the firewall.
         */
        eipCount: number;
        /**
         * Specifies the extend bandwidth of the firewall.
         */
        extendBandwidth?: number;
        /**
         * Specifies the extend EIP number of the firewall.
         */
        extendEipCount?: number;
        /**
         * Specifies the extend VPC number of the firewall.
         */
        extendVpcCount?: number;
        /**
         * Specifies the log storage of the firewall.
         */
        logStorage: number;
        /**
         * Specifies the total rule count of the firewall.
         */
        totalRuleCount: number;
        /**
         * Specifies the used rule count of the firewall.
         */
        usedRuleCount: number;
        /**
         * Specifies the version of the firewall.
         */
        version: string;
        /**
         * Specifies the VPC bandwidth of the firewall.
         */
        vpcBandwidth: number;
        /**
         * Specifies the VPC number of the firewall.
         */
        vpcCount: number;
    }

    export interface FirewallProtectObject {
        /**
         * Protected object ID
         */
        objectId: string;
        /**
         * Protected object name
         */
        objectName: string;
        /**
         * Project type. The options are as follows: 0: north-south; 1: east-west.
         */
        type: number;
    }

    export interface GetAccessControlLogsRecord {
        /**
         * The action.
         */
        action: string;
        /**
         * The application protocol.
         */
        app: string;
        /**
         * The distination city ID.
         */
        dstCityId: string;
        /**
         * The distination city name.
         */
        dstCityName: string;
        /**
         * The destination host.
         */
        dstHost: string;
        /**
         * The destination IP address.
         */
        dstIp: string;
        /**
         * The destination port.
         */
        dstPort: number;
        /**
         * The distination province ID.
         */
        dstProvinceId: string;
        /**
         * The distination province name.
         */
        dstProvinceName: string;
        /**
         * The destination region ID.
         */
        dstRegionId: string;
        /**
         * The destination region name.
         */
        dstRegionName: string;
        /**
         * The hit time.
         */
        hitTime: string;
        /**
         * The document ID.
         */
        logId: string;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The rule ID.
         */
        ruleId: string;
        /**
         * The rule name.
         */
        ruleName: string;
        /**
         * The source city ID.
         */
        srcCityId: string;
        /**
         * The source city name.
         */
        srcCityName: string;
        /**
         * The source IP address.
         */
        srcIp: string;
        /**
         * The source port.
         */
        srcPort: number;
        /**
         * The source province ID.
         */
        srcProvinceId: string;
        /**
         * The source province name.
         */
        srcProvinceName: string;
        /**
         * The source region ID.
         */
        srcRegionId: string;
        /**
         * The source region name.
         */
        srcRegionName: string;
    }

    export interface GetAddressGroupMembersRecord {
        /**
         * The IP address.
         */
        address: string;
        /**
         * The address type.
         */
        addressType: number;
        /**
         * The address group member description.
         */
        description: string;
        /**
         * The ID of an address group member.
         */
        itemId: string;
    }

    export interface GetAddressGroupsAddressGroup {
        /**
         * The address type.
         */
        addressType: number;
        /**
         * The address groups description.
         */
        description: string;
        /**
         * The ID of the IP address group.
         */
        id: string;
        /**
         * The IP address group name.
         */
        name: string;
        /**
         * The protected object ID.
         */
        objectId: string;
        /**
         * The number of times this address group has been referenced.
         */
        refCount: number;
        /**
         * The address group type.
         */
        type: number;
    }

    export interface GetAttackLogsRecord {
        /**
         * Then action.
         */
        action: string;
        /**
         * The application protocol.
         */
        app: string;
        /**
         * The attack rule.
         */
        attackRule: string;
        /**
         * The attack rule ID.
         */
        attackRuleId: string;
        /**
         * The attack type.
         */
        attackType: string;
        /**
         * The direction.
         */
        direction: string;
        /**
         * The distination city ID.
         */
        dstCityId: string;
        /**
         * The distination city name.
         */
        dstCityName: string;
        /**
         * The destination IP address.
         */
        dstIp: string;
        /**
         * The destination port.
         */
        dstPort: number;
        /**
         * The distination province ID.
         */
        dstProvinceId: string;
        /**
         * The distination province name.
         */
        dstProvinceName: string;
        /**
         * The destination region ID.
         */
        dstRegionId: string;
        /**
         * The destination region name.
         */
        dstRegionName: string;
        /**
         * The event time.
         */
        eventTime: string;
        /**
         * The threat level.
         */
        level: string;
        /**
         * The log ID.
         */
        logId: string;
        /**
         * The attack log packet.
         */
        packet: string;
        /**
         * The packet length.
         */
        packetLength: number;
        /**
         * The packet messages.
         */
        packetMessages: outputs.Cfw.GetAttackLogsRecordPacketMessage[];
        /**
         * The protocol.
         */
        protocol: string;
        /**
         * The source.
         */
        source: string;
        /**
         * The source city ID.
         */
        srcCityId: string;
        /**
         * The source city name.
         */
        srcCityName: string;
        /**
         * The source IP address.
         */
        srcIp: string;
        /**
         * The source port.
         */
        srcPort: number;
        /**
         * The source province ID.
         */
        srcProvinceId: string;
        /**
         * The source province name.
         */
        srcProvinceName: string;
        /**
         * The source region ID.
         */
        srcRegionId: string;
        /**
         * The source region name.
         */
        srcRegionName: string;
    }

    export interface GetAttackLogsRecordPacketMessage {
        /**
         * The hexadecimal index.
         */
        hexIndex: string;
        /**
         * The hexadecimal series.
         */
        hexs: string[];
        /**
         * The utf-8 string.
         */
        utf8String: string;
    }

    export interface GetBlackWhiteListsRecord {
        /**
         * The IP address.
         */
        address: string;
        /**
         * The IP address type.
         */
        addressType: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The direction of a black or white address.
         */
        direction: string;
        /**
         * The blacklist/whitelist ID.
         */
        listId: string;
        /**
         * The port.
         */
        port: string;
        /**
         * The protocol type.
         */
        protocol: number;
    }

    export interface GetCaptureTaskResultsFileList {
        /**
         * The file name.
         */
        fileName: string;
        /**
         * The file path.
         */
        filePath: string;
        /**
         * The download link.
         */
        url: string;
    }

    export interface GetCaptureTaskResultsRequestHeader {
        /**
         * The host header information.
         */
        host: string;
    }

    export interface GetCaptureTasksRecord {
        /**
         * The capture task size.
         */
        captureSize: string;
        /**
         * The creation time of the capture task.
         */
        createdAt: string;
        /**
         * The destination address.
         */
        destAddress: string;
        /**
         * The destination address type.
         */
        destAddressType: number;
        /**
         * The destination port.
         */
        destPort: string;
        /**
         * The capture task duration.
         */
        duration: number;
        /**
         * Whether is deleted.
         */
        isDeleted: number;
        /**
         * The max packets.
         */
        maxPackets: number;
        /**
         * The capture task name.
         */
        name: string;
        /**
         * The protocol type.
         */
        protocol: number;
        /**
         * The remaining days.
         */
        remainingDays: number;
        /**
         * The source address.
         */
        sourceAddress: string;
        /**
         * The source address type.
         */
        sourceAddressType: number;
        /**
         * The source port.
         */
        sourcePort: string;
        /**
         * The capture task status.
         */
        status: number;
        /**
         * The capture task ID.
         */
        taskId: string;
        /**
         * The update time of the capture task.
         */
        updatedAt: string;
    }

    export interface GetDomainNameGroupsRecord {
        /**
         * The configuration status.
         */
        configStatus: string;
        /**
         * The domain name group description.
         */
        description: string;
        /**
         * The list of domain names.
         */
        domainNames: outputs.Cfw.GetDomainNameGroupsRecordDomainName[];
        /**
         * The domain name group ID.
         */
        groupId: string;
        /**
         * The configuration message.
         */
        message: string;
        /**
         * The domain name group name.
         */
        name: string;
        /**
         * The domain name group reference count.
         */
        refCount: string;
        /**
         * The used rule list.
         */
        rules: outputs.Cfw.GetDomainNameGroupsRecordRule[];
        /**
         * The domain name group type.
         */
        type: string;
    }

    export interface GetDomainNameGroupsRecordDomainName {
        /**
         * The description.
         */
        description: string;
        /**
         * The domain address ID.
         */
        domainAddressId: string;
        /**
         * The domain name.
         */
        domainName: string;
    }

    export interface GetDomainNameGroupsRecordRule {
        /**
         * The rule ID.
         */
        id: string;
        /**
         * The rule name.
         */
        name: string;
    }

    export interface GetFirewallsRecord {
        /**
         * Billing mode. The value can be 0 (yearly/monthly) or 1 (pay-per-use).
         */
        chargeMode: number;
        /**
         * Engine type
         */
        engineType: number;
        /**
         * Whether to enable the feature. The options are true (yes) and false (no).
         */
        featureToggle: {[key: string]: boolean};
        /**
         * The flavor of the firewall.
         */
        flavors: outputs.Cfw.GetFirewallsRecordFlavor[];
        /**
         * Firewall ID
         */
        fwInstanceId: string;
        /**
         * Cluster type
         */
        haType: number;
        /**
         * Whether the engine is an old engine. The options are true (yes) and false (no).
         */
        isOldFirewallInstance: boolean;
        /**
         * Firewall name
         */
        name: string;
        /**
         * Project list
         */
        protectObjects: outputs.Cfw.GetFirewallsRecordProtectObject[];
        /**
         * Firewall instance resources
         */
        resources: outputs.Cfw.GetFirewallsRecordResource[];
        /**
         * Service type
         */
        serviceType: number;
        /**
         * Firewall status list. The options are as follows: -1: waiting for payment; 0: creating; 1: deleting; 2: running; 3: upgrading; 4: deletion completed; 5: freezing; 6: creation failed; 7: deletion failed; 8: freezing failed; 9: storage in progress; 10: storage failed; 11: upgrade failed
         */
        status: number;
        /**
         * Whether IPv6 is supported. The options are true (yes) and false (no).
         */
        supportIpv6: boolean;
    }

    export interface GetFirewallsRecordFlavor {
        /**
         * Bandwidth
         */
        bandwidth: number;
        /**
         * Number of EIPs
         */
        eipCount: number;
        /**
         * Log storage
         */
        logStorage: number;
        /**
         * Firewall version. The value can be 0 (standard edition), 1 (professional edition), 2 (platinum edition), or 3 (basic edition).
         */
        version: number;
        /**
         * Number of VPCs
         */
        vpcCount: number;
    }

    export interface GetFirewallsRecordProtectObject {
        /**
         * Protected object ID
         */
        objectId: string;
        /**
         * Protected object name
         */
        objectName: string;
        /**
         * Project type. The options are as follows: 0: north-south; 1: east-west.
         */
        type: number;
    }

    export interface GetFirewallsRecordResource {
        /**
         * Service type, which is used by CBC. The value is hws.service.type.cfw.
         */
        cloudServiceType: string;
        /**
         * Resource ID
         */
        resourceId: string;
        /**
         * Resource quantity
         */
        resourceSize: number;
        /**
         * Resource unit name
         */
        resourceSizeMeasureId: number;
        /**
         * Inventory unit code
         */
        resourceSpecCode: string;
        /**
         * Resource type. The options are as follows:1. CFW: hws.resource.type.cfw 2. EIP:hws.resource.type.cfw.exp.eip 3. Bandwidth: hws.resource.type.cfw.exp.bandwidth 4. VPC: hws.resource.type.cfw.exp.vpc 5. Log storage: hws.resource.type.cfw.exp.logaudit
         */
        resourceType: string;
    }

    export interface GetFlowLogsRecord {
        /**
         * The application protocol.
         */
        app: string;
        /**
         * The flow log bytes.
         */
        bytes: number;
        /**
         * The direction, which can be inbound or outbound.
         */
        direction: string;
        /**
         * The distination city ID.
         */
        dstCityId: string;
        /**
         * The distination city name.
         */
        dstCityName: string;
        /**
         * The destination host.
         */
        dstHost: string;
        /**
         * The destination IP address.
         */
        dstIp: string;
        /**
         * The destination port.
         */
        dstPort: number;
        /**
         * The distination province ID.
         */
        dstProvinceId: string;
        /**
         * The distination province name.
         */
        dstProvinceName: string;
        /**
         * The destination region id.
         */
        dstRegionId: string;
        /**
         * The destination region name.
         */
        dstRegionName: string;
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The document ID.
         */
        logId: string;
        /**
         * The number of packets.
         */
        packets: number;
        /**
         * The protocol type.
         */
        protocol: string;
        /**
         * The source city ID.
         */
        srcCityId: string;
        /**
         * The source city name.
         */
        srcCityName: string;
        /**
         * The source IP address.
         */
        srcIp: string;
        /**
         * The source port.
         */
        srcPort: number;
        /**
         * The source province ID.
         */
        srcProvinceId: string;
        /**
         * The source province name.
         */
        srcProvinceName: string;
        /**
         * The source region id.
         */
        srcRegionId: string;
        /**
         * The source region name.
         */
        srcRegionName: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface GetIpsCustomRulesRecord {
        /**
         * The action.
         */
        action: number;
        /**
         * The affected OS.
         */
        affectedOs: number;
        /**
         * The attack type.
         */
        attackType: number;
        /**
         * The rule status.
         */
        configStatus: number;
        /**
         * The content storage in JSON format.
         */
        content: string;
        /**
         * The destination port type.
         */
        dstPortType: number;
        /**
         * The destination port.
         */
        dstPorts: string;
        /**
         * The firewall cluster ID.
         */
        groupId: string;
        /**
         * The ID of a custom IPS rule in CFW.
         */
        ipsCfwId: string;
        /**
         * The ID of a rule in Hillstone.
         */
        ipsId: string;
        /**
         * The IPS rule name.
         */
        ipsName: string;
        /**
         * The protocol.
         */
        protocol: number;
        /**
         * The severity.
         */
        severity: number;
        /**
         * The affected software.
         */
        software: number;
        /**
         * The source port type.
         */
        srcPortType: number;
        /**
         * The source port.
         */
        srcPorts: string;
    }

    export interface GetIpsRuleDetailsData {
        /**
         * The IPS type.
         */
        ipsType: number;
        /**
         * The IPS version.
         */
        ipsVersion: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface GetIpsRulesRecord {
        /**
         * The application affected by the rule.
         */
        affectedApplication: string;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The default status of the IPS rule.
         */
        defaultStatus: string;
        /**
         * The CVE.
         */
        ipsCve: string;
        /**
         * The IPS rule group.
         */
        ipsGroup: string;
        /**
         * The IPS rule ID.
         */
        ipsId: string;
        /**
         * The risk level.
         */
        ipsLevel: string;
        /**
         * The IPS rule name.
         */
        ipsName: string;
        /**
         * The IPS rule type.
         */
        ipsRulesType: string;
        /**
         * The current status of the IPS rule.
         */
        ipsStatus: string;
    }

    export interface GetProtectionRulesRecord {
        /**
         * The rule action type.
         */
        actionType: string;
        /**
         * The address type.
         */
        addressType: number;
        /**
         * The created time of a rule.
         */
        createdDate: string;
        /**
         * The rule description.
         */
        description: string;
        /**
         * The destination configuration.
         */
        destinations: outputs.Cfw.GetProtectionRulesRecordDestination[];
        /**
         * The direction of a rule.
         */
        direction: string;
        /**
         * The last open time.
         */
        lastOpenTime: string;
        /**
         * Whether to support persistent connections.
         */
        longConnectEnable: number;
        /**
         * The persistent connection duration.
         */
        longConnectTime: number;
        /**
         * The persistent connection duration (hour).
         */
        longConnectTimeHour: number;
        /**
         * The persistent connection duration (minute).
         */
        longConnectTimeMinute: number;
        /**
         * The persistent connection duration (second).
         */
        longConnectTimeSecond: number;
        /**
         * The rule name.
         */
        name: string;
        /**
         * The rule ID.
         */
        ruleId: string;
        /**
         * The service.
         */
        services: outputs.Cfw.GetProtectionRulesRecordService[];
        /**
         * The source configuration.
         */
        sources: outputs.Cfw.GetProtectionRulesRecordSource[];
        /**
         * The rule status.
         */
        status: string;
        /**
         * The tag of a rule.
         */
        tags: {[key: string]: string};
        /**
         * The rule type.
         */
        type: string;
    }

    export interface GetProtectionRulesRecordDestination {
        /**
         * The destination IP address.
         */
        address: string;
        /**
         * The address group.
         */
        addressGroups: string[];
        /**
         * The ID of the associated IP address group.
         */
        addressSetId: string;
        /**
         * The IP address group name.
         */
        addressSetName: string;
        /**
         * The destination address set type.
         */
        addressSetType: number;
        /**
         * The destination address type.
         */
        addressType: number;
        /**
         * The name of the domain name address.
         */
        domainAddressName: string;
        /**
         * The ID of the domain group.
         */
        domainSetId: string;
        /**
         * The name of domain group.
         */
        domainSetName: string;
        /**
         * The IP address list.
         */
        ipAddresses: string[];
        /**
         * The region list of a rule.
         */
        regionLists: outputs.Cfw.GetProtectionRulesRecordDestinationRegionList[];
        /**
         * The destination type.
         */
        type: number;
    }

    export interface GetProtectionRulesRecordDestinationRegionList {
        /**
         * The Chinese description of a region.
         */
        descriptionCn: string;
        /**
         * The English description of a region.
         */
        descriptionEn: string;
        /**
         * The region ID of the destination.
         */
        regionId: string;
        /**
         * The region type.
         */
        regionType: number;
    }

    export interface GetProtectionRulesRecordService {
        /**
         * The custom service.
         */
        customServices: outputs.Cfw.GetProtectionRulesRecordServiceCustomService[];
        /**
         * The destination port of the service.
         */
        destPort: string;
        /**
         * The protocol type.
         */
        protocol: number;
        /**
         * The protocols.
         */
        protocols: number[];
        /**
         * The service group list.
         */
        serviceGroups: string[];
        /**
         * The service group ID.
         */
        serviceSetId: string;
        /**
         * The service group name.
         */
        serviceSetName: string;
        /**
         * The service set type.
         */
        serviceSetType: number;
        /**
         * The source port.
         */
        sourcePort: string;
        /**
         * The service input type.
         */
        type: number;
    }

    export interface GetProtectionRulesRecordServiceCustomService {
        /**
         * The custom service description.
         */
        description: string;
        /**
         * The destination port.
         */
        destPort: string;
        /**
         * The custom service name.
         */
        name: string;
        /**
         * The protocol type of the custom service.
         */
        protocol: number;
        /**
         * The source port of the custom service.
         */
        sourcePort: string;
    }

    export interface GetProtectionRulesRecordSource {
        /**
         * The source IP address.
         */
        address: string;
        /**
         * The address group.
         */
        addressGroups: string[];
        /**
         * The ID of the associated IP address group.
         */
        addressSetId: string;
        /**
         * The IP address group name.
         */
        addressSetName: string;
        /**
         * The address set type.
         */
        addressSetType: number;
        /**
         * The address type.
         */
        addressType: number;
        /**
         * The name of the domain address.
         */
        domainAddressName: string;
        /**
         * The IP address list.
         */
        ipAddresses: string[];
        /**
         * The region list of a rule.
         */
        regionLists: outputs.Cfw.GetProtectionRulesRecordSourceRegionList[];
        /**
         * The source type.
         */
        type: number;
    }

    export interface GetProtectionRulesRecordSourceRegionList {
        /**
         * The Chinese description of a region.
         */
        descriptionCn: string;
        /**
         * The English description of a region.
         */
        descriptionEn: string;
        /**
         * The region ID.
         */
        regionId: string;
        /**
         * The region type.
         */
        regionType: number;
    }

    export interface GetResourceTagsTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface GetServiceGroupMembersRecord {
        /**
         * The service group member description.
         */
        description: string;
        /**
         * The destination port.
         */
        destPort: string;
        /**
         * The service group member ID.
         */
        itemId: string;
        /**
         * The protocol type.
         */
        protocol: number;
        /**
         * The source port.
         */
        sourcePort: string;
    }

    export interface GetServiceGroupsServiceGroup {
        /**
         * The description of the service group.
         */
        description: string;
        /**
         * The service group ID.
         */
        id: string;
        /**
         * The name of the service group.
         */
        name: string;
        /**
         * The protocols of the service group.
         */
        protocols: number[];
        /**
         * The number of times this service group has been referenced.
         */
        refCount: number;
        /**
         * The type of the Service group.
         */
        type: number;
    }

    export interface GetTagsTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag values.
         */
        values: string[];
    }

}

export namespace Css {
    export interface ClusterBackupStrategy {
        agency: string;
        backupPath: string;
        bucket: string;
        keepDays?: number;
        prefix?: string;
        startTime: string;
    }

    export interface ClusterClientNodeConfig {
        flavor: string;
        instanceNumber: number;
        shrinkNodeIds?: string[];
        volume: outputs.Css.ClusterClientNodeConfigVolume;
    }

    export interface ClusterClientNodeConfigVolume {
        size: number;
        volumeType: string;
    }

    export interface ClusterColdNodeConfig {
        flavor: string;
        instanceNumber: number;
        shrinkNodeIds?: string[];
        volume: outputs.Css.ClusterColdNodeConfigVolume;
    }

    export interface ClusterColdNodeConfigVolume {
        size: number;
        volumeType: string;
    }

    export interface ClusterEssNodeConfig {
        flavor: string;
        instanceNumber: number;
        shrinkNodeIds?: string[];
        volume: outputs.Css.ClusterEssNodeConfigVolume;
    }

    export interface ClusterEssNodeConfigVolume {
        size: number;
        volumeType: string;
    }

    export interface ClusterKibanaPublicAccess {
        bandwidth: number;
        publicIp: string;
        whitelist?: string;
        whitelistEnabled: boolean;
    }

    export interface ClusterMasterNodeConfig {
        flavor: string;
        instanceNumber: number;
        shrinkNodeIds?: string[];
        volume: outputs.Css.ClusterMasterNodeConfigVolume;
    }

    export interface ClusterMasterNodeConfigVolume {
        size: number;
        volumeType: string;
    }

    export interface ClusterNode {
        availabilityZone: string;
        id: string;
        ip: string;
        name: string;
        resourceId: string;
        specCode: string;
        status: string;
        type: string;
    }

    export interface ClusterNodeConfig {
        availabilityZone: string;
        flavor: string;
        networkInfo: outputs.Css.ClusterNodeConfigNetworkInfo;
        volume: outputs.Css.ClusterNodeConfigVolume;
    }

    export interface ClusterNodeConfigNetworkInfo {
        securityGroupId: string;
        subnetId: string;
        vpcId: string;
    }

    export interface ClusterNodeConfigVolume {
        size: number;
        volumeType: string;
    }

    export interface ClusterPublicAccess {
        bandwidth: number;
        publicIp: string;
        whitelist?: string;
        whitelistEnabled: boolean;
    }

    export interface ClusterVpcepEndpoint {
        endpointWithDnsName: boolean;
        whitelists?: string[];
    }

    export interface GetFlavorsFlavor {
        availabilityZones: string;
        diskRange: string;
        id: string;
        memory: number;
        name: string;
        region: string;
        type: string;
        vcpus: number;
        version: string;
    }

}

export namespace Cts {
    export interface NotificationFilter {
        condition: string;
        rules: string[];
    }

    export interface NotificationOperation {
        resource: string;
        service: string;
        traceNames: string[];
    }

    export interface NotificationOperationUser {
        group: string;
        users: string[];
    }

}

export namespace Dcs {
    export interface GetFlavorsFlavor {
        availableZones: string[];
        cacheMode: string;
        capacity: number;
        chargingModes: string[];
        cpuArchitecture: string;
        engine: string;
        engineVersions: string;
        ipCount: number;
        name: string;
    }

    export interface InstanceBackupPolicy {
        backupAts: number[];
        backupType?: string;
        beginAt: string;
        periodType?: string;
        saveDays?: number;
    }

    export interface InstanceBandwidthInfo {
        bandwidth: number;
        beginTime: string;
        currentTime: string;
        endTime: string;
        expandCount: number;
        expandEffectTime: number;
        expandIntervalTime: number;
        maxExpandCount: number;
        nextExpandTime: string;
        taskRunning: boolean;
    }

    export interface InstanceParameter {
        id: string;
        name: string;
        value: string;
    }

    export interface InstanceWhitelist {
        groupName: string;
        ipAddresses: string[];
    }

}

export namespace Dds {
    export interface GetFlavorsFlavor {
        memory: string;
        specCode: string;
        type: string;
        vcpus: string;
    }

    export interface InstanceBackupStrategy {
        keepDays: number;
        period: string;
        startTime: string;
    }

    export interface InstanceConfiguration {
        id: string;
        type: string;
    }

    export interface InstanceDatastore {
        storageEngine?: string;
        type: string;
        version: string;
    }

    export interface InstanceFlavor {
        num: number;
        size?: number;
        specCode: string;
        storage?: string;
        type: string;
    }

    export interface InstanceGroup {
        id: string;
        name: string;
        nodes: outputs.Dds.InstanceGroupNode[];
        size: string;
        status: string;
        type: string;
        used: string;
    }

    export interface InstanceGroupNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Indicates the node name.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the EIP that has been bound on a node.
         */
        publicIp: string;
        /**
         * Indicates the node role.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type.
         */
        type: string;
    }

    export interface InstanceNode {
        /**
         * Indicates the node ID.
         */
        id: string;
        /**
         * Indicates the node name.
         */
        name: string;
        /**
         * Indicates the private IP address of a node.
         */
        privateIp: string;
        /**
         * Indicates the EIP that has been bound on a node.
         */
        publicIp: string;
        /**
         * Indicates the node role.
         */
        role: string;
        /**
         * Indicates the node status.
         */
        status: string;
        /**
         * Indicates the node type.
         */
        type: string;
    }

}

export namespace DedicatedApig {
    export interface ApiBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiFuncGraph {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The alias URN of the FunctionGraph function.
         */
        functionAliasUrn?: string;
        /**
         * The URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * The invocation type.
         */
        invocationType?: string;
        /**
         * The network architecture (framework) type of the FunctionGraph function.
         */
        networkType?: string;
        /**
         * The request protocol of the FunctionGraph function.
         */
        requestProtocol?: string;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The version of the FunctionGraph function.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The configaiton list of the backend parameters.
         */
        backendParams?: outputs.DedicatedApig.ApiFuncGraphPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.DedicatedApig.ApiFuncGraphPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The alias URN of the FunctionGraph function.
         */
        functionAliasUrn?: string;
        /**
         * The URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * The invocation mode of the FunctionGraph function.
         */
        invocationMode?: string;
        /**
         * The invocation mode of the FunctionGraph function.
         */
        invocationType?: string;
        /**
         * The name of the backend policy.
         */
        name: string;
        /**
         * The network (framework) type of the FunctionGraph function.
         */
        networkType?: string;
        /**
         * The request protocol of the FunctionGraph function.
         */
        requestProtocol?: string;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The version of the FunctionGraph function.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiFuncGraphPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface ApiMock {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The response content of the mock.
         */
        response?: string;
        /**
         * The custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The configuration list of backend parameters.
         */
        backendParams?: outputs.DedicatedApig.ApiMockPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.DedicatedApig.ApiMockPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The backend policy name.
         */
        name: string;
        /**
         * The response content of the mock.
         */
        response?: string;
        /**
         * The custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiMockPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface ApiPublishmentHistory {
        /**
         * The version description of the API publishment.
         */
        description: string;
        /**
         * The version ID of the API publishment.
         */
        versionId: string;
    }

    export interface ApiRequestParam {
        /**
         * The default value of the parameter.
         */
        default: string;
        /**
         * The parameter description.
         */
        description: string;
        /**
         * The enumerated value.
         */
        enumeration: string;
        /**
         * The parameter example.
         */
        example: string;
        /**
         * Where this parameter is located.
         */
        location?: string;
        /**
         * The maximum value or length (string parameter) for parameter.
         */
        maximum: number;
        /**
         * The minimum value or length (string parameter) for parameter.
         */
        minimum: number;
        /**
         * The name of the request parameter.
         */
        name: string;
        /**
         * The list of orchestration rules that parameter used.
         */
        orchestrations?: string[];
        /**
         * Whether to transparently transfer the parameter.
         */
        passthrough: boolean;
        /**
         * Whether this parameter is required.
         */
        required: boolean;
        /**
         * The parameter type.
         */
        type?: string;
        /**
         * Whether to enable the parameter validation.
         */
        validEnable: number;
    }

    export interface ApiWeb {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The backend service address, which consists of a domain name or IP address, and a port number.
         */
        backendAddress?: string;
        /**
         * The proxy host header.
         */
        hostHeader?: string;
        /**
         * The backend request path.
         */
        path: string;
        /**
         * The backend request method of the API.
         */
        requestMethod?: string;
        /**
         * The web protocol type of the API request.
         */
        requestProtocol?: string;
        /**
         * The number of retry attempts to request the backend service.
         */
        retryCount?: number;
        /**
         * Whether to enable two-way authentication.
         */
        sslEnable?: boolean;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The VPC channel ID.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The backend service address
         */
        backendAddress?: string;
        /**
         * The configuration list of the backend parameters.
         */
        backendParams?: outputs.DedicatedApig.ApiWebPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.DedicatedApig.ApiWebPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The proxy host header.
         */
        hostHeader?: string;
        /**
         * The name of the web policy.
         */
        name: string;
        /**
         * The backend request address.
         */
        path: string;
        /**
         * The backend request method of the API.
         */
        requestMethod: string;
        /**
         * The backend request protocol.
         */
        requestProtocol?: string;
        /**
         * The number of retry attempts to request the backend service.
         */
        retryCount?: number;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The VPC channel ID.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiWebPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface CustomAuthorizerIdentity {
        /**
         * The parameter location.
         */
        location: string;
        /**
         * The name of the parameter to be verified.
         */
        name: string;
        /**
         * The parameter verification expression.
         */
        validation?: string;
    }

    export interface GetEnvironmentsEnvironment {
        createTime: string;
        description: string;
        id: string;
        name: string;
    }

    export interface GroupEnvironment {
        /**
         * The ID of the environment to which the variables belongs.
         */
        environmentId: string;
        /**
         * The array of one or more environment variables.
         */
        variables: outputs.DedicatedApig.GroupEnvironmentVariable[];
    }

    export interface GroupEnvironmentVariable {
        /**
         * The ID of the variable that the group has.
         */
        id: string;
        /**
         * The variable name.
         */
        name: string;
        /**
         * The variable value.
         */
        value: string;
        /**
         * schema: Deprecated; The ID of the variable that the group has.
         *
         * @deprecated Use 'id' instead
         */
        variableId: string;
    }

    export interface GroupUrlDomain {
        /**
         * Whether to enable redirection from HTTP to HTTPS.
         */
        isHttpRedirectToHttps: boolean;
        /**
         * The minimum SSL protocol version.
         */
        minSslVersion: string;
        /**
         * The associated domain name.
         */
        name: string;
    }

    export interface InstanceCustomIngressPort {
        /**
         * The ID of the custom ingress port.
         */
        id: string;
        /**
         * Specified port of the custom ingress port.
         */
        port: number;
        /**
         * Specified protocol of the custom ingress port.
         */
        protocol: string;
        /**
         * The current status of the custom ingress port.
         */
        status: string;
    }

    export interface ResponseRule {
        /**
         * The body template of the API custom response rule.
         */
        body: string;
        /**
         * The error type of the API custom response rule.
         */
        errorType: string;
        /**
         * The configuration of the custom response headers.
         */
        headers?: outputs.DedicatedApig.ResponseRuleHeader[];
        /**
         * The HTTP status code of the API custom response rule.
         */
        statusCode: number;
    }

    export interface ResponseRuleHeader {
        /**
         * The key name of the response header.
         */
        key: string;
        /**
         * The value for the specified response header key.
         */
        value: string;
    }

    export interface ThrottlingPolicyAppThrottle {
        /**
         * The ID of the special user/application throttling policy.
         */
        id: string;
        /**
         * The maximum number of times an API can be accessed within a specified period.
         */
        maxApiRequests: number;
        /**
         * The object ID which the special throttling policy belongs.
         */
        throttlingObjectId: string;
        /**
         * The object name which the special user/application throttling policy belongs.
         */
        throttlingObjectName: string;
    }

    export interface ThrottlingPolicyUserThrottle {
        /**
         * The ID of the special user/application throttling policy.
         */
        id: string;
        /**
         * The maximum number of times an API can be accessed within a specified period.
         */
        maxApiRequests: number;
        /**
         * The object ID which the special throttling policy belongs.
         */
        throttlingObjectId: string;
        /**
         * The object name which the special user/application throttling policy belongs.
         */
        throttlingObjectName: string;
    }

}

export namespace Dew {
    export interface GetKeypairsKeypair {
        fingerprint: string;
        isManaged: boolean;
        name: string;
        publicKey: string;
        scope: string;
    }

}

export namespace Dis {
    export interface StreamPartition {
        hashRange: string;
        id: string;
        sequenceNumberRange: string;
        status: string;
    }

}

export namespace Dli {
    export interface QueueScalingPolicy {
        impactStartTime: string;
        impactStopTime: string;
        maxCu: number;
        minCu: number;
        priority: number;
    }

    export interface QueueSparkDriver {
        maxConcurrent?: number;
        maxInstance?: number;
        maxPrefetchInstance?: string;
    }

    export interface SparkJobDependentPackage {
        groupName: string;
        packages: outputs.Dli.SparkJobDependentPackagePackage[];
    }

    export interface SparkJobDependentPackagePackage {
        packageName: string;
        type: string;
    }

}

export namespace Dms {
    export interface GetFlavorsFlavor {
        archTypes: string[];
        chargingModes: string[];
        id: string;
        ios: outputs.Dms.GetFlavorsFlavorIo[];
        properties: outputs.Dms.GetFlavorsFlavorProperty[];
        supportFeatures: outputs.Dms.GetFlavorsFlavorSupportFeature[];
        type: string;
        vmSpecification: string;
    }

    export interface GetFlavorsFlavorIo {
        availabilityZones: string[];
        storageSpecCode: string;
        type: string;
        unavailabilityZones: string[];
    }

    export interface GetFlavorsFlavorProperty {
        flavorAlias: string;
        maxBandwidthPerBroker: number;
        maxBroker: number;
        maxConsumerPerBroker: number;
        maxPartitionPerBroker: number;
        maxStoragePerNode: number;
        maxTpsPerBroker: number;
        minBroker: number;
        minStoragePerNode: number;
    }

    export interface GetFlavorsFlavorSupportFeature {
        name: string;
        properties: outputs.Dms.GetFlavorsFlavorSupportFeatureProperty[];
    }

    export interface GetFlavorsFlavorSupportFeatureProperty {
        maxNode: number;
        maxTask: number;
        minNode: number;
        minTask: number;
    }

    export interface GetInstancesInstance {
        accessUser: string;
        availabilityZones: string[];
        connectAddress: string;
        crossVpcAccesses: outputs.Dms.GetInstancesInstanceCrossVpcAccess[];
        description: string;
        dumping: boolean;
        enableAutoTopic: boolean;
        enablePublicIp: boolean;
        enabledMechanisms: string[];
        engineVersion: string;
        enterpriseProjectId: string;
        id: string;
        maintainBegin: string;
        maintainEnd: string;
        managementConnectAddress: string;
        managerUser: string;
        /**
         * @deprecated typo in manegement_connect_address, please use "managementConnectAddress" instead.
         */
        manegementConnectAddress: string;
        name: string;
        networkId: string;
        partitionNum: number;
        port: number;
        productId: string;
        publicConnAddresses: string;
        publicIpIds: string[];
        resourceSpecCode: string;
        retentionPolicy: string;
        securityGroupId: string;
        securityProtocol: string;
        sslEnable: boolean;
        status: string;
        storageSpace: number;
        storageSpecCode: string;
        tags: {[key: string]: string};
        type: string;
        usedStorageSpace: number;
        userId: string;
        userName: string;
        vpcId: string;
    }

    export interface GetInstancesInstanceCrossVpcAccess {
        advertisedIp: string;
        /**
         * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
         */
        lisenterIp: string;
        listenerIp: string;
        port: number;
        portId: string;
    }

    export interface KafkaInstanceCrossVpcAccess {
        advertisedIp: string;
        /**
         * @deprecated typo in lisenter_ip, please use "listenerIp" instead.
         */
        lisenterIp: string;
        listenerIp: string;
        port: number;
        portId: string;
    }

    export interface KafkaInstanceParameter {
        name: string;
        value: string;
    }

    export interface KafkaInstancePortProtocol {
        privatePlainAddress: string;
        privatePlainDomainName: string;
        privatePlainEnable: boolean;
        privateSaslPlaintextAddress: string;
        privateSaslPlaintextDomainName: string;
        privateSaslPlaintextEnable: boolean;
        privateSaslSslAddress: string;
        privateSaslSslDomainName: string;
        privateSaslSslEnable: boolean;
        publicPlainAddress: string;
        publicPlainDomainName: string;
        publicPlainEnable: boolean;
        publicSaslPlaintextAddress: string;
        publicSaslPlaintextDomainName: string;
        publicSaslPlaintextEnable: boolean;
        publicSaslSslAddress: string;
        publicSaslSslDomainName: string;
        publicSaslSslEnable: boolean;
    }

    export interface KafkaPermissionsPolicy {
        accessPolicy: string;
        userName: string;
    }

    export interface KafkaTopicConfig {
        name: string;
        value: string;
    }

}

export namespace Dns {
    export interface ZoneRouter {
        /**
         * The ID of the associated VPC.
         */
        routerId: string;
        /**
         * The region of the VPC.
         */
        routerRegion: string;
    }

}

export namespace Drs {
    export interface JobDestinationDb {
        engineType: string;
        instanceId?: string;
        ip: string;
        name: string;
        password: string;
        port: number;
        region: string;
        sslCertCheckSum?: string;
        sslCertKey?: string;
        sslCertName?: string;
        sslCertPassword?: string;
        sslEnabled?: boolean;
        subnetId?: string;
        user: string;
    }

    export interface JobLimitSpeed {
        endTime: string;
        speed: string;
        startTime: string;
    }

    export interface JobSourceDb {
        engineType: string;
        instanceId?: string;
        ip: string;
        name: string;
        password: string;
        port: number;
        region: string;
        sslCertCheckSum?: string;
        sslCertKey?: string;
        sslCertName?: string;
        sslCertPassword?: string;
        sslEnabled?: boolean;
        subnetId?: string;
        user: string;
    }

}

export namespace Dws {
    export interface ClusterElb {
        /**
         * The ID of the ELB load balancer.
         */
        id: string;
        /**
         * The name of the ELB load balancer.
         */
        name: string;
        /**
         * The private endpoint of the ELB load balancer.
         */
        privateEndpoint: string;
        /**
         * The private IP address of the ELB load balancer.
         */
        privateIp: string;
        /**
         * The IPv6 address of the ELB load balancer.
         */
        privateIpV6: string;
        /**
         * The public IP address of the ELB load balancer.
         */
        publicIp: string;
        /**
         * The ID of VPC to which the ELB load balancer belongs.
         */
        vpcId: string;
    }

    export interface ClusterEndpoint {
        /**
         * Private network connection information.
         */
        connectInfo: string;
        /**
         * JDBC URL. Format: jdbc:postgresql://<connect_info>/<YOUR_DATABASE_NAME>
         */
        jdbcUrl: string;
    }

    export interface ClusterMaintainWindow {
        /**
         * Maintenance time in each week in the unit of day.
         */
        day: string;
        /**
         * Maintenance end time in HH:mm format. The time zone is GMT+0.
         */
        endTime: string;
        /**
         * Maintenance start time in HH:mm format. The time zone is GMT+0.
         */
        startTime: string;
    }

    export interface ClusterPublicEndpoint {
        /**
         * JDBC URL. Format: jdbc:postgresql://<public_connect_info>/<YOUR_DATABASE_NAME>
         */
        jdbcUrl: string;
        /**
         * Public network connection information.
         */
        publicConnectInfo: string;
    }

    export interface ClusterPublicIp {
        /**
         * The EIP ID.
         */
        eipId?: string;
        /**
         * The bind type of public IP.
         */
        publicBindType: string;
    }

    export interface ClusterVolume {
        /**
         * The capacity size, in GB.
         */
        capacity: string;
        /**
         * The volume type.
         */
        type: string;
    }

    export interface GetFlaovrsFlavor {
        /**
         * The list of availability zones.
         */
        availabilityZones: string[];
        /**
         * The type of datastore.
         */
        datastoreType: string;
        /**
         * The version of datastore.
         */
        datastoreVersion: string;
        /**
         * The typical specification, If the volume specification is elastic.
         */
        elasticVolumeSpecs: outputs.Dws.GetFlaovrsFlavorElasticVolumeSpec[];
        /**
         * The name of the dws node flavor.
         */
        flavorId: string;
        /**
         * The ram of the dws node flavor in GB.
         */
        memory: number;
        /**
         * The default disk size in GB.
         */
        size: number;
        /**
         * The vcpus of the dws node flavor.
         */
        vcpus: number;
        /**
         * Disk type.
         */
        volumetype: string;
    }

    export interface GetFlaovrsFlavorElasticVolumeSpec {
        /**
         * Maximum disk size.
         */
        maxSize: number;
        /**
         * Minimum disk size.
         */
        minSize: number;
        /**
         * Disk size increment step.
         */
        step: number;
    }

}

export namespace Ecs {
    export interface GetFlavorsFlavor {
        cpuCoreCount: number;
        generation: string;
        id: string;
        memorySize: number;
        performanceType: string;
        storageType: string;
    }

    export interface GetInstanceNetwork {
        fixedIpV4: string;
        fixedIpV6: string;
        mac: string;
        port: string;
        uuid: string;
    }

    export interface GetInstanceSchedulerHint {
        group: string;
    }

    export interface GetInstanceVolumeAttached {
        bootIndex: number;
        isSysVolume: boolean;
        pciAddress: string;
        size: number;
        type: string;
        volumeId: string;
    }

    export interface GetInstancesInstance {
        availabilityZone: string;
        chargingMode: string;
        enterpriseProjectId: string;
        expiredTime: string;
        flavorId: string;
        flavorName: string;
        id: string;
        imageId: string;
        imageName: string;
        keyPair: string;
        name: string;
        networks: outputs.Ecs.GetInstancesInstanceNetwork[];
        publicIp: string;
        schedulerHints: outputs.Ecs.GetInstancesInstanceSchedulerHint[];
        securityGroupIds: string[];
        status: string;
        systemDiskId: string;
        tags: {[key: string]: string};
        userData: string;
        volumeAttacheds: outputs.Ecs.GetInstancesInstanceVolumeAttached[];
    }

    export interface GetInstancesInstanceNetwork {
        fixedIpV4: string;
        fixedIpV6: string;
        mac: string;
        port: string;
        uuid: string;
    }

    export interface GetInstancesInstanceSchedulerHint {
        group: string;
    }

    export interface GetInstancesInstanceVolumeAttached {
        bootIndex: number;
        isSysVolume: boolean;
        pciAddress: string;
        size: number;
        type: string;
        volumeId: string;
    }

    export interface GetServergroupsServergroup {
        id: string;
        members: string[];
        name: string;
        policies: string[];
    }

    export interface InstanceBandwidth {
        chargeMode?: string;
        extendParam?: {[key: string]: string};
        id?: string;
        shareType: string;
        size?: number;
    }

    export interface InstanceDataDisk {
        dssPoolId?: string;
        iops?: number;
        kmsKeyId?: string;
        size: number;
        snapshotId?: string;
        throughput?: number;
        type: string;
    }

    export interface InstanceNetwork {
        accessNetwork?: boolean;
        fixedIpV4: string;
        /**
         * schema: Computed
         */
        fixedIpV6: string;
        ipv6Enable?: boolean;
        mac: string;
        /**
         * schema: Computed
         */
        port: string;
        sourceDestCheck?: boolean;
        /**
         * schema: Required
         */
        uuid: string;
    }

    export interface InstanceSchedulerHint {
        dehId?: string;
        /**
         * schema: Internal
         */
        faultDomain?: string;
        group: string;
        tenancy?: string;
    }

    export interface InstanceVolumeAttached {
        bootIndex: number;
        kmsKeyId: string;
        pciAddress: string;
        size: number;
        type: string;
        volumeId: string;
    }

}

export namespace Eip {
    export interface GetBandwidthPublicip {
        id: string;
        ipAddress: string;
        ipVersion: number;
        type: string;
    }

    export interface GetEipsEip {
        bandwidthId: string;
        bandwidthName: string;
        bandwidthShareType: string;
        bandwidthSize: number;
        createdAt: string;
        enterpriseProjectId: string;
        id: string;
        ipVersion: number;
        name: string;
        portId: string;
        privateIp: string;
        publicIp: string;
        publicIpv6: string;
        status: string;
        tags: {[key: string]: string};
        type: string;
    }

}

export namespace Elb {
    export interface GetListenersListener {
        clientCaTlsContainerRef: string;
        connectionLimit: number;
        createdAt: string;
        defaultPoolId: string;
        defaultTlsContainerRef: string;
        description: string;
        http2Enable: boolean;
        id: string;
        insertHeaders: outputs.Elb.GetListenersListenerInsertHeader[];
        loadbalancers: outputs.Elb.GetListenersListenerLoadbalancer[];
        name: string;
        protectionReason: string;
        protectionStatus: string;
        protocol: string;
        protocolPort: number;
        sniContainerRefs: string[];
        tags: {[key: string]: string};
        tlsCiphersPolicy: string;
        updatedAt: string;
    }

    export interface GetListenersListenerInsertHeader {
        xForwardedElbIp: string;
        xForwardedHost: string;
    }

    export interface GetListenersListenerLoadbalancer {
        /**
         * The loadbalancer ID.
         */
        id: string;
    }

    export interface GetPoolsPool {
        description: string;
        healthmonitorId: string;
        id: string;
        lbMethod: string;
        listeners: outputs.Elb.GetPoolsPoolListener[];
        loadbalancers: outputs.Elb.GetPoolsPoolLoadbalancer[];
        members: outputs.Elb.GetPoolsPoolMember[];
        name: string;
        persistences: outputs.Elb.GetPoolsPoolPersistence[];
        protectionReason: string;
        protectionStatus: string;
        protocol: string;
    }

    export interface GetPoolsPoolListener {
        id: string;
    }

    export interface GetPoolsPoolLoadbalancer {
        id: string;
    }

    export interface GetPoolsPoolMember {
        id: string;
    }

    export interface GetPoolsPoolPersistence {
        cookieName: string;
        timeout: number;
        type: string;
    }

    export interface ListenerInsertHeaders {
        xForwardedElbIp: string;
        xForwardedHost: string;
    }

    export interface PoolPersistence {
        cookieName?: string;
        timeout: number;
        type: string;
    }

}

export namespace Er {
    export interface GetAssociationsAssociation {
        attachmentId: string;
        attachmentType: string;
        createdAt: string;
        id: string;
        resourceId: string;
        routePolicyId: string;
        routeTableId: string;
        status: string;
        updatedAt: string;
    }

    export interface GetAttachmentsAttachment {
        /**
         * Whether this attachment has been associated.
         */
        associated: boolean;
        /**
         * The creation time of the attachment.
         */
        createdAt: string;
        /**
         * The description of the attachment.
         */
        description: string;
        /**
         * The attachment ID.
         */
        id: string;
        /**
         * The attachment name.
         */
        name: string;
        /**
         * The associated resource ID.
         */
        resourceId: string;
        /**
         * The associated route table ID.
         */
        routeTableId: string;
        /**
         * The current status of the attachment.
         */
        status: string;
        /**
         * The key/value pairs to associate with the attachment.
         */
        tags: {[key: string]: string};
        /**
         * The attachment type.
         */
        type: string;
        /**
         * The latest update time of the attachment.
         */
        updatedAt: string;
    }

    export interface GetAvailableRoutesRoute {
        /**
         * The destination address of the route.
         */
        destination: string;
        /**
         * The route ID.
         */
        id: string;
        /**
         * Whether the route is a blackhole route.
         */
        isBlackhole: boolean;
        /**
         * The next hops of the route.
         */
        nextHops: outputs.Er.GetAvailableRoutesRouteNextHop[];
        /**
         * The route type.
         */
        type: string;
    }

    export interface GetAvailableRoutesRouteNextHop {
        /**
         * The attachment ID.
         */
        attachmentId: string;
        /**
         * The attached resource ID.
         */
        resourceId: string;
        /**
         * The attachment type.
         */
        resourceType: string;
    }

    export interface GetFlowLogsFlowLog {
        /**
         * The creation time of the flow log.
         */
        createdAt: string;
        /**
         * The description of the flow log.
         */
        description: string;
        /**
         * The switch of the flow log.
         */
        enabled: boolean;
        /**
         * The ID of the flow log.
         */
        id: string;
        /**
         * The ID of the log group to which the flow log belongs.
         */
        logGroupId: string;
        /**
         * The storage type of the flow log.
         */
        logStoreType: string;
        /**
         * The ID of the log stream to which the flow log belongs.
         */
        logStreamId: string;
        /**
         * The name of the flow log.
         */
        name: string;
        /**
         * The ID of the attachment to which the flow log belongs.
         */
        resourceId: string;
        /**
         * The type of the flow log.
         */
        resourceType: string;
        /**
         * The status of the flow log.
         */
        status: string;
        /**
         * The latest update time of the flow log.
         */
        updatedAt: string;
    }

    export interface GetInstancesInstance {
        /**
         * The BGP AS number of the ER instance.
         */
        asn: number;
        /**
         * Whether to automatically accept the creation of shared attachment.
         */
        autoAcceptSharedAttachments: boolean;
        /**
         * The availability zone list where the ER instance is located.
         */
        availabilityZones: string[];
        /**
         * The creation time of the instance.
         */
        createdAt: string;
        /**
         * The ID of the default association route table.
         */
        defaultAssociationRouteTableId: string;
        /**
         * The ID of the default propagation route table.
         */
        defaultPropagationRouteTableId: string;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * Whether to enable the association of the default route table.
         */
        enableDefaultAssociation: boolean;
        /**
         * Whether to enable the propagation of the default route table.
         */
        enableDefaultPropagation: boolean;
        /**
         * The ID of enterprise project to which the instance belongs.
         */
        enterpriseProjectId: string;
        /**
         * The instance ID.
         */
        id: string;
        /**
         * The name of the instance.
         */
        name: string;
        /**
         * The current status of the instance.
         */
        status: string;
        /**
         * The key/value pairs to associate with the instance.
         */
        tags: {[key: string]: string};
        /**
         * The last update time of the instance.
         */
        updatedAt: string;
    }

    export interface GetPropagationsPropagation {
        attachmentId: string;
        attachmentType: string;
        createdAt: string;
        id: string;
        instanceId: string;
        resourceId: string;
        routePolicyId: string;
        routeTableId: string;
        status: string;
        updatedAt: string;
    }

    export interface GetQuotasQuota {
        /**
         * The number of available quotas, `-1` means unlimited.
         */
        limit: number;
        /**
         * The quota type.
         */
        type: string;
        /**
         * The unit of usage.
         */
        unit: string;
        /**
         * The number of quota used.
         */
        used: number;
    }

    export interface GetRouteTablesRouteTable {
        /**
         * The association configuration of the route table.
         */
        associations: outputs.Er.GetRouteTablesRouteTableAssociation[];
        /**
         * The creation time.
         */
        createdAt: string;
        /**
         * The description of the route table.
         */
        description: string;
        /**
         * The route table ID.
         */
        id: string;
        /**
         * Whether this route table is the default association route table.
         */
        isDefaultAssociation: boolean;
        /**
         * Whether this route table is the default propagation route table.
         */
        isDefaultPropagation: boolean;
        /**
         * The name of the route table.
         */
        name: string;
        /**
         * The propagation configuration of the route table.
         */
        propagations: outputs.Er.GetRouteTablesRouteTablePropagation[];
        /**
         * The route details of the route table.
         */
        routes: outputs.Er.GetRouteTablesRouteTableRoute[];
        /**
         * The current status of the route table.
         */
        status: string;
        /**
         * The tags configuration of the route table.
         */
        tags: {[key: string]: string};
        /**
         * The latest update time.
         */
        updatedAt: string;
    }

    export interface GetRouteTablesRouteTableAssociation {
        /**
         * The attachment ID corresponding to the routing association/propagation.
         */
        attachmentId: string;
        /**
         * The attachment type corresponding to the routing association/propagation.
         */
        attachmentType: string;
        /**
         * The ID of the association/propagation.
         */
        id: string;
    }

    export interface GetRouteTablesRouteTablePropagation {
        /**
         * The attachment ID corresponding to the routing association/propagation.
         */
        attachmentId: string;
        /**
         * The attachment type corresponding to the routing association/propagation.
         */
        attachmentType: string;
        /**
         * The ID of the association/propagation.
         */
        id: string;
    }

    export interface GetRouteTablesRouteTableRoute {
        /**
         * The details of the attachment corresponding to the route.
         */
        attachments: outputs.Er.GetRouteTablesRouteTableRouteAttachment[];
        /**
         * The destination address (CIDR) of the route.
         */
        destination: string;
        /**
         * The route ID.
         */
        id: string;
        /**
         * Whether route is the black hole route.
         */
        isBlackhole: boolean;
        /**
         * The current status of the route.
         */
        status: string;
    }

    export interface GetRouteTablesRouteTableRouteAttachment {
        /**
         * The ID of the nexthop attachment.
         */
        attachmentId: string;
        /**
         * The type of the nexthop attachment.
         */
        attachmentType: string;
        /**
         * The ID of the resource associated with the attachment.
         */
        resourceId: string;
    }

    export interface GetTagsTag {
        /**
         * The key of the resource tag.
         */
        key: string;
        /**
         * All values corresponding to the key.
         */
        values: string[];
    }

}

export namespace Evs {
    export interface GetVolumesVolume {
        attachments: outputs.Evs.GetVolumesVolumeAttachment[];
        availabilityZone: string;
        bootable: boolean;
        createAt: string;
        dedicatedStorageId: string;
        dedicatedStorageName: string;
        description: string;
        enterpriseProjectId: string;
        id: string;
        iops: number;
        iopsAttributes: outputs.Evs.GetVolumesVolumeIopsAttribute[];
        links: outputs.Evs.GetVolumesVolumeLink[];
        metadata: {[key: string]: string};
        name: string;
        serialNumber: string;
        serviceType: string;
        shareable: boolean;
        size: number;
        snapshotId: string;
        status: string;
        tags: {[key: string]: string};
        throughput: number;
        throughputAttributes: outputs.Evs.GetVolumesVolumeThroughputAttribute[];
        updateAt: string;
        volumeImageMetadata: {[key: string]: string};
        volumeType: string;
        wwn: string;
    }

    export interface GetVolumesVolumeAttachment {
        attachedAt: string;
        attachedMode: string;
        attachedVolumeId: string;
        deviceName: string;
        hostName: string;
        id: string;
        serverId: string;
        volumeId: string;
    }

    export interface GetVolumesVolumeIopsAttribute {
        frozened: boolean;
        id: string;
        totalVal: number;
    }

    export interface GetVolumesVolumeLink {
        href: string;
        rel: string;
    }

    export interface GetVolumesVolumeThroughputAttribute {
        frozened: boolean;
        id: string;
        totalVal: number;
    }

    export interface VolumeAttachment {
        attachedAt: string;
        attachedVolumeId: string;
        device: string;
        hostName: string;
        id: string;
        instanceId: string;
        volumeId: string;
    }

    export interface VolumeIopsAttribute {
        frozened: boolean;
        id: string;
        totalVal: number;
    }

    export interface VolumeLink {
        href: string;
        rel: string;
    }

    export interface VolumeThroughputAttribute {
        frozened: boolean;
        id: string;
        totalVal: number;
    }

}

export namespace FunctionGraph {
    export interface FunctionCustomImage {
        /**
         * The command line arguments used to start the SWR image.
         */
        args?: string;
        /**
         * The startup commands of the SWR image.
         */
        command?: string;
        /**
         * The URL of SWR image.
         */
        url: string;
        /**
         * The user group ID that used to run SWR image.
         */
        userGroupId?: string;
        /**
         * The user ID that used to run SWR image.
         */
        userId?: string;
        /**
         * The working directory of the SWR image.
         */
        workingDir: string;
    }

    export interface FunctionFuncMount {
        /**
         * The function access path.
         */
        localMountPath: string;
        /**
         * The ID of the mounted resource (corresponding cloud service).
         */
        mountResource: string;
        /**
         * The remote mount path.
         */
        mountSharePath: string;
        /**
         * The mount type.
         */
        mountType: string;
        /**
         * The mount status.
         */
        status: string;
    }

    export interface FunctionNetworkController {
        /**
         * Whether to disable the public network access.
         */
        disablePublicNetwork?: boolean;
        /**
         * The configuration of the VPCs that can trigger the function.
         */
        triggerAccessVpcs: outputs.FunctionGraph.FunctionNetworkControllerTriggerAccessVpc[];
    }

    export interface FunctionNetworkControllerTriggerAccessVpc {
        /**
         * The ID of the VPC that can trigger the function.
         */
        vpcId: string;
        /**
         * The ID of the VPC that can trigger the function.
         */
        vpcName: string;
    }

    export interface FunctionReservedInstance {
        /**
         * The number of reserved instance.
         */
        count: number;
        /**
         * Whether to enable the idle mode.
         */
        idleMode?: boolean;
        /**
         * The version name or alias name.
         */
        qualifierName: string;
        /**
         * The qualifier type of reserved instance.
         */
        qualifierType: string;
        /**
         * The auto scaling policies for reserved instance.
         */
        tacticsConfig?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfig;
    }

    export interface FunctionReservedInstanceTacticsConfig {
        /**
         * The list of scheduled policy configurations.
         */
        cronConfigs?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfigCronConfig[];
        /**
         * The list of metric policy configurations.
         */
        metricConfigs?: outputs.FunctionGraph.FunctionReservedInstanceTacticsConfigMetricConfig[];
    }

    export interface FunctionReservedInstanceTacticsConfigCronConfig {
        /**
         * The number of reserved instance to which the policy belongs.
         */
        count: number;
        /**
         * The cron expression.
         */
        cron: string;
        /**
         * The expiration timestamp of the policy.
         */
        expiredTime: number;
        /**
         * The name of scheduled policy configuration.
         */
        name: string;
        /**
         * The effective timestamp of policy.
         */
        startTime: number;
    }

    export interface FunctionReservedInstanceTacticsConfigMetricConfig {
        /**
         * The minimun of traffic.
         */
        min: number;
        /**
         * The name of metric policy.
         */
        name: string;
        /**
         * The metric policy threshold.
         */
        threshold: number;
        /**
         * The type of metric policy.
         */
        type: string;
    }

    export interface FunctionVersion {
        /**
         * The aliases management for specified version.
         */
        aliases?: outputs.FunctionGraph.FunctionVersionAliases;
        /**
         * The description of the version.
         */
        description?: string;
        /**
         * The version name.
         */
        name: string;
    }

    export interface FunctionVersionAliases {
        /**
         * The description of the version alias.
         */
        additionalVersionStrategy?: string;
        /**
         * The percentage grayscale configuration of the version alias.
         */
        additionalVersionWeights?: string;
        /**
         * The description of the version alias.
         */
        description?: string;
        /**
         * The name of the version alias.
         */
        name: string;
    }

    export interface GetDependenciesPackage {
        /**
         * The unique ID of the dependency package.
         */
        etag: string;
        /**
         * The file name of the stored dependency package.
         */
        fileName: string;
        /**
         * The ID of the dependency package.
         */
        id: string;
        /**
         * The OBS bucket path where the dependency package is located (FunctionGraph serivce side).
         */
        link: string;
        /**
         * The name of the dependency package.
         */
        name: string;
        /**
         * The owner of the dependency package.
         */
        owner: string;
        /**
         * The runtime of the dependency package.
         */
        runtime: string;
        /**
         * The size of the dependency package.
         */
        size: number;
        /**
         * The list of the versions for the dependency package.
         */
        versions: outputs.FunctionGraph.GetDependenciesPackageVersion[];
    }

    export interface GetDependenciesPackageVersion {
        /**
         * The ID of the dependency package version.
         */
        id: string;
        /**
         * The dependency package version.
         */
        version: number;
    }

}

export namespace Iam {
    export interface AclIpCidr {
        cidr: string;
        description?: string;
    }

    export interface AclIpRange {
        description?: string;
        range: string;
    }

    export interface AgencyProjectRole {
        project: string;
        roles: string[];
    }

    export interface GetGroupUser {
        description: string;
        enabled: boolean;
        id: string;
        name: string;
        passwordExpiresAt: string;
        passwordStatus: boolean;
        passwordStrength: string;
    }

    export interface GetProjectsProject {
        enabled: boolean;
        id: string;
        name: string;
    }

    export interface GetUsersUser {
        description: string;
        enabled: boolean;
        groups: string[];
        id: string;
        name: string;
        passwordExpiresAt: string;
        passwordStatus: boolean;
    }

    export interface ProviderAccessConfig {
        accessType: string;
        authorizationEndpoint: string;
        clientId: string;
        providerUrl: string;
        responseMode?: string;
        responseType?: string;
        scopes: string[];
        signingKey: string;
    }

    export interface ProviderConversionConversionRule {
        locals: outputs.Iam.ProviderConversionConversionRuleLocal[];
        remotes: outputs.Iam.ProviderConversionConversionRuleRemote[];
    }

    export interface ProviderConversionConversionRuleLocal {
        group?: string;
        username?: string;
    }

    export interface ProviderConversionConversionRuleRemote {
        attribute: string;
        condition?: string;
        values?: string[];
    }

    export interface ProviderConversionRule {
        locals: outputs.Iam.ProviderConversionRuleLocal[];
        remotes: outputs.Iam.ProviderConversionRuleRemote[];
    }

    export interface ProviderConversionRuleLocal {
        group: string;
        username: string;
    }

    export interface ProviderConversionRuleRemote {
        attribute: string;
        condition: string;
        values: string[];
    }

}

export namespace Ims {
    export interface GetImagesImage {
        __supportAgentList: string;
        activeAt: string;
        architecture: string;
        backupId: string;
        containerFormat: string;
        createdAt: string;
        dataOrigin: string;
        description: string;
        diskFormat: string;
        enterpriseProjectId: string;
        file: string;
        id: string;
        imageType: string;
        maxRamMb: number;
        minDiskGb: number;
        minRamMb: number;
        name: string;
        os: string;
        osVersion: string;
        owner: string;
        protected: boolean;
        schema: string;
        sizeBytes: number;
        status: string;
        updatedAt: string;
        visibility: string;
    }

}

export namespace Mrs {
    export interface ClusterAnalysisCoreNodes {
        assignedRoles?: string[];
        autoRenew?: string;
        chargingMode: string;
        dataVolumeCount: number;
        dataVolumeSize?: number;
        dataVolumeType?: string;
        flavor: string;
        hostIps: string[];
        nodeNumber: number;
        period?: number;
        periodUnit?: string;
        rootVolumeSize: number;
        rootVolumeType: string;
    }

    export interface ClusterAnalysisTaskNodes {
        assignedRoles?: string[];
        dataVolumeCount: number;
        dataVolumeSize?: number;
        dataVolumeType?: string;
        flavor: string;
        hostIps: string[];
        nodeNumber: number;
        rootVolumeSize: number;
        rootVolumeType: string;
    }

    export interface ClusterBootstrapScript {
        /**
         * Whether the bootstrap action script runs only on active master nodes.
         */
        activeMaster: boolean;
        /**
         * Whether the bootstrap action script is executed before component start.
         */
        beforeComponentStart: boolean;
        /**
         * Whether the bootstrap action script involves root user operations.
         */
        executeNeedSudoRoot: boolean;
        /**
         * The action after the bootstrap action script fails to be executed.
         */
        failAction: string;
        /**
         * Name of a bootstrap action script.
         */
        name: string;
        /**
         * Name of the node group where the bootstrap action script is executed.
         */
        nodes: string[];
        /**
         * Bootstrap action script parameters.
         */
        parameters?: string;
        /**
         * The execution time of one bootstrap action script, in RFC-3339 format.
         */
        startTime: string;
        /**
         * The status of one bootstrap action script.
         */
        state: string;
        /**
         * Path of a bootstrap action script. Set this parameter to an OBS bucket path or a local VM path.
         */
        uri: string;
    }

    export interface ClusterComponentConfig {
        configs: outputs.Mrs.ClusterComponentConfigConfig[];
        name: string;
    }

    export interface ClusterComponentConfigConfig {
        configFileName: string;
        key: string;
        value: string;
    }

    export interface ClusterCustomNode {
        assignedRoles?: string[];
        autoRenew?: string;
        chargingMode: string;
        dataVolumeCount: number;
        dataVolumeSize?: number;
        dataVolumeType?: string;
        flavor: string;
        groupName: string;
        hostIps: string[];
        nodeNumber: number;
        period?: number;
        periodUnit?: string;
        rootVolumeSize: number;
        rootVolumeType: string;
    }

    export interface ClusterExternalDatasource {
        componentName: string;
        dataConnectionId?: string;
        roleType: string;
        sourceType: string;
    }

    export interface ClusterMasterNodes {
        assignedRoles?: string[];
        autoRenew?: string;
        chargingMode: string;
        dataVolumeCount: number;
        dataVolumeSize?: number;
        dataVolumeType?: string;
        flavor: string;
        hostIps: string[];
        nodeNumber: number;
        period?: number;
        periodUnit?: string;
        rootVolumeSize: number;
        rootVolumeType: string;
    }

    export interface ClusterSmnNotify {
        /**
         * The subscription rule name.
         */
        subscriptionName: string;
        /**
         * The Uniform Resource Name (URN) of the topic.
         */
        topicUrn: string;
    }

    export interface ClusterStreamingCoreNodes {
        assignedRoles?: string[];
        autoRenew?: string;
        chargingMode: string;
        dataVolumeCount: number;
        dataVolumeSize?: number;
        dataVolumeType?: string;
        flavor: string;
        hostIps: string[];
        nodeNumber: number;
        period?: number;
        periodUnit?: string;
        rootVolumeSize: number;
        rootVolumeType: string;
    }

    export interface ClusterStreamingTaskNodes {
        assignedRoles?: string[];
        dataVolumeCount: number;
        dataVolumeSize?: number;
        dataVolumeType?: string;
        flavor: string;
        hostIps: string[];
        nodeNumber: number;
        rootVolumeSize: number;
        rootVolumeType: string;
    }

}

export namespace Nat {
    export interface GatewaySessionConf {
        /**
         * The ICMP session expiration time.
         */
        icmpSessionExpireTime: number;
        /**
         * The TCP session expiration time.
         */
        tcpSessionExpireTime: number;
        /**
         * The duration of TIME_WAIT state when TCP connection is closed.
         */
        tcpTimeWaitTime: number;
        /**
         * The UDP session expiration time.
         */
        udpSessionExpireTime: number;
    }

}

export namespace Obs {
    export interface BucketCorsRule {
        allowedHeaders?: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposeHeaders?: string[];
        maxAgeSeconds?: number;
    }

    export interface BucketLifecycleRule {
        abortIncompleteMultipartUploads?: outputs.Obs.BucketLifecycleRuleAbortIncompleteMultipartUpload[];
        enabled: boolean;
        expirations?: outputs.Obs.BucketLifecycleRuleExpiration[];
        name: string;
        noncurrentVersionExpirations?: outputs.Obs.BucketLifecycleRuleNoncurrentVersionExpiration[];
        noncurrentVersionTransitions?: outputs.Obs.BucketLifecycleRuleNoncurrentVersionTransition[];
        prefix?: string;
        transitions?: outputs.Obs.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleAbortIncompleteMultipartUpload {
        days: number;
    }

    export interface BucketLifecycleRuleExpiration {
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionExpiration {
        days: number;
    }

    export interface BucketLifecycleRuleNoncurrentVersionTransition {
        days: number;
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        days: number;
        storageClass: string;
    }

    export interface BucketLogging {
        /**
         * schema: Required
         */
        agency: string;
        targetBucket: string;
        targetPrefix?: string;
    }

    export interface BucketStorageInfo {
        objectNumber: number;
        size: number;
    }

    export interface BucketWebsite {
        errorDocument?: string;
        indexDocument?: string;
        redirectAllRequestsTo?: string;
        routingRules?: string;
    }

    export interface GetBucketsBucket {
        bucket: string;
        createdAt: string;
        enterpriseProjectId: string;
        region: string;
        storageClass: string;
    }

}

export namespace Rds {
    export interface BackupDatabase {
        /**
         * Database to be backed up for Microsoft SQL Server.
         */
        name: string;
    }

    export interface GetBackupsBackup {
        /**
         * Whether a DDM instance has been associated.
         */
        associatedWithDdm: boolean;
        /**
         * Backup start time in the "yyyy-mm-ddThh:mm:ssZ" format.
         */
        beginTime: string;
        /**
         * Database been backed up.
         */
        databases: outputs.Rds.GetBackupsBackupDatabase[];
        datastores: outputs.Rds.GetBackupsBackupDatastore[];
        /**
         * Backup end time in the "yyyy-mm-ddThh:mm:ssZ" format.
         */
        endTime: string;
        /**
         * Backup ID.
         */
        id: string;
        /**
         * RDS instance ID.
         */
        instanceId: string;
        /**
         * Backup name.
         */
        name: string;
        /**
         * Backup size in KB.
         */
        size: number;
        /**
         * Backup status.
         */
        status: string;
        /**
         * Backup type.
         */
        type: string;
    }

    export interface GetBackupsBackupDatabase {
        /**
         * Database to be backed up for Microsoft SQL Server.
         */
        name: string;
    }

    export interface GetBackupsBackupDatastore {
        /**
         * DB engine.
         */
        type: string;
        /**
         * DB engine version.
         */
        version: string;
    }

    export interface GetEngineVersionsVersion {
        id: string;
        name: string;
    }

    export interface GetFlavorsFlavor {
        availabilityZones: string[];
        dbVersions: string[];
        groupType: string;
        id: string;
        instanceMode: string;
        memory: number;
        /**
         * @deprecated use instanceMode instead
         */
        mode: string;
        name: string;
        vcpus: number;
    }

    export interface GetInstancesInstance {
        availabilityZones: string[];
        backupStrategies: outputs.Rds.GetInstancesInstanceBackupStrategy[];
        created: string;
        dbs: outputs.Rds.GetInstancesInstanceDb[];
        enterpriseProjectId: string;
        fixedIp: string;
        flavor: string;
        haReplicationMode: string;
        id: string;
        name: string;
        nodes: outputs.Rds.GetInstancesInstanceNode[];
        paramGroupId: string;
        privateIps: string[];
        publicIps: string[];
        region: string;
        securityGroupId: string;
        sslEnable: boolean;
        status: string;
        subnetId: string;
        tags: {[key: string]: string};
        timeZone: string;
        volumes: outputs.Rds.GetInstancesInstanceVolume[];
        vpcId: string;
    }

    export interface GetInstancesInstanceBackupStrategy {
        keepDays: number;
        startTime: string;
    }

    export interface GetInstancesInstanceDb {
        port: number;
        type: string;
        userName: string;
        version: string;
    }

    export interface GetInstancesInstanceNode {
        availabilityZone: string;
        id: string;
        name: string;
        role: string;
        status: string;
    }

    export interface GetInstancesInstanceVolume {
        diskEncryptionId: string;
        size: number;
        type: string;
    }

    export interface GetPgAccountsUser {
        attributes: outputs.Rds.GetPgAccountsUserAttribute[];
        description: string;
        memberofs: string[];
        name: string;
    }

    export interface GetPgAccountsUserAttribute {
        rolbypassrls: boolean;
        rolcanlogin: boolean;
        rolconnlimit: number;
        rolcreatedb: boolean;
        rolcreaterole: boolean;
        rolinherit: boolean;
        rolreplication: boolean;
        rolsuper: boolean;
    }

    export interface GetPgDatabasesDatabase {
        characterSet: string;
        description: string;
        lcCollate: string;
        name: string;
        owner: string;
        size: number;
    }

    export interface GetPgPluginsPlugin {
        /**
         * Indicates whether the plugin has been created.
         */
        created: boolean;
        /**
         * Indicates the plugin description.
         */
        description: string;
        /**
         * Indicates the plugin name.
         */
        name: string;
        /**
         * Indicates the dependent preloaded library.
         */
        sharedPreloadLibraries: string;
        /**
         * Indicates the plugin version.
         */
        version: string;
    }

    export interface GetPgSqlLimitsSqlLimit {
        /**
         * Indicates the ID of SQL limit.
         */
        id: string;
        /**
         * Indicates whether the SQL limit is effective.
         */
        isEffective: boolean;
        /**
         * Indicates the number of SQL statements executed simultaneously.
         */
        maxConcurrency: number;
        /**
         * Indicates the max waiting time in seconds.
         */
        maxWaiting: number;
        /**
         * Indicates the query ID.
         */
        queryId: string;
        /**
         * Indicates the text form of SQL statement.
         */
        queryString: string;
        /**
         * Indicates the query order for names that are not schema qualified.
         */
        searchPath: string;
    }

    export interface GetStorageTypesStorageType {
        /**
         * The status details of the AZs to which the specification belongs.
         */
        azStatus: {[key: string]: string};
        /**
         * Storage type.
         */
        name: string;
        /**
         * Performance specifications.
         */
        supportComputeGroupTypes: string[];
    }

    export interface InstanceBackupStrategy {
        /**
         * schema: Required
         */
        keepDays: number;
        period: string;
        startTime: string;
    }

    export interface InstanceDb {
        password?: string;
        port: number;
        type: string;
        userName: string;
        version: string;
    }

    export interface InstanceMsdtcHost {
        hostName: string;
        id: string;
        ip: string;
    }

    export interface InstanceNode {
        availabilityZone: string;
        id: string;
        name: string;
        role: string;
        status: string;
    }

    export interface InstanceParameter {
        name: string;
        value: string;
    }

    export interface InstanceRestore {
        backupId: string;
        databaseName?: {[key: string]: string};
        instanceId: string;
    }

    export interface InstanceVolume {
        diskEncryptionId: string;
        limitSize?: number;
        size: number;
        triggerThreshold?: number;
        type: string;
    }

    export interface MysqlDatabasePrivilegeUser {
        /**
         * Specifies the username of the database account.
         */
        name: string;
        /**
         * Specifies the read-only permission.
         */
        readonly: boolean;
    }

    export interface MysqlDatabaseTableRestoreDatabase {
        /**
         * Specifies the name of the database after restoration.
         */
        newName: string;
        /**
         * Specifies the name of the database before restoration.
         */
        oldName: string;
    }

    export interface MysqlDatabaseTableRestoreRestoreTable {
        /**
         * Specifies the database name.
         */
        database: string;
        /**
         * Specifies the tables.
         */
        tables: outputs.Rds.MysqlDatabaseTableRestoreRestoreTableTable[];
    }

    export interface MysqlDatabaseTableRestoreRestoreTableTable {
        /**
         * Specifies the name of the table after restoration.
         */
        newName: string;
        /**
         * Specifies the name of the table before restoration.
         */
        oldName: string;
    }

    export interface ParametergroupConfigurationParameter {
        description: string;
        name: string;
        readonly: boolean;
        restartRequired: boolean;
        type: string;
        value: string;
        valueRange: string;
    }

    export interface ParametergroupDatastore {
        type: string;
        version: string;
    }

    export interface PgAccountAttribute {
        /**
         * Indicates whether a user bypasses each row-level security policy.
         */
        rolBypassRls: boolean;
        /**
         * Indicates whether a user can log in to the database.
         */
        rolCanLogin: boolean;
        /**
         * Indicates the maximum number of concurrent connections to a DB instance.
         */
        rolConnLimit: number;
        /**
         * Indicates whether a user can create a database.
         */
        rolCreateDb: boolean;
        /**
         * Indicates whether a user can create other sub-users.
         */
        rolCreateRole: boolean;
        /**
         * Indicates whether a user automatically inherits the permissions of the role to which the
         * user belongs.
         */
        rolInherit: boolean;
        /**
         * Indicates whether the user is a replication role.
         */
        rolReplication: boolean;
        /**
         * Indicates whether a user has the super-user permission.
         */
        rolSuper: boolean;
    }

    export interface PgHbaHostBasedAuthentication {
        /**
         * Specifies the client IP address.
         */
        address: string;
        /**
         * Specifies the database name.
         */
        database: string;
        /**
         * Specifies the subnet mask.
         */
        mask: string;
        /**
         * Specifies the authentication mode.
         */
        method: string;
        /**
         * Specifies the connection type.
         */
        type: string;
        /**
         * Specifies the Name of a user.
         */
        user: string;
    }

    export interface ReadReplicaInstanceDb {
        port: number;
        type: string;
        userName: string;
        version: string;
    }

    export interface ReadReplicaInstanceParameter {
        name: string;
        value: string;
    }

    export interface ReadReplicaInstanceVolume {
        /**
         * schema: Computed
         */
        diskEncryptionId: string;
        limitSize?: number;
        size: number;
        triggerThreshold?: number;
        type: string;
    }

    export interface SqlserverDatabasePrivilegeUser {
        /**
         * Specifies the username of the database account.
         */
        name: string;
        /**
         * Specifies the read-only permission.
         */
        readonly: boolean;
    }

}

export namespace Sfs {
    export interface FileSystemAccessRule {
        accessLevel: string;
        accessRuleId: string;
        accessTo: string;
        accessType: string;
        status: string;
    }

    export interface GetTurbosTurbo {
        availabilityZone: string;
        availableCapacity: string;
        cryptKeyId: string;
        enhanced: boolean;
        enterpriseProjectId: string;
        exportLocation: string;
        id: string;
        name: string;
        securityGroupId: string;
        shareProto: string;
        shareType: string;
        size: number;
        subnetId: string;
        version: string;
        vpcId: string;
    }

}

export namespace SharedApig {
    export interface ApiBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiFuncGraph {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The alias URN of the FunctionGraph function.
         */
        functionAliasUrn?: string;
        /**
         * The URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * The invocation type.
         */
        invocationType?: string;
        /**
         * The network architecture (framework) type of the FunctionGraph function.
         */
        networkType?: string;
        /**
         * The request protocol of the FunctionGraph function.
         */
        requestProtocol?: string;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The version of the FunctionGraph function.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The configaiton list of the backend parameters.
         */
        backendParams?: outputs.SharedApig.ApiFuncGraphPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.SharedApig.ApiFuncGraphPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The alias URN of the FunctionGraph function.
         */
        functionAliasUrn?: string;
        /**
         * The URN of the FunctionGraph function.
         */
        functionUrn: string;
        /**
         * The invocation mode of the FunctionGraph function.
         */
        invocationMode?: string;
        /**
         * The invocation mode of the FunctionGraph function.
         */
        invocationType?: string;
        /**
         * The name of the backend policy.
         */
        name: string;
        /**
         * The network (framework) type of the FunctionGraph function.
         */
        networkType?: string;
        /**
         * The request protocol of the FunctionGraph function.
         */
        requestProtocol?: string;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The version of the FunctionGraph function.
         */
        version?: string;
    }

    export interface ApiFuncGraphPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiFuncGraphPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface ApiMock {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The response content of the mock.
         */
        response?: string;
        /**
         * The custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The configuration list of backend parameters.
         */
        backendParams?: outputs.SharedApig.ApiMockPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.SharedApig.ApiMockPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The backend policy name.
         */
        name: string;
        /**
         * The response content of the mock.
         */
        response?: string;
        /**
         * The custom status code of the mock response.
         */
        statusCode: number;
    }

    export interface ApiMockPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiMockPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface ApiRequestParam {
        /**
         * The default value of the parameter.
         */
        default: string;
        /**
         * The parameter description.
         */
        description: string;
        /**
         * The enumerated value.
         */
        enumeration: string;
        /**
         * The parameter example.
         */
        example: string;
        /**
         * Where this parameter is located.
         */
        location?: string;
        /**
         * The maximum value or length (string parameter) for parameter.
         */
        maximum: number;
        /**
         * The minimum value or length (string parameter) for parameter.
         */
        minimum: number;
        /**
         * The name of the request parameter.
         */
        name: string;
        /**
         * The list of orchestration rules that parameter used.
         */
        orchestrations?: string[];
        /**
         * Whether to transparently transfer the parameter.
         */
        passthrough: boolean;
        /**
         * Whether this parameter is required.
         */
        required: boolean;
        /**
         * The parameter type.
         */
        type?: string;
        /**
         * Whether to enable the parameter validation.
         */
        validEnable: number;
    }

    export interface ApiWeb {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The backend service address, which consists of a domain name or IP address, and a port number.
         */
        backendAddress?: string;
        /**
         * The proxy host header.
         */
        hostHeader?: string;
        /**
         * The backend request path.
         */
        path: string;
        /**
         * The backend request method of the API.
         */
        requestMethod?: string;
        /**
         * The web protocol type of the API request.
         */
        requestProtocol?: string;
        /**
         * The number of retry attempts to request the backend service.
         */
        retryCount?: number;
        /**
         * Whether to enable two-way authentication.
         */
        sslEnable?: boolean;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The VPC channel ID.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicy {
        /**
         * The ID of the backend custom authorization.
         */
        authorizerId?: string;
        /**
         * The backend service address
         */
        backendAddress?: string;
        /**
         * The configuration list of the backend parameters.
         */
        backendParams?: outputs.SharedApig.ApiWebPolicyBackendParam[];
        /**
         * The policy conditions.
         */
        conditions: outputs.SharedApig.ApiWebPolicyCondition[];
        /**
         * The effective mode of the backend policy.
         */
        effectiveMode?: string;
        /**
         * The proxy host header.
         */
        hostHeader?: string;
        /**
         * The name of the web policy.
         */
        name: string;
        /**
         * The backend request address.
         */
        path: string;
        /**
         * The backend request method of the API.
         */
        requestMethod: string;
        /**
         * The backend request protocol.
         */
        requestProtocol?: string;
        /**
         * The number of retry attempts to request the backend service.
         */
        retryCount?: number;
        /**
         * The timeout for API requests to backend service.
         */
        timeout?: number;
        /**
         * The VPC channel ID.
         */
        vpcChannelId?: string;
    }

    export interface ApiWebPolicyBackendParam {
        /**
         * The description of the parameter.
         */
        description?: string;
        /**
         * Where the parameter is located.
         */
        location: string;
        /**
         * The parameter name.
         */
        name: string;
        systemParamType?: string;
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The value of the parameter
         */
        value: string;
    }

    export interface ApiWebPolicyCondition {
        /**
         * The cookie parameter name.
         */
        cookieName?: string;
        /**
         * The frontend authentication parameter name.
         */
        frontendAuthorizerName?: string;
        /**
         * The location of a parameter generated after orchestration.
         */
        mappedParamLocation?: string;
        /**
         * The name of a parameter generated after orchestration.
         */
        mappedParamName?: string;
        /**
         * The request parameter name.
         */
        paramName?: string;
        /**
         * The type of the backend policy.
         */
        source?: string;
        /**
         * The gateway built-in parameter name.
         */
        sysName?: string;
        /**
         * The condition type.
         */
        type?: string;
        /**
         * The value of the backend policy.
         */
        value: string;
    }

    export interface GroupEnvironment {
        /**
         * The ID of the environment to which the variables belongs.
         */
        environmentId: string;
        /**
         * The array of one or more environment variables.
         */
        variables: outputs.SharedApig.GroupEnvironmentVariable[];
    }

    export interface GroupEnvironmentVariable {
        /**
         * The ID of the variable that the group has.
         */
        id: string;
        /**
         * The variable name.
         */
        name: string;
        /**
         * The variable value.
         */
        value: string;
        /**
         * schema: Deprecated; The ID of the variable that the group has.
         *
         * @deprecated Use 'id' instead
         */
        variableId: string;
    }

    export interface GroupUrlDomain {
        /**
         * Whether to enable redirection from HTTP to HTTPS.
         */
        isHttpRedirectToHttps: boolean;
        /**
         * The minimum SSL protocol version.
         */
        minSslVersion: string;
        /**
         * The associated domain name.
         */
        name: string;
    }

}

export namespace Vpc {
    export interface AddressGroupIpExtraSet {
        ip: string;
        remarks?: string;
    }

    export interface BandwidthPublicip {
        id: string;
        ipAddress: string;
        ipVersion: number;
        type: string;
    }

    export interface EipBandwidth {
        /**
         * Whether the bandwidth is billed by traffic or by bandwidth size.
         */
        chargeMode: string;
        /**
         * The shared bandwidth ID.
         */
        id: string;
        /**
         * The dedicated bandwidth name.
         */
        name: string;
        /**
         * Whether the bandwidth is dedicated or shared.
         */
        shareType: string;
        /**
         * The dedicated bandwidth size.
         */
        size: number;
    }

    export interface EipPublicip {
        /**
         * The EIP address to be assigned.
         */
        ipAddress: string;
        /**
         * The IP version.
         */
        ipVersion: number;
        /**
         * schema: Deprecated
         */
        portId: string;
        /**
         * The EIP type.
         */
        type?: string;
    }

    export interface GetAddressGroupsAddressGroup {
        /**
         * IP address sets in an IP address group.
         */
        addresses: string[];
        /**
         * Time when the IP address group is created.
         */
        createdAt: string;
        /**
         * The supplementary information about the IP address group.
         */
        description: string;
        /**
         * Enterprise project ID.
         */
        enterpriseProjectId: string;
        /**
         * IP address group ID, which uniquely identifies the IP address group.
         */
        id: string;
        /**
         * IP addresses and their remarks in an IP address group.
         */
        ipExtraSets: outputs.Vpc.GetAddressGroupsAddressGroupIpExtraSet[];
        /**
         * Whether it is an IPv4 or IPv6 address group.
         */
        ipVersion: number;
        /**
         * Maximum number of entries in an address group,
         */
        maxCapacity: number;
        /**
         * IP address group name.
         */
        name: string;
        /**
         * The status of IP address group.
         */
        status: string;
        /**
         * The status details of IP address group.
         */
        statusMessage: string;
        /**
         * Time when the IP address group was last updated.
         */
        updatedAt: string;
    }

    export interface GetAddressGroupsAddressGroupIpExtraSet {
        /**
         * An IP address, IP address range, or CIDR block.
         */
        ip: string;
        /**
         * Provides supplementary information about the IP address, IP address range, or CIDR block.
         */
        remarks: string;
    }

    export interface GetRouteTableRoute {
        description: string;
        destination: string;
        nexthop: string;
        type: string;
    }

    export interface GetRoutesRoute {
        /**
         * The route destination.
         */
        destination: string;
        /**
         * The route ID.
         */
        id: string;
        /**
         * The next hop of the route.
         */
        nexthop: string;
        /**
         * The route type.
         */
        type: string;
        /**
         * The ID of the VPC to which the route belongs.
         */
        vpcId: string;
    }

    export interface GetSecgroupRule {
        action: string;
        description: string;
        direction: string;
        ethertype: string;
        id: string;
        /**
         * schema: Deprecated
         */
        portRangeMax: number;
        /**
         * schema: Deprecated
         */
        portRangeMin: number;
        ports: string;
        priority: number;
        protocol: string;
        remoteAddressGroupId: string;
        remoteGroupId: string;
        remoteIpPrefix: string;
    }

    export interface GetSecgroupsSecurityGroup {
        createdAt: string;
        description: string;
        enterpriseProjectId: string;
        id: string;
        name: string;
        updatedAt: string;
    }

    export interface GetSubnetsSubnet {
        availabilityZone: string;
        cidr: string;
        description: string;
        dhcpEnable: boolean;
        dnsLists: string[];
        gatewayIp: string;
        id: string;
        ipv4SubnetId: string;
        ipv6Cidr: string;
        ipv6Enable: boolean;
        ipv6Gateway: string;
        ipv6SubnetId: string;
        name: string;
        primaryDns: string;
        secondaryDns: string;
        status: string;
        /**
         * schema: Deprecated
         */
        subnetId: string;
        tags: {[key: string]: string};
        vpcId: string;
    }

    export interface GetVpcRoute {
        destination: string;
        nexthop: string;
    }

    export interface GetVpcsVpc {
        cidr: string;
        description: string;
        enterpriseProjectId: string;
        id: string;
        name: string;
        secondaryCidrs: string[];
        status: string;
        tags: {[key: string]: string};
    }

    export interface RouteTableRoute {
        description?: string;
        destination: string;
        nexthop: string;
        type: string;
    }

    export interface SecgroupRule {
        action: string;
        description: string;
        direction: string;
        ethertype: string;
        id: string;
        /**
         * schema: Deprecated
         */
        portRangeMax: number;
        /**
         * schema: Deprecated
         */
        portRangeMin: number;
        ports: string;
        priority: number;
        protocol: string;
        remoteAddressGroupId: string;
        remoteGroupId: string;
        remoteIpPrefix: string;
    }

    export interface VpcRoute {
        destination: string;
        nexthop: string;
    }

}

export namespace Vpcep {
    export interface GetPublicServicesService {
        id: string;
        isCharge: boolean;
        owner: string;
        serviceName: string;
        serviceType: string;
    }

    export interface ServiceConnection {
        description: string;
        domainId: string;
        endpointId: string;
        packetId: number;
        status: string;
    }

    export interface ServicePortMapping {
        protocol?: string;
        /**
         * schema: Required
         */
        servicePort?: number;
        /**
         * schema: Required
         */
        terminalPort?: number;
    }

}

export namespace config {
    export interface AssumeRole {
        agencyName: string;
        domainName: string;
    }

}
