# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlarmruleAlarmActionArgs',
    'AlarmruleAlarmActionArgsDict',
    'AlarmruleConditionArgs',
    'AlarmruleConditionArgsDict',
    'AlarmruleInsufficientdataActionArgs',
    'AlarmruleInsufficientdataActionArgsDict',
    'AlarmruleMetricArgs',
    'AlarmruleMetricArgsDict',
    'AlarmruleMetricDimensionArgs',
    'AlarmruleMetricDimensionArgsDict',
    'AlarmruleOkActionArgs',
    'AlarmruleOkActionArgsDict',
]

MYPY = False

if not MYPY:
    class AlarmruleAlarmActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        specifies the list of objects to be notified if the alarm status changes, the
        maximum length is 5. If `type` is set to *notification*, the value of notification_list cannot be empty. If `type` is
        set to *autoscaling*, the value of notification_list must be **[]**
        and the value of namespace must be *SYS.AS*.

        Note: to enable the *autoscaling* alarm rules take effect, you must bind scaling policies.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of action triggered by an alarm. the
        value can be *notification* or *autoscaling*.
        + notification: indicates that a notification will be sent to the user.
        + autoscaling: indicates that a scaling action will be triggered.
        """
elif False:
    AlarmruleAlarmActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleAlarmActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notification_lists: specifies the list of objects to be notified if the alarm status changes, the
               maximum length is 5. If `type` is set to *notification*, the value of notification_list cannot be empty. If `type` is
               set to *autoscaling*, the value of notification_list must be **[]**
               and the value of namespace must be *SYS.AS*.
               
               Note: to enable the *autoscaling* alarm rules take effect, you must bind scaling policies.
        :param pulumi.Input[_builtins.str] type: Specifies the type of action triggered by an alarm. the
               value can be *notification* or *autoscaling*.
               + notification: indicates that a notification will be sent to the user.
               + autoscaling: indicates that a scaling action will be triggered.
        """
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        specifies the list of objects to be notified if the alarm status changes, the
        maximum length is 5. If `type` is set to *notification*, the value of notification_list cannot be empty. If `type` is
        set to *autoscaling*, the value of notification_list must be **[]**
        and the value of namespace must be *SYS.AS*.

        Note: to enable the *autoscaling* alarm rules take effect, you must bind scaling policies.
        """
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of action triggered by an alarm. the
        value can be *notification* or *autoscaling*.
        + notification: indicates that a notification will be sent to the user.
        + autoscaling: indicates that a scaling action will be triggered.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmruleConditionArgsDict(TypedDict):
        comparison_operator: pulumi.Input[_builtins.str]
        """
        Specifies the comparison condition of alarm thresholds. The value can be >,
        =, <, >=, or <=.
        """
        count: pulumi.Input[_builtins.int]
        """
        Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
        """
        filter: pulumi.Input[_builtins.str]
        """
        Specifies the data rollup methods. The value can be max, min, average, sum, and vaiance.
        """
        period: pulumi.Input[_builtins.int]
        """
        Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
        and 86400.

        Note: If period is set to 1, the raw metric data is used to determine whether to generate an alarm. When the value of
        `alarm_type` is **EVENT.SYS** or **EVENT.CUSTOM**, period can be set to 0.
        """
        value: pulumi.Input[_builtins.int]
        """
        Specifies the alarm threshold. The value ranges from 0 to Number of
        1.7976931348623157e+108.
        """
        suppress_duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the interval for triggering an alarm if the alarm persists.
        Possible values are as follows:
        + **0**: Cloud Eye triggers the alarm only once;
        + **300**: Cloud Eye triggers the alarm every 5 minutes;
        + **600**: Cloud Eye triggers the alarm every 10 minutes;
        + **900**: Cloud Eye triggers the alarm every 15 minutes;
        + **1800**: Cloud Eye triggers the alarm every 30 minutes;
        + **3600**: Cloud Eye triggers the alarm every hour;
        + **10800**: Cloud Eye triggers the alarm every 3 hours;
        + **21600**: Cloud Eye triggers the alarm every 6 hours;
        + **43200**: Cloud Eye triggers the alarm every 12 hour;
        + **86400**: Cloud Eye triggers the alarm every day.

        The default value is **0**.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the data unit.
        """
elif False:
    AlarmruleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleConditionArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[_builtins.str],
                 count: pulumi.Input[_builtins.int],
                 filter: pulumi.Input[_builtins.str],
                 period: pulumi.Input[_builtins.int],
                 value: pulumi.Input[_builtins.int],
                 suppress_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comparison_operator: Specifies the comparison condition of alarm thresholds. The value can be >,
               =, <, >=, or <=.
        :param pulumi.Input[_builtins.int] count: Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
        :param pulumi.Input[_builtins.str] filter: Specifies the data rollup methods. The value can be max, min, average, sum, and vaiance.
        :param pulumi.Input[_builtins.int] period: Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
               and 86400.
               
               Note: If period is set to 1, the raw metric data is used to determine whether to generate an alarm. When the value of
               `alarm_type` is **EVENT.SYS** or **EVENT.CUSTOM**, period can be set to 0.
        :param pulumi.Input[_builtins.int] value: Specifies the alarm threshold. The value ranges from 0 to Number of
               1.7976931348623157e+108.
        :param pulumi.Input[_builtins.int] suppress_duration: Specifies the interval for triggering an alarm if the alarm persists.
               Possible values are as follows:
               + **0**: Cloud Eye triggers the alarm only once;
               + **300**: Cloud Eye triggers the alarm every 5 minutes;
               + **600**: Cloud Eye triggers the alarm every 10 minutes;
               + **900**: Cloud Eye triggers the alarm every 15 minutes;
               + **1800**: Cloud Eye triggers the alarm every 30 minutes;
               + **3600**: Cloud Eye triggers the alarm every hour;
               + **10800**: Cloud Eye triggers the alarm every 3 hours;
               + **21600**: Cloud Eye triggers the alarm every 6 hours;
               + **43200**: Cloud Eye triggers the alarm every 12 hour;
               + **86400**: Cloud Eye triggers the alarm every day.
               
               The default value is **0**.
        :param pulumi.Input[_builtins.str] unit: Specifies the data unit.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "value", value)
        if suppress_duration is not None:
            pulumi.set(__self__, "suppress_duration", suppress_duration)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the comparison condition of alarm thresholds. The value can be >,
        =, <, >=, or <=.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the data rollup methods. The value can be max, min, average, sum, and vaiance.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
        and 86400.

        Note: If period is set to 1, the raw metric data is used to determine whether to generate an alarm. When the value of
        `alarm_type` is **EVENT.SYS** or **EVENT.CUSTOM**, period can be set to 0.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the alarm threshold. The value ranges from 0 to Number of
        1.7976931348623157e+108.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="suppressDuration")
    def suppress_duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the interval for triggering an alarm if the alarm persists.
        Possible values are as follows:
        + **0**: Cloud Eye triggers the alarm only once;
        + **300**: Cloud Eye triggers the alarm every 5 minutes;
        + **600**: Cloud Eye triggers the alarm every 10 minutes;
        + **900**: Cloud Eye triggers the alarm every 15 minutes;
        + **1800**: Cloud Eye triggers the alarm every 30 minutes;
        + **3600**: Cloud Eye triggers the alarm every hour;
        + **10800**: Cloud Eye triggers the alarm every 3 hours;
        + **21600**: Cloud Eye triggers the alarm every 6 hours;
        + **43200**: Cloud Eye triggers the alarm every 12 hour;
        + **86400**: Cloud Eye triggers the alarm every day.

        The default value is **0**.
        """
        return pulumi.get(self, "suppress_duration")

    @suppress_duration.setter
    def suppress_duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "suppress_duration", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the data unit.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class AlarmruleInsufficientdataActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        type: pulumi.Input[_builtins.str]
elif False:
    AlarmruleInsufficientdataActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleInsufficientdataActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmruleMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        """
        Specifies the metric name of the condition. The value can be a string of
        1 to 64 characters that must start with a letter and contain only letters, digits, and underscores (_).
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Specifies the namespace in **service.item** format. **service** and **item**
        each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
        Changing this creates a new resource.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgsDict']]]]
        """
        Specifies the list of metric dimensions. The structure is described below.
        """
elif False:
    AlarmruleMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] metric_name: Specifies the metric name of the condition. The value can be a string of
               1 to 64 characters that must start with a letter and contain only letters, digits, and underscores (_).
        :param pulumi.Input[_builtins.str] namespace: Specifies the namespace in **service.item** format. **service** and **item**
               each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
               Changing this creates a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgs']]] dimensions: Specifies the list of metric dimensions. The structure is described below.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the metric name of the condition. The value can be a string of
        1 to 64 characters that must start with a letter and contain only letters, digits, and underscores (_).
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the namespace in **service.item** format. **service** and **item**
        each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
        Changing this creates a new resource.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgs']]]]:
        """
        Specifies the list of metric dimensions. The structure is described below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)


if not MYPY:
    class AlarmruleMetricDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the dimension name. The value can be a string of 1 to 32 characters
        that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the dimension value. The value can be a string of 1 to 64 characters
        that must start with a letter or a number and contain only letters, digits, underscores (_), and hyphens (-).
        """
elif False:
    AlarmruleMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleMetricDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the dimension name. The value can be a string of 1 to 32 characters
               that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        :param pulumi.Input[_builtins.str] value: Specifies the dimension value. The value can be a string of 1 to 64 characters
               that must start with a letter or a number and contain only letters, digits, underscores (_), and hyphens (-).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension name. The value can be a string of 1 to 32 characters
        that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension value. The value can be a string of 1 to 64 characters
        that must start with a letter or a number and contain only letters, digits, underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlarmruleOkActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        specifies the list of objects to be notified if the alarm status changes, the
        maximum length is 5.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of action triggered by an alarm. the value is notification.
        notification: indicates that a notification will be sent to the user.
        """
elif False:
    AlarmruleOkActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleOkActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notification_lists: specifies the list of objects to be notified if the alarm status changes, the
               maximum length is 5.
        :param pulumi.Input[_builtins.str] type: Specifies the type of action triggered by an alarm. the value is notification.
               notification: indicates that a notification will be sent to the user.
        """
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        specifies the list of objects to be notified if the alarm status changes, the
        maximum length is 5.
        """
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of action triggered by an alarm. the value is notification.
        notification: indicates that a notification will be sent to the user.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


